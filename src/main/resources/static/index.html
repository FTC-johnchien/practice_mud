<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>HTML MUD 測試客戶端</title>
    <style>
        body { background-color: #1a1a1a; color: #00ff00; font-family: 'Courier New', monospace; display: flex; flex-direction: column; height: 100vh; margin: 0; padding: 20px; box-sizing: border-box; }
        #output { flex-grow: 1; border: 1px solid #333; padding: 10px; overflow-y: auto; margin-bottom: 10px; white-space: pre-wrap; }
        #input-area { display: flex; gap: 10px; }
        input { background: #000; color: #00ff00; border: 1px solid #00ff00; padding: 10px; flex-grow: 1; outline: none; }
        button { background: #00ff00; color: #000; border: none; padding: 10px 20px; cursor: pointer; font-weight: bold; }
        .status { color: #888; font-size: 0.8em; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="status" id="status">狀態: 尚未連線</div>
    <div id="output"></div>
    <div id="input-area">
        <input type="text" id="commandInput" placeholder="輸入指令..." autofocus>
        <button onclick="sendCommand()">發送</button>
    </div>

    <script>
        let socket;
        const output = document.getElementById('output');
        const status = document.getElementById('status');
        const input = document.getElementById('commandInput');

        function connect() {
            // 連線至 WebSocket 端點
            socket = new WebSocket('ws://' + window.location.host + '/ws');

            socket.onopen = () => {
                status.innerText = '狀態: 已連線至 ' + window.location.host;
                log('>>> 系統：已建立連線');
            };

            socket.onmessage = (event) => {
                log(event.data);
            };

            socket.onclose = () => {
                status.innerText = '狀態: 連線已中斷';
                log('>>> 系統：連線已關閉');
                // 3秒後嘗試重連
                // setTimeout(connect, 3000);
            };

            socket.onerror = (error) => {
                log('>>> 錯誤：' + error.message);
            };
        }

        // ANSI 轉 HTML 解析器
        function ansiToHtml(text) {
            const colors = {
                '30': '#000000', '31': '#ff5555', '32': '#55ff55', '33': '#ffff55',
                '34': '#5555ff', '35': '#ff55ff', '36': '#55ffff', '37': '#ffffff'
            };

            // 1. 先進行 HTML 轉義防止 XSS
            let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // 2. 解析 ANSI 逃逸字元 (Regex 匹配 \x1B[...m)
            html = html.replace(/\x1B\[(\d+)m/g, (match, code) => {
                if (code === '0') return '</span>';
                if (code === '1') return '<span style="font-weight:bold">';
                const color = colors[code];
                return color ? `<span style="color:${color}">` : '';
            });

            return '<span>' + html + '</span>';
        }

        function log(message) {
            const div = document.createElement('div');
            div.innerHTML = ansiToHtml(message);
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function sendCommand() {
            const cmd = input.value.trim();
            if (cmd && socket.readyState === WebSocket.OPEN) {
                socket.send(cmd);
                log('> ' + cmd);
                input.value = '';
            }
        }

        // 監聽 Enter 鍵
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendCommand();
        });

        // 初始化連線
        connect();
    </script>
</body>
</html>