

--- File: HtmlmudApplication.java ---

package com.example.htmlmud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class HtmlmudApplication {

  public static void main(String[] args) {
    SpringApplication.run(HtmlmudApplication.class, args);
  }

}


--- File: CommandDispatcher.java ---

package com.example.htmlmud.application.command;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.annotation.CommandAlias;
import com.example.htmlmud.application.command.impl.MoveCommand;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.Direction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class CommandDispatcher {

  // 指令註冊表: "look" -> LookCommand Object
  private final Map<String, PlayerCommand> commandMap = new HashMap<>();

  // Spring 會自動注入所有實作 PlayerCommand 的 Bean (LookCommand, MoveCommand...)
  public CommandDispatcher(List<PlayerCommand> commands) {
    for (PlayerCommand cmd : commands) {
      // 1. 註冊主鍵 (例如 "look", "move")
      register(cmd.getKey(), cmd);

      // 2. 【核心修改】檢查是否有 Alias 註解
      if (cmd.getClass().isAnnotationPresent(CommandAlias.class)) {
        CommandAlias annotation = cmd.getClass().getAnnotation(CommandAlias.class);

        // 3. 註冊所有別名
        for (String alias : annotation.value()) {
          register(alias, cmd);
        }
      }

      // 額外處理 MoveCommand 的方向縮寫 (因為這不是單純的別名，還涉及參數轉換)
      // 建議還是保留在程式碼裡特殊處理，或者用另一種 @DirectionAlias 處理
      registerDirectionAliases(commands);
    }
  }

  private void register(String key, PlayerCommand cmd) {
    commandMap.put(key.toLowerCase(), cmd);
  }

  // 處理方向鍵 (n, s, e, w)
  private void registerDirectionAliases(List<PlayerCommand> commands) {
    // 找到 MoveCommand
    PlayerCommand moveCmd =
        commands.stream().filter(c -> c.getKey().equals("move")).findFirst().orElse(null);

    if (moveCmd != null) {
      for (Direction d : Direction.values()) {
        register(d.getShortName(), moveCmd); // n, s, e, w
        register(d.getFullName(), moveCmd); // north, south...
      }
    }
  }

  /**
   * 核心派發邏輯
   *
   * @param input 玩家輸入的原始字串，例如 "look north" 或 "kill goblin"
   */
  public void dispatch(PlayerActor actor, String input) {
    if (input == null || input.isBlank())
      return;

    // 1. 切割字串： "kill goblin" -> key="kill", args="goblin"
    String[] parts = input.trim().split("\\s+", 2); // 只切成兩份
    String key = parts[0].toLowerCase();
    String args = parts.length > 1 ? parts[1] : "";

    log.info("key:{}, args:{}", key, args);
    // 2. 查找指令
    PlayerCommand command = commandMap.get(key);

    if (command != null) {
      // 【關鍵修正】
      // 如果玩家輸入的是 "n"，我們需要把 "n" 當作參數傳給 MoveCommand
      // 或者是 MoveCommand 內部 logic 要知道 "n" 等於 "move n"
      if (command instanceof MoveCommand && Direction.parse(key) != null) {
        // 如果指令本身就是方向 (例如輸入 "n")，把 key 當作 args 傳進去
        command.execute(actor, key);
      } else {
        // 否則正常執行 (例如 "move north")
        command.execute(actor, args);
      }
    } else {
      // 4. 找不到指令的預設處理
      actor.reply("我不懂 '" + key + "' 是什麼意思。輸入 'help' 查看指令列表。");
    }
  }
}


--- File: PlayerCommand.java ---

package com.example.htmlmud.application.command;

import com.example.htmlmud.domain.actor.impl.PlayerActor;

public interface PlayerCommand {

  // 該指令的觸發關鍵字，例如 "look", "l"
  String getKey();

  // 執行邏輯
  // actor: 誰發出的指令 (操作者 Context)
  // args: 指令參數 (例如 'look north' 的 'north')
  void execute(PlayerActor actor, String args);

  // 描述 (給 help 指令用)
  default String getDescription() {
    return "無描述";
  }
}


--- File: CommandAlias.java ---

package com.example.htmlmud.application.command.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE) // 只能放在類別上
@Retention(RetentionPolicy.RUNTIME) // 執行時期透過反射讀取
public @interface CommandAlias {
  String[] value(); // 允許傳入多個別名，例如 {"l", "see"}
}


--- File: GetCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.concurrent.CompletableFuture;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.application.command.annotation.CommandAlias;
import com.example.htmlmud.application.command.parser.TargetSelector;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.protocol.RoomMessage;
import lombok.RequiredArgsConstructor;

@Component
@CommandAlias("get")
@RequiredArgsConstructor
public class GetCommand implements PlayerCommand {

  private final WorldManager worldManager;

  private final TargetSelector targetSelector; // 注入工具

  @Override
  public String getKey() {
    return "get";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 基本檢查
    if (args.isEmpty()) {
      actor.reply("你要撿什麼？");
      return;
    }

    // 1. 準備 Future 接收結果
    CompletableFuture<GameItem> future = new CompletableFuture<>();

    // 2. 發送訊息給房間： "我要撿 'sword' (args)"
    // 注意：這裡我們還不知道房間到底有沒有劍，只傳字串
    RoomActor room = worldManager.getRoomActor(actor.getCurrentRoomId());
    room.send(new RoomMessage.TryPickItem(args, actor, future));

    // 3. 等待結果 (Virtual Thread 不會卡死)
    try {
      GameItem item = future.join();
      if (item != null) {
        actor.getInventory().add(item);
        actor.reply("你撿起了 " + item.getDisplayName());
      } else {
        actor.reply("這裡沒有看到 '" + args + "'。");
      }
    } catch (Exception e) {
      actor.reply("發生錯誤:");
    }
  }
}


--- File: KillCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.List;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.application.command.annotation.CommandAlias;
import com.example.htmlmud.application.command.parser.TargetSelector;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@CommandAlias("k")
@RequiredArgsConstructor
public class KillCommand implements PlayerCommand {

  private final WorldManager worldManager;

  private final TargetSelector targetSelector; // 注入工具

  @Override
  public String getKey() {
    return "kill";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    if (args.isBlank()) {
      actor.reply("你要攻擊誰？");
      return;
    }

    // 1. 取得房間內的怪物列表
    RoomActor room = worldManager.getRoomActor(actor.getCurrentRoomId());
    // 這裡假設 room 有 getMobsSnapshot() 回傳 List<MobActor>
    // 注意：為了線程安全，這裡最好是 Snapshot 或是能確保讀取安全的列表
    List<MobActor> mobsInRoom = room.getMobsSnapshot();

    // 2. 交給 Selector 處理複雜字串
    // args 可能是 "red goblin", "elite soldier 2"
    // TODO pvp的處理
    MobActor target = targetSelector.selectMob(mobsInRoom, args);
    if (target == null) {
      actor.reply("這裡沒有看到 '" + args + "'。");
      return;
    }
    log.info("name:{} defense: {}", target.getTemplate().name(), target.getState().defense);

    // 3. 執行戰鬥邏輯
    actor.getState().combatTargetId = target.getId();
    actor.getState().isInCombat = true;
    log.info("name:{} {}", actor.getName(), actor.getNickname());
    actor.reply("你對 " + target.getTemplate().name() + " 大喊受死吧 一邊擺出了戰鬥架式！");
    // actor.reply("你開始攻擊 " + target.getTemplate().name() + "！");
    target.onAttacked(actor);
  }
}


--- File: LookCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.List;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.application.command.annotation.CommandAlias;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.MobKind;
import com.example.htmlmud.infra.util.AnsiColor;
import com.example.htmlmud.infra.util.ColorText;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component // 註冊為 Spring Bean
@RequiredArgsConstructor
@CommandAlias({"l", "see", "ls"}) // 支援 l, see, ls
public class LookCommand implements PlayerCommand {

  private final WorldManager worldManager;

  @Override
  public String getKey() {
    return "look";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 1. 取得玩家當前位置 ID
    String roomId = actor.getCurrentRoomId();

    log.info("args:{}", args);

    // 2. 查詢房間資料 (使用 WorldManager)
    RoomActor roomActor = worldManager.getRoomActor(roomId);

    if (roomActor == null) {
      actor.reply("你處於一片虛空之中... (RoomID: " + roomId + " 不存在)");
      return;
    }

    // 3. 產生房間描述
    String roomDescription = buildRoomDescription(actor, roomActor);



    // 4. 回傳給玩家
    actor.reply(roomDescription);
  }

  private String buildRoomDescription(PlayerActor actor, RoomActor room) {
    StringBuilder sb = new StringBuilder();

    // 標題 (亮白色)
    sb.append(ColorText.room("=== " + room.getTemplate().name() + " ===")).append("\r\n");

    // 描述 (預設色/灰色)
    sb.append(ColorText.roomDesc(room.getTemplate().description())).append("\r\n");

    // 出口 (黃色)
    sb.append(ColorText.exit("[出口]: "));
    if (room.getTemplate().exits().isEmpty()) {
      sb.append("無");
    } else {
      sb.append(String.join(", ", room.getTemplate().exits().keySet()));
    }
    sb.append("\r\n");

    // 取得房間內的生物 (玩家與怪物，經過排序)
    List<PlayerActor> players = room.getPlayersSnapshot();
    List<MobActor> mobs = room.getMobsSnapshot();
    List<GameItem> items = room.getItemsSnapshot();
    log.info("players: {}, mobs: {} items: {}", players.size(), mobs.size(), items.size());


    // 1. 篩選出 其他玩家 (亮藍色，排除自己)
    List<String> otherPlayerNames = players.stream().filter(p -> !p.getId().equals(actor.getId()))
        .map(p -> ColorText.player(p.getNickname() + "(" + p.getName() + ")")).toList();

    // 2. 篩選出 NPC (綠色顯示)
    List<String> npcNames = mobs.stream().filter(m -> m.getTemplate().kind() == MobKind.FRIENDLY)
        .map(m -> ColorText.npc(m.getTemplate().name() + "(" + m.getTemplate().aliases()[0] + ")"))
        .toList();

    // 3. 篩選出 怪物 (紅色顯示)
    List<String> monsterNames = mobs.stream().filter(
        m -> m.getTemplate().kind() == MobKind.AGGRESSIVE || m.getTemplate().kind() == MobKind.BOSS)
        .map(m -> ColorText.mob(m.getTemplate().name() + "(" + m.getTemplate().aliases()[0] + ")")) // 紅色代表危險
        .toList();

    // items
    List<String> itemNames = items.stream()
        .map(i -> ColorText.item(i.getDisplayName() + "(" + i.getTemplate().aliases()[0] + ")"))
        .toList();


    if (!otherPlayerNames.isEmpty()) {
      sb.append(ColorText.wrap(AnsiColor.BRIGHT_MAGENTA, "[玩家]: "))
          .append(String.join(", ", otherPlayerNames)).append("\r\n");
    }
    if (!npcNames.isEmpty()) {
      sb.append(ColorText.npc("[人物]: ")).append(String.join(", ", npcNames)).append("\r\n");
    }
    if (!monsterNames.isEmpty()) {
      sb.append(ColorText.wrap(AnsiColor.RED, "[怪物]: ")).append(String.join(", ", monsterNames))
          .append("\r\n");
    }
    if (!itemNames.isEmpty()) {
      sb.append(ColorText.wrap(AnsiColor.YELLOW, "[物品]: ")).append(String.join(", ", itemNames))
          .append("\r\n");
    }


    return sb.toString();
  }
}


--- File: MoveCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.concurrent.CompletableFuture;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.model.Direction;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.example.htmlmud.infra.util.AnsiColor;
import com.example.htmlmud.infra.util.ColorText;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class MoveCommand implements PlayerCommand {

  private final WorldManager worldManager;

  private final LookCommand lookCommand;


  @Override
  public String getKey() {
    return "move"; // 主鍵是 move，但我們會註冊 alias (n, s, e, w)
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 1. 解析方向
    // 玩家可能輸入 "move north" 或者直接輸入 "north" (由 Dispatcher 轉發)
    Direction dir = Direction.parse(args);

    if (dir == null) {
      actor.reply("你要往哪個方向移動？");
      return;
    }

    // 2. 取得當前房間
    String currentRoomId = actor.getCurrentRoomId();
    RoomActor currentRoom = worldManager.getRoomActor(currentRoomId);

    if (currentRoom == null) {
      actor.reply("你在一片虛空中，無法移動。");
      return;
    }

    // 3. 檢查出口
    // 假設 Room.exits 是 Map<String, Integer> (key 是 direction full name)
    // Integer nextRoomId = currentRoom.getTemplate().exits().get(dir.getFullName());
    RoomExit exit = currentRoom.getTemplate().exits().get(dir.getFullName());
    if (exit == null) {
      actor.reply("往 " + dir.getDisplayName() + " 沒有出路。");
      return;
    }

    // TODO 檢查出口限制


    // 檢查要去的房間是否存在
    String targetRoomId = exit.targetRoomId();
    RoomActor targetRoom = worldManager.getRoomActor(targetRoomId);

    if (targetRoom == null) {
      actor.reply("前方房間 " + targetRoomId + " 施工中，無法前往。");
      return;
    }


    // --- 檢查成功，開始處理移動流程 ---

    // 4. 舊房間廣播 (離場)
    currentRoom.leave(actor.getId());
    String leaveMsg = ColorText.wrap(AnsiColor.YELLOW,
        actor.getNickname() + " 往 " + dir.getDisplayName() + " 離開了。");
    worldManager.broadcastToRoom(currentRoomId, leaveMsg, actor.getId());

    // 6. 新房間廣播 (進場)
    // 計算反方向 (例如往北走，新房間的人會看到你從南方來)
    CompletableFuture<Void> future = new CompletableFuture<>();
    targetRoom.enter(actor, future);
    future.join();
    String arriveMsg = ColorText.wrap(AnsiColor.YELLOW,
        actor.getNickname() + " 從 " + dir.opposite().getDisplayName() + " 過來了。");
    worldManager.broadcastToRoom(targetRoomId, arriveMsg, actor.getId());

    // 7. 自動 Look (讓玩家看到新環境)
    // 直接調用 LookCommand 執行邏輯
    lookCommand.execute(actor, "");
  }
}


--- File: TargetSelector.java ---

package com.example.htmlmud.application.command.parser;

import java.util.List;
import java.util.function.BiPredicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.model.GameItem;

@Component
public class TargetSelector {

  // 用來解析 "name index" (例如: goblin 2)
  private static final Pattern TRAILING_NUMBER = Pattern.compile("^(.*)\\s+(\\d+)$");

  // 用來解析 "index.name" (例如: 2.goblin)
  private static final Pattern DOT_NOTATION = Pattern.compile("^(\\d+)\\.(.*)$");

  public GameItem selectItem(List<GameItem> candidates, String input) {
    return select(candidates, input, this::isMatchItem);
  }

  /**
   * 從列表中找到符合描述的目標
   *
   * @param candidates 房間裡的所有怪物 (或物品)
   * @param input 玩家輸入的字串 (例如 "elite soldier 3" 或 "2.goblin")
   * @return 找到的 Mob，若無則回傳 null
   */
  public MobActor selectMob(List<MobActor> candidates, String input) {
    return select(candidates, input, this::isMatchMob);
  }

  /**
   * 通用的選擇邏輯，減少重複程式碼
   */
  private <T> T select(List<T> candidates, String input, BiPredicate<T, String> matcher) {
    if (input == null || input.isBlank())
      return null;

    ParsedTarget parsed = parseInput(input);
    String keyword = parsed.name.toLowerCase();
    int targetIndex = parsed.index;
    int matchCount = 0;

    for (T candidate : candidates) {
      if (matcher.test(candidate, keyword)) {
        matchCount++;
        if (matchCount == targetIndex) {
          return candidate;
        }
      }
    }
    return null;
  }

  private boolean isMatchItem(GameItem item, String keyword) {
    return isMatch(item.getTemplate().name(), item.getTemplate().aliases(), keyword);
  }

  private boolean isMatchMob(MobActor mob, String keyword) {
    return isMatch(mob.getTemplate().name(), mob.getTemplate().aliases(), keyword);
  }

  private boolean isMatch(String name, String[] aliases, String keyword) {
    if (name.toLowerCase().contains(keyword))
      return true;

    if (aliases != null) {
      for (String alias : aliases) {
        if (alias.toLowerCase().contains(keyword))
          return true;
      }
    }
    return false;
  }

  // --- 解析邏輯 ---

  private record ParsedTarget(String name, int index) {
  }

  private ParsedTarget parseInput(String input) {
    input = input.trim();

    // 檢查 "2.goblin" 格式
    Matcher dotMatcher = DOT_NOTATION.matcher(input);
    if (dotMatcher.find()) {
      int idx = Integer.parseInt(dotMatcher.group(1));
      String name = dotMatcher.group(2);
      return new ParsedTarget(name, idx);
    }

    // 檢查 "goblin 2" 格式
    Matcher trailMatcher = TRAILING_NUMBER.matcher(input);
    if (trailMatcher.find()) {
      String name = trailMatcher.group(1);
      int idx = Integer.parseInt(trailMatcher.group(2));
      return new ParsedTarget(name, idx);
    }

    // 預設: 找第 1 個
    return new ParsedTarget(input, 1);
  }
}


--- File: WorldFactory.java ---

package com.example.htmlmud.application.factory;

import java.util.UUID;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadLocalRandom;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.stereotype.Service;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.infra.persistence.repository.TemplateRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class WorldFactory {

  private final ObjectProvider<GameServices> servicesProvider;

  // private final GameServices gameServices;

  // private final WorldManager worldManager;
  // private final ScheduledExecutorService scheduler;
  private final ObjectMapper objectMapper;

  private final TemplateRepository templateRepo;

  /**
   * 建立房間 Actor
   */
  public RoomActor createRoom(String roomId) {
    log.info("createRoom roomId: {}", roomId);
    RoomTemplate roomTpl = templateRepo.findRoom(roomId).orElse(null);
    if (roomTpl == null) {
      log.error("Create Room failed: RoomTemplate not found {}", roomId);
      return null;
    }

    ZoneTemplate zoneTpl = templateRepo.findZone(roomTpl.zoneId()).orElse(null);
    if (zoneTpl == null) {
      log.error("Create Room failed: ZoneTemplate not found {}", roomTpl.zoneId());
      return null;
    }

    // 這裡負責組裝：RoomActor 需要 Template + ZoneTemplate
    RoomActor room = new RoomActor(roomTpl, zoneTpl, servicesProvider.getObject(), this);
    room.start();
    return room;
  }

  /**
   * 建立怪物 Actor (包含 AI 啟動邏輯)
   */
  public MobActor createMob(String templateId) {
    // 1. 查 Template (Record)
    log.info("createMob templateId: {}", templateId);
    MobTemplate tpl = templateRepo.findMob(templateId).orElse(null);
    if (tpl == null) {
      log.error("MobTemplate ID not found: " + templateId);
      return null;
    }

    // 2. new Actor (State 自動生成)
    // MobActor mob = new MobActor(tpl);
    MobActor mob = new MobActor(tpl, servicesProvider.getObject());

    // 3. 這裡可以處理「菁英怪」或「隨機稱號」邏輯
    // if (Math.random() < 0.1) mob.setPrefix("狂暴的");

    // 4. 啟動 AI (重要：Factory 負責讓它動起來，或者由 Manager 統一啟動)
    mob.start();

    return mob;
  }

  /**
   * 建立物品實體 (處理隨機數值)
   */
  public GameItem createItem(String templateId) {
    log.info("templateId:{}", templateId);
    ItemTemplate tpl = templateRepo.findItem(templateId).orElse(null);
    if (tpl == null) {
      log.error("Create Item failed: Template not found {}", templateId);
      return null;
    }

    GameItem item = new GameItem();
    item.setId(UUID.randomUUID().toString()); // 生成唯一 ID
    item.setTemplate(tpl);
    // item.setCurrentDurability(tpl.maxDurability());
    item.setAmount(1);

    // --- 處理隨機屬性 (RNG) ---
    // 這是 Factory 最有價值的地方，不要讓 Manager 變髒
    // if (tpl.chance() < 1.0) {
    // 處理掉落率/開箱率邏輯...
    // }

    // 範例：10% 機率出現稀有屬性
    if (ThreadLocalRandom.current().nextDouble() < 0.1) {
      item.getDynamicProps().put("quality", "RARE");
      item.getDynamicProps().put("attack_bonus", 5);
    }

    return item;
  }
}


--- File: AuditLogEventListener.java ---

package com.example.htmlmud.application.listener;

import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.event.DomainEvent;
import com.example.htmlmud.domain.event.MobEvents;
import com.example.htmlmud.domain.event.PlayerEvents;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AuditLogEventListener {
  @Async // <--- 關鍵：丟到另一個 Thread (或 Virtual Thread) 執行
  @EventListener
  public void logPlayerAction(DomainEvent event) {
    // 這裡使用了 switch pattern matching (Java 21+)
    // 可以優雅地處理所有 DomainEvent
    String logMsg = switch (event) {
      case PlayerEvents.LoggedIn e -> "使用者登入: " + e.username() + " IP:" + e.ipAddress();
      case PlayerEvents.LevelUp e -> "玩家升級: " + e.newLevel();
      case MobEvents.MobDead e -> "怪物死亡: " + e.mobId();
      default -> "未知事件: " + event.getClass().getSimpleName();
    };

    // 模擬寫入 DB
    log.info("[AUDIT LOG] " + event.occurredOn() + " - " + logMsg);
  }
}


--- File: PlayerLoginListener.java ---

package com.example.htmlmud.application.listener;

import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.protocol.RoomMessage;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;

import java.util.concurrent.CompletableFuture;

@Slf4j
@Component
@RequiredArgsConstructor
public class PlayerLoginListener {

  private final WorldManager worldManager;

  @Autowired
  private ObjectMapper objectMapper;

  // @EventListener
  // public void onPlayerLogin(PlayerLoginEvent event) {
  // var entity = event.getPlayerEntity();
  // var session = event.getSession();

  // log.info("處理玩家登入事件: {}", entity.getUsername());
  /*
   * try { // 1. 建立 Actor (這裡是 Domain Logic) PlayerActor playerActor = new
   * PlayerActor(entity.getId(), session, entity.state, objectMapper);
   *
   * // 2. 設定上次位置 playerActor.setCurrentRoomId(entity.getCurrentRoomId());
   *
   * // 3. 綁定 Session (讓 WebSocketHandler 知道這個 session 有主人了) session.getAttributes().put("actor",
   * playerActor);
   *
   * // 4. 歡迎訊息 playerActor.sendText("\u001B[32m登入成功！歡迎回到 MUD 世界 (Event Driven)。\u001B[0m");
   *
   * // 5. 進入房間邏輯 var room = worldManager.getRoomActor(playerActor.getCurrentRoomId()); var future =
   * new CompletableFuture<Void>();
   *
   * // 讓玩家進入房間 // room.receive(new RoomMessage.PlayerEnter(playerActor, future));
   *
   * // 進入後自動 Look // future.thenRun(() -> playerActor.send("look"));
   *
   * } catch (Exception e) { log.error("玩家登入後續處理失敗", e); try { session.sendMessage(new
   * TextMessage("系統錯誤：無法進入世界")); } catch (Exception ignored) { } }
   */
  // }
}


--- File: QuestEventListener.java ---

package com.example.htmlmud.application.listener;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.event.PlayerEvents;

@Component
public class QuestEventListener {
  @EventListener
  public void checkLevelUpQuest(PlayerEvents.LevelUp event) {
    // 檢查該玩家是否有 "升到 10 級" 的任務
    // if (event.newLevel() >= 10) ...
    System.out.println("任務檢查: 玩家 " + event.playerId() + " 升級了。");
  }
}


--- File: SessionEventListener.java ---

package com.example.htmlmud.application.listener;

import java.io.IOException;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.event.DomainEvent.SessionEvent;
import com.example.htmlmud.infra.server.SessionRegistry;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class SessionEventListener {

  @Autowired
  private ObjectMapper objectMapper;

  @Autowired
  private SessionRegistry sessionRegistry;

  @EventListener
  public void onEstablished(SessionEvent.Established event) throws IOException {
    log.info("系統收到連線建立事件: {}", event.sessionId());

    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());

    // String welcomeMsg = """
    // \u001B[36m
    // ==========================================
    // 歡迎來到 HTML MUD (Java 25 Edition)
    // ==========================================
    // \u001B[0m
    // 請輸入以下指令開始:
    // 1. 註冊: \u001B[33mregister <帳號> <密碼>\u001B[0m
    // 2. 登入: \u001B[33mlogin <帳號> <密碼>\u001B[0m
    // """;
    String welcomeMsg = "歡迎來到 HTML MUD 世界！\r\n請輸入帳號 (或輸入 new 註冊)：";
    if (session != null && session.isOpen()) {
      String json = objectMapper.writeValueAsString(Map.of("type", "TEXT", "content", welcomeMsg));

      session.sendMessage(new TextMessage(json));
    }
  }

  @EventListener
  public void onMessageReceived(SessionEvent.MessageReceived event) {
    System.out.println("onMessageReceived");
  }

  @EventListener
  public void onClosed(SessionEvent.Closed event) {
    log.info("系統收到連線關閉事件: {} CloseStatus:{}", event.sessionId(), event.reason());
  }

}


--- File: SystemEventListener.java ---

package com.example.htmlmud.application.listener;

import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.event.DomainEvent.SystemEvent;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import com.example.htmlmud.infra.server.SessionRegistry;
import com.example.htmlmud.protocol.ConnectionState;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class SystemEventListener {

  private static final int MAX_AUTH_RETRIES = 5;

  // 基礎保留字（非指令類的關鍵字）
  private final Set<String> reservedWords = new HashSet<>(
      Set.of("new", "quit", "exit", "wizard", "admin", "system", "root", "guest", "player"));

  @Autowired
  private ObjectMapper objectMapper;

  @Autowired
  private WorldManager worldManager;

  @Autowired
  private SessionRegistry sessionRegistry;

  @Autowired
  private UserRepository userRepository;



  @EventListener
  public void onRegisterUsername(SystemEvent.RegisterUsername event) throws Exception {
    log.info("onRegisterUsername");
    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();

    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validateUsername(event.input());

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount,
            event.input());
        actor.reply("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 註冊帳號失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    // actor.setTempUsername(event.input());

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n只能包含英文字母與數字且長度必須在 6 到 32 個字元之間。\r\n請輸入密碼:";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    actor.setConnectionState(ConnectionState.CREATING_PASSWORD);
  }

  @EventListener
  public void onRegisterPassword(SystemEvent.RegisterPassword event) throws IOException {
    log.info("onRegisterPassword");

    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validatePassword(event.input());

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount,
            event.input());
        actor.reply("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 註冊密碼失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    // actor.setTempPassword(event.input());

    // 新增玩家帳密


    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n註冊完成，請重新登入。";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    actor.reply(msg);

    actor.setConnectionState(ConnectionState.CONNECTED);
  }

  @EventListener
  public void onLogin(SystemEvent.Login event) {
    log.info("onLogin");
  }

  @EventListener
  public void onAuthenticate(SystemEvent.Authenticate event) throws IOException {
    log.info("onAuthenticate");
    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    if ("new".equalsIgnoreCase(event.input())) {
      doRegister(session, actor);
    } else {
      doLoginUsername(session, actor, event);
    }
  }

  @EventListener
  public void onLogout(SystemEvent.Logout event) {}


  private void doRegister(WebSocketSession session, PlayerActor actor) throws IOException {
    log.info("doRegister");

    String msg = "【註冊流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 4 到 20 個字元之間。\r\n請輸入您想使用的帳號名稱:";
    // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
    actor.setConnectionState(ConnectionState.CREATING_USERNAME);
  }

  private void doLoginUsername(WebSocketSession session, PlayerActor actor,
      SystemEvent.Authenticate event) throws IOException {
    log.info("doLoginUsername");

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validateUsername(event.input());

    // 如果格式正確，檢查資料庫是否存在該帳號
    if (errorReason == null && !userRepository.existsByUsername(event.input())) {
      errorReason = "帳號不存在。";
    }

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 驗證失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount, event.input());
        actor.reply("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 驗證失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    // actor.setTempUsername(event.input());

    String msg = "請輸入密碼:";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    actor.setConnectionState(ConnectionState.ENTERING_PASSWORD);
  }


  /**
   * 驗證用戶名是否合法
   *
   * @return 錯誤訊息，若合法則回傳 null
   */
  private String validateUsername(String input) {
    if (input == null || input.isEmpty()) {
      return "帳號名稱不能為空。";
    }
    if (!input.matches("^[a-zA-Z]+$")) {
      log.info("{}", input);
      return "帳號名稱只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。";
    }
    if (input.length() < 4 || input.length() > 20) {
      return "帳號名稱長度必須在 4 到 20 個字元之間。";
    }
    if (reservedWords.contains(input.toLowerCase())) {
      return "「" + input + "」是系統保留字或指令，請選擇其他名稱。";
    }
    return null;
  }

  /**
   * 驗證密碼是否合法
   *
   * @param input 輸入的密碼
   * @return 錯誤訊息，若合法則回傳 null
   */
  private String validatePassword(String input) {
    if (input == null || input.isEmpty()) {
      return "密碼不能為空。";
    }
    if (!input.matches("^[a-zA-Z0-9]+$")) {
      return "密碼只能包含英文字母與數字。";
    }
    if (input.length() < 6 || input.length() > 32) {
      return "密碼長度必須在 6 到 32 個字元之間。";
    }
    return null;
  }

}


--- File: AuthService.java ---

package com.example.htmlmud.application.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.MudContext;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.entity.UserEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import com.example.htmlmud.protocol.ConnectionState;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService {

  // 基礎保留字（非指令類的關鍵字）
  private final Set<String> reservedWords = new HashSet<>(
      Set.of("new", "quit", "exit", "wizard", "admin", "system", "root", "guest", "player"));

  // 使用 BCrypt，Spring Security 內建，或者自己 new 一個
  private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

  private final PlayerService playerService;


  private final UserRepository userRepository;

  private final CharacterRepository playerRepository;


  public boolean exists(String username) {
    return userRepository.existsByUsername(username);
  }

  /**
   * 註冊新帳號
   */
  @Transactional
  public CharacterEntity register(String username, String rawPassword) {
    if (userRepository.existsByUsername(username)) {
      throw new IllegalArgumentException("帳號已存在");
    }

    LocalDateTime now = LocalDateTime.now();
    UserEntity newUser = UserEntity.builder().username(username)
        .passwordHash(passwordEncoder.encode(rawPassword)).createdAt(now).lastLoginAt(now).build();
    userRepository.save(newUser);

    CharacterEntity characterEntity = new CharacterEntity();
    characterEntity.setUid(newUser.getId());
    characterEntity.setName(username);
    characterEntity.setNickname(username); // TODO 待處理
    characterEntity.setCurrentRoomId(null);
    characterEntity.setState(new LivingState());
    characterEntity.setCreatedAt(now);
    characterEntity.setModifyAt(now);

    return playerRepository.save(characterEntity);
  }

  /**
   * 登入驗證
   */
  @Transactional
  public PlayerRecord login(String username, String rawPassword) {
    // log.info("login username:{} password: {}", username, rawPassword);
    UserEntity user = userRepository.findByUsername(username)
        .orElseThrow(() -> new IllegalArgumentException("帳號不存在"));

    if (!passwordEncoder.matches(rawPassword, user.getPasswordHash())) {
      throw new IllegalArgumentException("密碼錯誤");
    }

    // 更新最後登入時間
    user.setLastLoginAt(LocalDateTime.now());
    userRepository.save(user);
    log.info("玩家登入成功: {}", username);

    // -----------------------------------------------------------------------------
    // 進入角色設定流程
    // -----------------------------------------------------------------------------

    // 取出角色 player 資料
    return playerService.loadRecord(user.getId(), username);
  }


  /**
   * 驗證用戶名是否合法
   *
   * @return 錯誤訊息，若合法則回傳 null
   */
  public String validateUsername(String input) {
    if (input == null || input.isEmpty()) {
      return "帳號名稱不能為空。";
    }
    if (!input.matches("^[a-zA-Z]+$")) {
      return "帳號名稱只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。";
    }
    if (input.length() < 4 || input.length() > 20) {
      return "帳號名稱長度必須在 4 到 20 個字元之間。";
    }
    if (reservedWords.contains(input.toLowerCase())) {
      return "「" + input + "」是系統保留字或指令，請選擇其他名稱。";
    }
    return null;
  }

  /**
   * 驗證密碼是否合法
   *
   * @param input 輸入的密碼
   * @return 錯誤訊息，若合法則回傳 null
   */
  public String validatePassword(String input) {
    if (input == null || input.isEmpty()) {
      return "密碼不能為空。";
    }
    if (!input.matches("^[a-zA-Z0-9]+$")) {
      return "密碼只能包含英文字母與數字。";
    }
    if (input.length() < 4 || input.length() > 32) {
      return "密碼長度必須在 4 到 32 個字元之間。";
    }
    return null;
  }

}


--- File: PlayerService.java ---

package com.example.htmlmud.application.service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Service;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.mapper.PlayerMapper;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class PlayerService {

  private final UserRepository userRepository;

  private final CharacterRepository characterRepository;

  private final PlayerMapper mapper; // 注入 MapStruct

  // 模擬 DB: Username -> Password
  private final Map<String, String> userDb = new ConcurrentHashMap<>();

  // public PlayerService() {
  // // 預設一個測試帳號 (帳號: admin, 密碼: 123)
  // userDb.put("admin", "123");
  // }



  // public void register(PlayerActor actor) {

  // userDb.put(username.toLowerCase(), password);
  // }

  public boolean verifyPassword(String username, String password) {
    String stored = userDb.get(username.toLowerCase());
    return stored != null && stored.equals(password);
  }

  public PlayerRecord loadRecord(String uid, String username) {
    // 1. DB -> Entity
    CharacterEntity entity = characterRepository.findByUidAndName(uid, username)
        .orElseThrow(() -> new IllegalArgumentException("角色不存在 uid:" + uid + ", name:" + username));

    // 2. Entity -> Record (MapStruct 自動轉)
    // 注意：這裡得到的 Record 內含的 State 是 Entity 裡解序列化出來的
    return mapper.toRecord(entity);
  }
}


--- File: WorldManager.java ---

package com.example.htmlmud.application.service;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.stereotype.Service;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.factory.WorldFactory;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.SpawnRule;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.domain.service.CombatService;
import com.example.htmlmud.infra.mapper.ItemTemplateMapper;
import com.example.htmlmud.infra.persistence.repository.ItemTemplateRepository;
import com.example.htmlmud.infra.persistence.repository.RoomStateRepository;
import com.example.htmlmud.infra.persistence.repository.TemplateRepository;
import com.example.htmlmud.infra.persistence.service.PlayerPersistenceService;
import com.example.htmlmud.infra.util.IdUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PreDestroy;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class WorldManager {

  // private final ObjectProvider<GameServices> servicesProvider;

  @Getter
  private final AuthService authService;

  @Getter
  private final PlayerService playerService;

  @Getter
  private final CombatService combatService;

  @Getter
  private final WorldFactory worldFactory; // 注入 Factory

  @Getter
  private final PlayerPersistenceService playerPersistenceService;

  // private final WorldFactory worldFactory;
  private final ObjectMapper objectMapper;
  private final ResourcePatternResolver resourceResolver;
  private final RoomStateRepository roomStateRepository;
  private final ItemTemplateRepository itemTemplateRepository;
  private final ItemTemplateMapper itemTemplateMapper;

  // 1. Static Data Cache: 存放唯讀的 Room 設定檔 (POJO/Record)
  // 雖然伺服器通常會載入全地圖，但 Caffeine 可以幫我們管理記憶體上限
  // private final Cache<String, RoomTemplate> staticRoomCache =
  // Caffeine.newBuilder().maximumSize(10_000) // 假設地圖上限
  // .expireAfterAccess(1, TimeUnit.HOURS) // 沒人用的房間資料可被釋放 (視需求)
  // .recordStats().build();

  // 怪物原型快取
  // private final Cache<String, MobTemplate> staticMobCache =
  // Caffeine.newBuilder().maximumSize(5_000).expireAfterAccess(1, TimeUnit.HOURS).build();

  private final TemplateRepository templateRepo;

  // 2. Runtime Actors: 存放正在運作的 RoomActor
  // 使用 ConcurrentHashMap 確保並發存取安全
  @Getter
  private final ConcurrentHashMap<String, RoomActor> activeRooms = new ConcurrentHashMap<>();

  // 3. Write-Behind Queue: 存放待寫入資料庫的變更
  private final BlockingQueue<RoomStateUpdate> persistenceQueue = new LinkedBlockingQueue<>();

  // 快取：ID -> Player 實體
  private final ConcurrentHashMap<String, PlayerActor> activePlayers = new ConcurrentHashMap<>();

  private volatile boolean isRunning = true;



  /**
   * 伺服器啟動時載入地圖
   */
  public void loadWorld() {
    log.info("Starting World Loading...");

    // 讀取 global 資料

    // 讀取 newbie_village 資料
    loadZone("newbie_village");



    // 啟動 Write-Behind 消費者執行緒
    // startPersistenceWorker();
  }


  private void loadZone(String zone) {
    try {

      // 讀取 zone 資料
      Resource resource =
          resourceResolver.getResource("classpath:data/zones/" + zone + "/manifest.json");
      if (resource == null) {
        log.error("Zone manifest not found: {}", zone);
        return;
      }
      ZoneTemplate zoneTemplate =
          objectMapper.readValue(resource.getInputStream(), ZoneTemplate.class);
      log.info("{}", objectMapper.writeValueAsString(zoneTemplate));
      templateRepo.registerZone(zoneTemplate);
      String zoneId = zoneTemplate.id();


      // 讀取 mob 資料
      resource = resourceResolver.getResource("classpath:data/zones/" + zone + "/mobs.json");
      if (resource == null) {
        log.error("Zone mobs not found: {}", zone);
        return;
      } else {
        Set<MobTemplate> mobs = objectMapper.readValue(resource.getInputStream(),
            new TypeReference<Set<MobTemplate>>() {});
        for (MobTemplate mob : mobs) {
          log.info("{}", objectMapper.writeValueAsString(mob));

          String newMobId = zoneId + ":" + mob.id();
          MobTemplate newMob = mob.toBuilder().id(newMobId).build();
          templateRepo.registerMob(newMob);
        }
      }


      // 讀取 item 資料
      resource = resourceResolver.getResource("classpath:data/zones/" + zone + "/items.json");
      if (resource == null) {
        log.error("Zone items not found: {}", zone);
        return;
      } else {
        Set<ItemTemplate> items = objectMapper.readValue(resource.getInputStream(),
            new TypeReference<Set<ItemTemplate>>() {});
        for (ItemTemplate item : items) {
          log.info("{}", objectMapper.writeValueAsString(item));

          String newItemId = zoneId + ":" + item.id();
          ItemTemplate newItem = item.toBuilder().id(newItemId).build();
          templateRepo.registerItem(newItem);
        }
      }


      // 讀取 room 資料
      resource = resourceResolver.getResource("classpath:data/zones/" + zone + "/rooms.json");
      if (resource == null) {
        log.error("Zone rooms not found: {}", zone);
        return;
      }

      // 使用 TypeReference 來正確讀取 JSON 陣列為 Set<RoomTemplate>
      List<RoomTemplate> rooms = objectMapper.readValue(resource.getInputStream(),
          new TypeReference<List<RoomTemplate>>() {});

      for (RoomTemplate room : rooms) {
        log.info("{}", objectMapper.writeValueAsString(room));

        // 1. 處理 Mob Spawn Rules (使用 Stream 避免 ConcurrentModificationException)
        List<SpawnRule> updatedMobRules = room.mobSpawnRules() == null ? null
            : room.mobSpawnRules().stream()
                .map(rule -> rule.toBuilder().id(IdUtils.resolveId(zoneId, rule.id())).build())
                .toList();

        // 2. 處理 Item Spawn Rules
        List<SpawnRule> updatedItemRules = room.itemSpawnRules() == null ? null
            : room.itemSpawnRules().stream()
                .map(rule -> rule.toBuilder().id(IdUtils.resolveId(zoneId, rule.id())).build())
                .toList();

        // 3. 處理 Exits
        Map<String, RoomExit> updatedExits = room.exits() == null ? null
            : room.exits().entrySet().stream()
                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toBuilder()
                    .targetRoomId(IdUtils.resolveId(zoneId, e.getValue().targetRoomId())).build()));

        // 更新 room.id
        String newRoomId = zoneId + ":" + room.id();
        RoomTemplate newRoom = room.toBuilder().id(newRoomId).zoneId(zoneId).exits(updatedExits)
            .mobSpawnRules(updatedMobRules).itemSpawnRules(updatedItemRules).build();

        templateRepo.registerRoom(newRoom);

        // init roomActor
        getRoomActor(newRoomId);
      }

    } catch (IOException e) {
      log.error("Could not read rooms resources", e);
    }
  }
  /*
   * public void loadWorld_old() { log.info("Starting World Loading..."); try { // 讀取
   * classpath:maps/ 下所有的 json
   *
   * // 讀取 mob 資料
   *
   * // 讀取 item 資料
   *
   * // 讀取 room 資料
   *
   * Resource[] resources = resourceResolver.getResources("classpath:maps/*.json"); // Resource[]
   * resources = resourceResolver.getResources("classpath:maps/** /*.json");
   *
   *
   * for (Resource res : resources) { try { ZoneTemplate zone =
   * objectMapper.readValue(res.getInputStream(), ZoneTemplate.class); String zoneId = zone.id();
   * log.info("Loading Zone: {} ({}) - {} rooms", zone.name(), zoneId, zone.rooms().size());
   *
   * // 將房間放入 Cache，建立全域索引 for (RoomTemplate room : zone.rooms()) {
   *
   * // 更新exits里的targetRoomId for (Map.Entry<String, RoomExit> entry : room.exits().entrySet()) {
   * RoomExit roomExit = entry.getValue(); String newTargetRoomId = zoneId + ":" +
   * roomExit.targetRoomId(); RoomExit newRoomExit =
   * roomExit.toBuilder().targetRoomId(newTargetRoomId).build(); entry.setValue(newRoomExit); }
   *
   * String newRoomId = zoneId + ":" + room.id(); RoomTemplate newRoom =
   * room.toBuilder().id(newRoomId).build(); staticRoomCache.put(newRoomId, newRoom); }
   *
   * // 將怪物原型放入 Cache log.info("zone.mobTemplates().size: {}", zone.mobTemplates().size()); for
   * (MobTemplate mob : zone.mobTemplates()) { String newMobId = zoneId + ":" + mob.id();
   * MobTemplate newMob = mob.toBuilder().id(newMobId).build(); staticMobCache.put(newMobId,
   * newMob); }
   *
   * // 3. 根據 mob_resets 產生怪物實體 if (zone.mobResets() != null) { for (Population reset :
   * zone.mobResets()) {
   *
   * MobTemplate mobTpl = staticMobCache.getIfPresent(zoneId + ":" + reset.mobTemplateId());
   *
   * if (mobTpl != null) { RoomActor roomActor = getRoomActor(zoneId + ":" + reset.roomId());
   *
   * for (int i = 0; i < reset.count(); i++) { // 建立 MobActor 並設定初始房間 MobActor mobActor = new
   * MobActor(mobTpl, null); log.info("Spawned Mob: {} in Room: {}", mobTpl.name(), reset.roomId());
   * mobActor.setCurrentRoomId(roomActor.getId()); log.info("MobTemplate:{}",
   * objectMapper.writeValueAsString(mobActor));
   *
   * // 把 mob 塞到房間里 roomActor.getMobs().add(mobActor); mobActor.start(); } } else {
   * log.info("MobTemplate is null"); } } } } catch (IOException e) {
   * log.error("Failed to load map file: {}", res.getFilename(), e); } } } catch (IOException e) {
   * log.error("Could not read map resources", e); }
   *
   * // 啟動 Write-Behind 消費者執行緒 startPersistenceWorker(); }
   */

  /**
   * 核心方法：取得或創建 RoomActor 這是進入遊戲世界的入口
   */
  public RoomActor getRoomActor(String roomId) {
    // 如果 Actor 已經存在，直接回傳
    return activeRooms.computeIfAbsent(roomId, id -> {
      return worldFactory.createRoom(id);
    });
  }

  public MobTemplate getMobTemplate(String mobId) {
    return templateRepo.findMob(mobId).orElseThrow(() -> {
      log.error("MobTemplate ID not found: " + mobId);
      // return new IllegalArgumentException("MobTemplate ID not found: " + mobId);
      return null;
    });
  }

  // ==========================================
  // Write-Behind Implementation (非同步存檔機制)
  // ==========================================

  // 定義存檔請求的封包 (Record)
  public record RoomStateUpdate(int roomId, String dataToSave) {
  }

  public void addPlayer(PlayerActor actor) {
    activePlayers.put(actor.getId(), actor);
  }

  public PlayerActor getPlayer(WebSocketSession session) {
    String playerId = (String) session.getAttributes().get(MudKeys.PLAYER_ID);
    return getPlayer(playerId);
  }

  public PlayerActor getPlayer(String playerId) {
    // TODO 若 playerActor 不存在，則需要從資料庫載入並建立

    return activePlayers.get(playerId);
  }

  public void removePlayer(String playerId) {
    activePlayers.remove(playerId);
  }


  /**
   * RoomActor 呼叫此方法來請求存檔，不會阻塞 Actor 的運作
   */
  public void enqueueSave(int roomId, String data) {
    persistenceQueue.offer(new RoomStateUpdate(roomId, data));
  }

  private void startPersistenceWorker() {
    // 使用 Java 21+ Virtual Thread 來處理後台存檔
    Thread.ofVirtual().name("world-persistence-worker").start(() -> {
      log.info("World Persistence Worker started (Virtual Thread)");
      while (isRunning) {
        try {
          // 阻塞直到有資料進來
          RoomStateUpdate update = persistenceQueue.take();
          processUpdate(update);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          break;
        }
      }
    });
  }

  private void processUpdate(RoomStateUpdate update) {
    // 模擬寫入資料庫 (MySQL JSON)
    // 未來這裡會注入 JPA Repository
    try {
      // 模擬 IO 延遲
      Thread.sleep(10);
      log.debug("[Write-Behind] Saved room {} state to DB: {}", update.roomId(),
          update.dataToSave());
    } catch (Exception e) {
      log.error("Error saving room state", e);
    }
  }

  @PreDestroy
  public void shutdown() {
    isRunning = false;
    // 實際專案中這裡應該要把 Queue 裡的剩餘資料 flush 到資料庫
    log.info("WorldManager shutting down...");
  }

  /**
   * 對房間內的所有人廣播訊息 (除了來源者自己)
   *
   * @param roomId 房間 ID
   * @param message 訊息內容
   * @param excludeActorId 不想收到廣播的人 (通常是移動者本人)，可為 null
   */
  public void broadcastToRoom(String roomId, String message, String excludeActorId) {
    List<PlayerActor> actors = getActorsInRoom(roomId); // 假設您已有此方法

    for (PlayerActor actor : actors) {
      if (excludeActorId != null && actor.getId().equals(excludeActorId)) {
        continue;
      }
      // 直接發送文字
      actor.reply(message);
    }
  }

  // 簡單的 getActorsInRoom 實作參考 (效率較差，之後可用 Map<RoomId, Set<ActorId>> 優化)
  public List<PlayerActor> getActorsInRoom(String roomId) {
    return activePlayers.values().stream().filter(a -> roomId.equals(a.getCurrentRoomId()))
        .toList();
  }

  /**
   * 建立一個全新的物品實體
   *
   * @param templateId 物品原型 ID
   * @param randomize 是否進行隨機數值浮動
   */
  // public GameItem createItem(int templateId, boolean randomize) {
  // ItemTemplate tpl = loadItemTemplate(templateId);

  // GameItem item = new GameItem();
  // item.setId(UUID.randomUUID().toString());
  // item.setTemplateId(tpl.id());
  // item.setCurrentDurability(tpl.maxDurability());
  // item.setAmount(1);

  // // --- 處理隨機邏輯 (RNG) ---
  // if (randomize) {
  // // 1. 隨機浮動耐久度 (例如：全新 ~ 80% 新)
  // // item.setCurrentDurability(...);

  // // 2. 隨機詞綴 (例如 10% 機率出現 +1 攻擊)
  // if (ThreadLocalRandom.current().nextDouble() < 0.1) {
  // item.getDynamicProps().put("attack_bonus", 1);
  // item.getDynamicProps().put("quality", "RARE");
  // }
  // }

  // return item;
  // }

  // public ItemTemplate loadItemTemplate(int templateId) {
  // // 1. DB -> Entity
  // ItemTemplateEntity entity = itemTemplateRepository.findById(templateId).orElseThrow(
  // () -> new IllegalArgumentException("ItemTemplate ID not found: " + templateId));

  // // 2. Entity -> Record (MapStruct 自動轉)
  // // 注意：這裡得到的 Record 內含的 State 是 Entity 裡解序列化出來的
  // return itemTemplateMapper.toRecord(entity);
  // }
}


--- File: GameConfig.java ---

package com.example.htmlmud.config;

import java.util.concurrent.ScheduledExecutorService;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.example.htmlmud.application.command.CommandDispatcher;
import com.example.htmlmud.application.command.parser.TargetSelector;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.service.CombatService;
import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
public class GameConfig {
  @Bean
  public GameServices gameServices(

      ObjectMapper objectMapper,

      CombatService combatService,

      CommandDispatcher commandDispatcher,

      ScheduledExecutorService scheduler,

      ApplicationEventPublisher eventPublisher,

      TargetSelector targetSelector

  ) {
    return new GameServices(

        objectMapper,

        combatService,

        commandDispatcher,

        scheduler,

        eventPublisher,

        targetSelector

    );
  }
}


--- File: JacksonConfig.java ---

package com.example.htmlmud.config;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class JacksonConfig {

  @Bean
  @Primary // 確保這是預設使用的 ObjectMapper
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();

    // 1. 忽略 JSON 中存在但 Java POJO 中沒有的欄位 (避免新舊版本不相容導致報錯)
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    // 2. 允許空的 Bean (某些只有方法的物件序列化時不報錯)
    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

    // 3. (選用) 排版輸出，方便 Debug 查看 JSON，正式環境可關閉
    mapper.enable(SerializationFeature.INDENT_OUTPUT);

    return mapper;
  }
}


--- File: SchedulerConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@Configuration
public class SchedulerConfig {

  @Bean(destroyMethod = "shutdown") // 確保伺服器關閉時釋放資源
  public ScheduledExecutorService gameScheduler() {
    // 核心執行緒數設為 2~4 即可。
    // 因為我們只用它來 "觸發" 任務，實際執行會丟給 Virtual Thread，
    // 所以這個 Scheduler 幾乎不會被卡住，不需要太多執行緒。
    return Executors.newScheduledThreadPool(4, Thread.ofPlatform().factory());
  }
}


--- File: SecurityConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }
}


--- File: WebSocketConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import com.example.htmlmud.infra.server.MudWebSocketHandler;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

  private final MudWebSocketHandler mudWebSocketHandler;

  public WebSocketConfig(MudWebSocketHandler mudWebSocketHandler) {
    this.mudWebSocketHandler = mudWebSocketHandler;
  }

  @Override
  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
    registry.addHandler(mudWebSocketHandler, "/ws").setAllowedOrigins("*");
  }
}


--- File: AggressiveBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 攻擊行為
public class AggressiveBehavior implements MobBehavior {

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {
    // 主動怪邏輯：看到玩家就攻擊
    // 發送戰鬥指令給 BattleSystem
    self.sayToRoom("滾出去！" + player.getName());
    self.attack(player);
  }

  @Override
  public void onInteract(MobActor self, PlayerActor player, String command) {
    self.sayToRoom("吼！！！(它看起來不想跟你說話)");
    self.attack(player);
  }

  @Override
  public void onDamaged(MobActor self, LivingActor attacker) {
    self.sayToRoom("吼吼吼！！！(它看起來想殺死你)");
    self.attack(attacker);
  }
}


--- File: GuestBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import org.slf4j.MDC;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.service.AuthService;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.MudContext;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.persistence.entity.UserEntity;
import com.example.htmlmud.protocol.ConnectionState;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
// @RequiredArgsConstructor
public class GuestBehavior implements PlayerBehavior {

  private static final int MAX_AUTH_RETRIES = 5;

  private final AuthService authService;

  @Setter
  private String tempUsername; // 暫存正在處理的帳號名

  @Setter
  private String tempPassword; // 暫存正在處理的密碼

  public GuestBehavior(AuthService authService) {
    this.authService = authService;
  }

  @Override
  public PlayerBehavior handle(PlayerActor actor, GameCommand cmd) {
    // 目前只處理文字輸入 (Input)
    PlayerBehavior next = null;
    if (cmd instanceof GameCommand.Input(var text)) {
      switch (actor.getConnectionState()) {
        case CONNECTED -> doConnected(actor, text);
        case CREATING_USERNAME -> doCreatingUsername(actor, text);
        case CREATING_PASSWORD -> doCreatingPassword(actor, text);
        case ENTERING_PASSWORD -> {
          next = doEnterPassword(actor, text);
        }
        case ENTERING_CHAR_NAME -> doEnteringCharName(actor, text);
        case ENTERING_CHAR_GENDER -> {
        }
        case ENTERING_CHAR_RACE -> {
        }
        case ENTERING_CHAR_CLASS -> {
        }
        case ENTERING_CHAR_ATTRIBUTES -> {
        }
        case IN_GAME -> {
        }
      }
    }

    return next;
  }

  private void doConnected(PlayerActor actor, String input) {
    log.info("doConnected");

    if ("new".equalsIgnoreCase(input.trim())) {
      doRegister(actor);
    } else {
      doEnterUsername(actor, input);
    }
  }

  private void doRegister(PlayerActor actor) {
    log.info("doRegister");

    WebSocketSession session = actor.getSession();
    String msg = "【註冊流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 4 到 20 個字元之間。\r\n請輸入您想使用的帳號名稱:";
    try {
      // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
      actor.setConnectionState(ConnectionState.CREATING_USERNAME);
    } catch (IOException e) {
      log.error("doRegister {}", e.getMessage(), e);
    }
  }

  public void doCreatingUsername(PlayerActor actor, String input) {
    log.info("doCreatingUsername");
    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = authService.validateUsername(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.reply("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 註冊帳號失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    this.tempUsername = input;

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n只能包含英文字母與數字且長度必須在 6 到 32 個字元之間。\r\n請輸入密碼:";
    try {
      // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      actor.setConnectionState(ConnectionState.CREATING_PASSWORD);
    } catch (IOException e) {
      log.error("doCreatingUsername {}", e.getMessage(), e);
    }
  }

  public void doCreatingPassword(PlayerActor actor, String input) {
    log.info("doCreatingPassword");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = authService.validatePassword(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.reply("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 註冊密碼失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    this.tempPassword = input;

    // 新增玩家帳密
    authService.register(tempUsername, tempPassword);
    log.info("玩家註冊成功: {}", tempUsername);

    this.tempUsername = null;
    this.tempPassword = null;

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n註冊完成，請重新登入。";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    actor.reply(msg);

    actor.setConnectionState(ConnectionState.CONNECTED);
  }

  private void doEnterUsername(PlayerActor actor, String input) {
    log.info("doLoginUsername");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = authService.validateUsername(input);

    // 如果格式正確，檢查資料庫是否存在該帳號
    if (errorReason == null && !authService.exists(input)) {
      errorReason = "帳號不存在。";
    }

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 登入帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.reply("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 登入帳號失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    this.tempUsername = input;

    String msg = "請輸入密碼:";
    try {
      // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      actor.setConnectionState(ConnectionState.ENTERING_PASSWORD);
    } catch (IOException e) {
      log.error("msg");
    }
  }

  private PlayerBehavior doEnterPassword(PlayerActor actor, String input) {
    log.info("doEnterPassword");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = authService.validatePassword(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 登入密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.reply("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return null;
      }

      log.info("連線 {} 登入密碼失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.reply(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return null;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    this.tempPassword = input;
    // log.info("玩家登入: {} {}", this.tempUsername, this.tempPassword);

    // 登入玩家帳密
    PlayerRecord record = authService.login(tempUsername, tempPassword);

    // 變更為正式玩家身份
    return upgradeIdentity(actor, record);
  }

  private void doEnteringCharName(PlayerActor actor, String input) {
    log.info("doEnteringCharName");

    WebSocketSession session = actor.getSession();
    String msg =
        "【角色設定流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 2 到 20 個字元之間。\r\n請輸入您想使用的角色名稱:";
    try {
      // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
      actor.setConnectionState(ConnectionState.ENTERING_CHAR_NAME);
    } catch (IOException e) {
      log.error("doRegister {}", e.getMessage(), e);
    }
  }


  // 供 GuestBehavior 呼叫：由GUEST變更為正式玩家
  private PlayerBehavior upgradeIdentity(PlayerActor actor, PlayerRecord record) {

    // 資料載入
    actor.fromRecord(this, record);
    actor.setConnectionState(ConnectionState.IN_GAME);

    // 裝備?

    // 讓玩家進入資料紀錄的房間
    RoomActor room = actor.getManager().getRoomActor(actor.getCurrentRoomId());
    room.enter(actor, new CompletableFuture<Void>());

    log.info("Actor 載入玩家資料 當前狀態: {} {}", actor.getName(), actor.getNickname());
    return new InGameBehavior();
  }

}


--- File: InGameBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
public class InGameBehavior implements PlayerBehavior {
  // 這裡可以注入 CommandHandlerRegistry

  @Override
  public void onEnter(PlayerActor actor) {
    log.info("InGameBehavior onEnter()");

    // 進場時自動看一次房間
    actor.getServices().commandDispatcher().dispatch(actor, "look");
  }

  @Override
  public PlayerBehavior handle(PlayerActor actor, GameCommand cmd) {
    // log.info("InGameBehavior handle()");

    // 目前只處理文字輸入 (Input)
    if (cmd instanceof GameCommand.Input(var text)) {
      // 【關鍵】將文字交給 Dispatcher
      actor.getServices().commandDispatcher().dispatch(actor, text);
    }
    // else if (cmd instanceof GameCommand.Logout) {
    // actor.reply("登出中...");
    // actor.handleDisconnect();
    // // ... 切換回 GuestBehavior ...
    // }

    return null; // 保持 InGame 狀態
  }
}


--- File: MerchantBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 商店行為
public class MerchantBehavior implements MobBehavior {

  private final int shopId;

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {
    // 禮貌性問候
    self.sayToRoom("歡迎光臨！需要買點什麼嗎？(輸入 'list' 查看商品)");
  }

  @Override
  public void onInteract(MobActor self, PlayerActor player, String command) {
    if ("list".equalsIgnoreCase(command)) {
      // 顯示商品列表
      // ShopService.showList(player, shopId);
    } else if (command.startsWith("buy")) {
      // 處理購買
    } else {
      // 隨機講一句話
      String dialog = self.getTemplate().dialogues().iterator().next();
      self.sayToRoom(dialog);
    }
  }

  @Override
  public void onDamaged(MobActor self, LivingActor attacker) {
    // 守衛邏輯：如果被打，可能呼叫警衛，或者單純不理會(因為無敵)
    self.sayToRoom("衛兵！有人在鬧事！");
    // Spawn guards...
  }
}


--- File: MobBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.protocol.ActorMessage;

public interface MobBehavior {

  // 定期心跳 (例如每秒一次)：決定是否移動、回血、索敵
  default void onTick(MobActor self) {}

  // 當玩家進入視野
  default void onPlayerEnter(MobActor self, PlayerActor player) {}

  // 當玩家與其互動 (例如輸入 "talk guard")
  default void onInteract(MobActor self, PlayerActor player, String command) {}

  // 當受傷時 (仇恨值處理)
  default void onDamaged(MobActor self, LivingActor attacker) {}

  // 處理通用訊息
  default void onMessage(MobActor self, ActorMessage msg) {}
}


--- File: PassiveBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 被動行為 (一般 NPC)
public class PassiveBehavior implements MobBehavior {

  // 在 PassiveBehavior (一般 NPC) 的 onTick
  public void onTick(MobActor self) {
    // 5% 機率隨機移動
    if (Math.random() < 0.05) {
      // 隨機選一個出口移動
      // self.moveTo(randomExit);
    }

    // 10% 機率說夢話
    if (Math.random() < 0.1) {
      self.sayToRoom("今天天氣真好...");
    }
  }

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {

  }

  @Override
  public void onDamaged(MobActor self, LivingActor attacker) {
    self.sayToRoom("吼吼~！！！(它看起來想殺死你)");
    self.attack(attacker);
  }
}


--- File: PlayerBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.protocol.GameCommand;

public interface PlayerBehavior {

  // 處理指令
  // 回傳值：如果是 null 代表狀態不變；如果回傳新的 Behavior，代表狀態切換 (Become)
  PlayerBehavior handle(PlayerActor actor, GameCommand cmd);

  // 當切換到這個狀態時觸發 (Optional)
  default void onEnter(PlayerActor actor) {}
}


--- File: VirtualActor.java ---

package com.example.htmlmud.domain.actor.core;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class VirtualActor<T> {

  // 每個 Actor 都有自己的信箱
  protected final BlockingQueue<T> mailbox = new LinkedBlockingQueue<>();
  private final AtomicBoolean running = new AtomicBoolean(true);
  private final AtomicBoolean started = new AtomicBoolean(false);
  private final String actorId;

  public VirtualActor(String actorId) {
    this.actorId = actorId;
  }

  // 啟動 Actor：這會生成一個專屬的 Virtual Thread
  public void start() {
    if (started.compareAndSet(false, true)) {
      Thread.ofVirtual().name(actorId).start(this::runLoop);
    } else {
      log.warn("[{}] 已經啟動，忽略重複的啟動請求。", actorId);
    }
  }

  // 非阻塞投遞訊息 (給外部呼叫用)
  public void send(T message) {
    mailbox.offer(message);
  }

  // 核心迴圈
  private void runLoop() {
    log.info("[{}] started on thread: {}", actorId, Thread.currentThread());

    try {
      while (running.get()) {
        // 這裡會 Block，虛擬執行緒會 Unmount，不佔用 OS Thread
        T message = mailbox.take();
        handleMessage(message);
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      log.warn("[{}] interrupted.", actorId);
    } catch (Exception e) {
      log.error("[{}] encountered unexpected error", actorId, e);
    }
  }

  public void stop() {
    if (running.compareAndSet(true, false)) { // 確保只執行一次
      log.info("Stopping [{}]", actorId);
      // 重要：送出一個中斷訊號給執行該 Actor 的 Virtual Thread
      // 因為 runLoop 卡在 mailbox.take()，如果不 interrupt，它會永遠卡在那裡直到有新訊息
      // 注意：這需要你在 start() 時保存 Thread 參照，或者發送一個 Poison Pill
    }
  }

  // 子類別實作具體邏輯
  protected abstract void handleMessage(T message);
}


--- File: LivingActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.core.VirtualActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.EquipmentSlot;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.ItemType;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.GameCommand;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

// 泛型 T 讓我們可以在子類別擴充更多 Message 類型
@Slf4j
public abstract sealed class LivingActor extends VirtualActor<ActorMessage>
    permits PlayerActor, MobActor {

  @Getter
  protected GameServices services;

  @Getter
  protected String id;

  @Getter
  @Setter
  protected String name;

  // 所有生物都有狀態 (HP/MP)
  @Getter
  protected LivingState state;

  // 所有生物都在某個房間 (可能是 null)
  @Getter
  @Setter
  protected String currentRoomId;

  // 用來記錄進入房間的時間戳記 (奈秒精度以防同時進入)
  @Getter
  private long lastEnterRoomTime;

  // 背包
  @Getter
  protected List<GameItem> inventory = new ArrayList<>();


  public LivingActor(String id, String name, LivingState state, GameServices services) {
    super(id);
    this.id = id;
    this.name = name;
    this.state = state;
    this.services = services;
  }

  @Override
  protected void handleMessage(ActorMessage msg) {
    switch (msg) {
      case ActorMessage.Tick(var tickCount, var timestamp) -> {
        doTick(tickCount, timestamp);
      }
      case ActorMessage.Command(var traceId, var cmd) -> {
        // services.commandDispatcher().dispatch(this, cmd);
        doCommand(traceId, cmd);
      }
      case ActorMessage.Die(var killerId) -> {
        doDeath(killerId);
      }
      case ActorMessage.SendText(var session, var content) -> {
        doSendText(session, content);
      }
      case ActorMessage.OnAttacked(var attacker) -> {
        doOnAttacked(attacker);
      }
      case ActorMessage.Equip(var item, var future) -> {
        doEquip(item, future);
      }
      case ActorMessage.Unequip(var slot, var future) -> {
        doUnequip(slot, future);
      }
    }
  }


  // default 應依自己需求改寫 -----------------------------------------------------------
  protected void doTick(long tickCount, long time) {
    // === 1. 戰鬥心跳 (最優先，每秒執行) ===
    // 頻率：1秒 (因為 WorldPulse 就是 1秒)
    if (this.state.isInCombat()) {
      processAutoAttack(time); // 之前討論過的自動攻擊
    }

    // === 2. 回復/狀態心跳 (Regen Tick) ===
    // 頻率：每 3 秒執行一次 ( tickCount % 3 == 0 )
    // 只有沒在戰鬥時才回血，或者戰鬥中回得比較慢
    if (tickCount % 3 == 0) {
      processRegen();
      // processBuffs(); // 檢查 Buff 是否過期
    }

    // === 3. AI 行為心跳 (AI Tick) ===
    // 頻率：每 5 秒執行一次
    // 只有怪物需要，玩家不需要
    if (this instanceof MobActor mob && tickCount % 5 == 0) {
      // mob.processAI(); // 例如：隨機移動、喊話
    }
  }

  protected void doCommand(String traceId, GameCommand cmd) {}

  protected void doDeath(String killerId) {
    this.state.hp = 0;
    this.state.isDead = true;
    log.info("{} has been slain by {}!", id, killerId);
  }

  protected void doSendText(WebSocketSession session, String msg) {}

  protected void doOnAttacked(LivingActor attacker) {
    // 檢查是否正在戰鬥
    if (!this.state.isInCombat) {
      this.state.isInCombat = true;
      this.state.combatTargetId = attacker.getId();
    }
  }

  /**
   * 穿上裝備 (核心邏輯)
   *
   * @param item 要穿的物品
   * @return 成功回傳 true
   */
  protected boolean doEquip(GameItem item, CompletableFuture<String> future) {
    // 1. 取得 ItemTemplate (需要依賴 Service 或是 Item 本身帶有 slot 資訊)
    // 假設 GameItem 已經從 Template 複製了 slot 資訊，或者這裡去查 Template
    ItemTemplate tpl = item.getTemplate();
    if (tpl.type() != ItemType.EQUIPMENT) {
      future.complete(item.getDisplayName() + " 不是裝備");
      return false;
    }

    EquipmentSlot slot = tpl.equipmentProp().slot();

    // 2. 檢查該部位是否已經有裝備？如果有，先脫下來 (Swap)
    if (state.equipment.containsKey(slot)) {
      // GameItem oldItem = state.equipment.get(slot);
      doUnequip(slot, new CompletableFuture<>()); // 先脫舊的
      if (state.equipment.containsKey(slot)) {
        future.complete("無法脫下 " + slot.getDisplayName() + "，或背包已滿");
        return false;
      }
    }

    // 3. 從背包移除該物品
    // 注意：這裡假設 inventory 是 Mutable List
    if (!inventory.remove(item)) {
      future.complete(item.getDisplayName() + "不在背包裡");
      return false; // 物品不在背包裡
    }

    // 4. 放入裝備欄
    state.equipment.put(slot, item);

    // 5. 重新計算數值
    recalculateStats();

    future.complete("你裝上 " + item.getDisplayName());
    return true;
  }

  /**
   * 脫下裝備
   */
  protected boolean doUnequip(EquipmentSlot slot, CompletableFuture<String> future) {
    GameItem item = state.equipment.get(slot);
    if (item == null) {
      future.complete("你 " + slot.getDisplayName() + " 上沒有裝備任何東西");
      return false;
    }

    // 1. 放入背包
    inventory.add(item);

    // 2. 從裝備欄移除
    state.equipment.remove(slot);

    // 3. 重新計算數值
    recalculateStats();

    future.complete("你將 " + slot.getDisplayName() + " 放入背包");
    return true;
  }
  // -----------------------------------------------------------------------------------


  // 實作 defualt 的公開方法給外部呼叫用 --------------------------------------------------
  public void tick() {
    this.send(new ActorMessage.Tick(System.currentTimeMillis(), System.nanoTime()));
  }

  public void command(GameCommand cmd) {
    this.send(new ActorMessage.Command("internal", cmd));
  }

  public void death(String killerId) {
    this.send(new ActorMessage.Die(killerId));
  }

  // 被攻擊處理
  public void onAttacked(LivingActor attacker) {
    this.send(new ActorMessage.OnAttacked(attacker));
  }

  public CompletableFuture<String> equip(GameItem item) {
    var future = new CompletableFuture<String>();
    this.send(new ActorMessage.Equip(item, new CompletableFuture<>()));
    return future;
  }

  public CompletableFuture<String> unequip(EquipmentSlot slot) {
    var future = new CompletableFuture<String>();
    this.send(new ActorMessage.Unequip(slot, future));
    return future;
  }

  // -----------------------------------------------------------------------------------


  protected void processAutoAttack(long now) {
    // 1. 檢查攻速冷卻 (例如 2000ms 一刀)
    if (now < state.nextAttackTime) {
      return; // 還在冷卻中
    }

    LivingActor target =
        services.combatService().processAutoAttack(this, currentRoomId, state.combatTargetId);
    if (target == null || target.getState().hp <= 0) {
      stopCombat(); // 目標消失或死亡，停止戰鬥
      return;
    }

    // 6. 設定下一次攻擊時間 (攻速 2秒)
    state.nextAttackTime = now + 2000;
  }

  protected void processRegen() {
    if (state.hp < state.maxHp) {
      int regenAmount = (int) (state.maxHp * 0.05); // 回復 5%
      heal(regenAmount);
    }
  }

  // 治療處理
  protected void heal(int amount) {
    if (state.isDead)
      return;
    this.state.hp = Math.min(state.hp + amount, state.maxHp);
  }



  // 1. 受傷處理
  private void takeDamage(int amount, String attackerId) {
    if (state.isDead)
      return;

    this.state.hp -= amount;
    log.info("{} took {} damage from {}. HP: {}/{}", id, amount, attackerId, state.hp, state.maxHp);

    // 發送訊息給房間 (讓其他人看到噴血)
    // if (currentRoom != null) {
    // currentRoom.broadcast(...);
    // }

    if (state.hp <= 0) {
      death(attackerId);
    }
  }



  // --- 共用行為邏輯 ---
  // 進入房間時，房間會呼叫此方法來紀錄進入時間戳記
  public void markEnterRoom() {
    this.lastEnterRoomTime = System.nanoTime();
  }


  /**
   * 【重要】重新計算總屬性 每次穿脫裝備、升級、Buff 改變時呼叫
   */
  public void recalculateStats() {
    int atk = 0; // 基礎攻擊力 (可從 Level 算)
    int def = 0; // 基礎防禦力

    // 遍歷所有裝備
    for (GameItem item : state.equipment.values()) {
      ItemTemplate tpl = item.getTemplate();
      if (tpl != null) {
        atk += tpl.equipmentProp().damage();
        def += tpl.equipmentProp().defense();

        // 處理額外屬性 (Bonus Stats)
        // if (tpl.bonusStats() != null) ...
      }
    }

    this.state.damage = atk;
    this.state.defense = def;
    log.info("{} stats updated: Atk={}, Def={}", this.name, atk, def);
  }



  public void stopCombat() {
    state.isInCombat = false;
    state.combatTargetId = null;
    // this.re("戰鬥結束了。");
  }
}


--- File: MobActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import com.example.htmlmud.domain.actor.behavior.AggressiveBehavior;
import com.example.htmlmud.domain.actor.behavior.MerchantBehavior;
import com.example.htmlmud.domain.actor.behavior.MobBehavior;
import com.example.htmlmud.domain.actor.behavior.PassiveBehavior;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.EquipmentSlot;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.map.Equipment;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.vo.DamageSource;
import com.example.htmlmud.protocol.ActorMessage;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public final class MobActor extends LivingActor {

  // 仇恨列表 (Key: 攻擊者 ID字串, Value: 仇恨值)
  // 因為 ID 已改為 UUID String，這裡的 Key 也同步調整為 String
  protected final Map<String, Integer> aggroTable = new HashMap<>();

  @Getter
  private final MobTemplate template;

  private ScheduledFuture<?> aiTask; // Heartbeat 排程
  private MobBehavior behavior; // AI 行為 (策略模式)

  // 裝備欄位
  private Map<EquipmentSlot, GameItem> equipments;

  /**
   * 建構子： 1. 接收 Template 與 Services 2. 自動生成 UUID 3. 自動從 Template 建立 LivingState
   */
  public MobActor(MobTemplate template, GameServices services) {
    // 【修正 1】直接使用 UUID 作為 ID，不再依賴 GameObjectId.mob()
    // 【修正 2】呼叫 helper method 建立初始 State，確保血量與 Template 一致
    String mobId = "mob-" + UUID.randomUUID().toString().substring(0, 8);
    super(mobId, template.name(), createInitialState(template), services);
    this.template = template;

    // 處理裝備

    // 初始化行為
    initBehavior();

    log.debug("Mob created: {} (ID: {})", template.name(), this.getId());

    // 【重要】這裡移除了 this.start()，請在外部 (MobFactory) 建立實體後呼叫 mob.start()
  }

  // 輔助方法：根據 Template 產生初始的 LivingState
  private static LivingState createInitialState(MobTemplate tpl) {
    LivingState state = new LivingState();

    // 基本屬性設定
    state.level = tpl.level();
    state.hp = tpl.maxHp();
    state.maxHp = tpl.maxHp();
    state.mp = tpl.maxMp();
    state.maxMp = tpl.maxMp();
    state.stamina = tpl.maxStamina();
    state.maxStamina = tpl.maxStamina();
    // state.san = tpl.maxSan();
    // state.maxSan = tpl.maxSan();

    // 戰鬥屬性設定
    state.damage = tpl.baseDamage();
    state.defense = tpl.baseDefense();
    state.attackSpeed = tpl.attackSpeed();

    return state;
  }

  // 處理初期裝備
  private void initEquipment(MobTemplate tpl) {
    if (tpl.equipment() != null) {
      for (String itemId : tpl.equipment().values()) {

        // equip(itemId);
      }
    }
  }

  private void initBehavior() {
    if (template.shopId() != null) {
      this.behavior = new MerchantBehavior(template.shopId());
    } else if (template.isAggressive()) {
      this.behavior = new AggressiveBehavior();
    } else {
      this.behavior = new PassiveBehavior();
    }
  }

  // --- 生命週期控制 ---

  @Override
  public void start() {
    super.start(); // 啟動 Actor 訊息佇列處理
    // startHeartbeat(); // 啟動 AI 心跳
  }

  @Override
  public void stop() {
    stopHeartbeat(); // 停止 AI
    super.stop(); // 停止 Actor
  }

  // --- 訊息處理 ---

  @Override
  protected void handleMessage(ActorMessage msg) {
    // 1. AI 決策優先 (例如：受到攻擊決定是否逃跑)
    behavior.onMessage(this, msg);

    // 2. 如果父類別有通用邏輯 (如 Buff 結算)，可視需求呼叫
    super.handleMessage(msg);
  }

  // --- AI 心跳機制 (Heartbeat) ---

  private void startHeartbeat() {
    if (aiTask != null && !aiTask.isCancelled())
      return;

    // Scheduler (Platform Thread) 負責定時觸發
    this.aiTask = services.scheduler().scheduleAtFixedRate(() -> {
      // Virtual Thread 負責執行邏輯
      Thread.ofVirtual().name("mob-tick-" + this.getId()).start(() -> {
        try {
          if (this.state.hp > 0) {
            this.tick();
          } else {
            stopHeartbeat();
          }
        } catch (Exception e) {
          log.error("Mob tick error: {}", this.getId(), e);
        }
      });
    }, 1, 3, TimeUnit.SECONDS); // 延遲1秒開始，每3秒一次
  }

  private void stopHeartbeat() {
    if (aiTask != null) {
      aiTask.cancel(false);
      aiTask = null;
    }
  }

  public void tick() {
    // 委派給 Behavior
    // behavior.onTick(this);

    long now = System.currentTimeMillis();

    // 1. 戰鬥邏輯
    // log.info("this.state.isInCombat: {}", this.state.isInCombat);
    if (this.state.isInCombat) {
      processCombatRound(now);
    } else {
      // 2. 非戰鬥邏輯 (巡邏、回復 HP)
      // processRegen();
      behavior.onTick(this);
    }
  }

  // --- 互動與事件 ---

  public void onPlayerEnter(PlayerActor player) {
    behavior.onPlayerEnter(this, player);
  }

  public void onInteract(PlayerActor player, String command) {
    behavior.onInteract(this, player, command);
  }

  @Override
  protected void doOnAttacked(LivingActor attacker) {

    // 檢查是否正在戰鬥
    if (!this.state.isInCombat) {
      this.state.isInCombat = true;
    }

    // TODO 檢查仇恨表，選最高的當對手
    this.state.combatTargetId = attacker.getId();

    // TODO 檢查仇恨表，選最高的當對手
    // if (this.state.combatTargetId == null) {
    // this.state.combatTargetId = attacker.getId();
    // }

    // 無敵判定
    if (template.isInvincible()) {
      if (attacker instanceof PlayerActor p) {
        p.reply(this.template.name() + " 毫髮無傷！");
      }
      return;
    }

    // 1. 扣血 (呼叫父類別)
    log.info("hp: {} defense: {}  attacker.damage: {}", this.state.hp, this.state.defense,
        attacker.getState().damage);
    // super.onAttacked(attacker);

    // 2. 增加仇恨值 (使用 String ID)
    addAggro(attacker.getId(), attacker.getState().damage);

    // 3. 通知 AI
    behavior.onDamaged(this, attacker);
  }

  @Override
  protected void doDeath(String killerId) {
    // super.onDie(killerId);
    stopHeartbeat();

    log.info("{} died. Killer: {}", this.template.name(), killerId);
    // 觸發掉寶、給予經驗值等邏輯...
  }

  // 仇恨值管理 (Key 改為 String)
  public void addAggro(String sourceId, int value) {
    aggroTable.merge(sourceId, value, Integer::sum);
  }

  // 取得當前仇恨最高目標 ID
  public String getHighestAggroTarget() {
    return aggroTable.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey)
        .orElse(null);
  }

  // 行為層需要的輔助方法 (Facade)
  public void sayToRoom(String content) {
    // 實作：取得當前 RoomActor 並廣播
    // services.worldManager().getRoom(currentRoomId).broadcast(...)
  }

  public void attack(LivingActor target) {
    // 實作：發送 AttackMessage 給 target
  }

  private void processCombatRound(long now) {
    // 檢查攻擊冷卻
    log.info("this.state.nextAttackTime: {}", this.state.nextAttackTime);
    if (now < this.state.nextAttackTime) {
      return;
    }

    // 取得當前最高仇恨目標
    log.info("getHighestAggroTarget: {}", getHighestAggroTarget());
    String targetId = getHighestAggroTarget();
    if (targetId == null) {
      this.state.isInCombat = false; // 沒目標，脫離戰鬥
      return;
    }

    processAutoAttack(now);

    // 從房間取得目標 Actor (這裡需要 WorldManager 協助，或 RoomActor 傳遞)
    // 假設這段邏輯在 RoomActor 處理會更好，但若在 Mob 處理：
    // LivingActor target = services.worldManager().getRoomActor(currentRoomId).findActor(targetId);

    // 為了簡單，假設我們能取到 target
    // int dmg = combatService.calculateDamage(this, target);
    // target.onAttacked(this, dmg);

    // 重設冷卻時間
    this.state.nextAttackTime = now + this.state.attackSpeed;
  }

  // 取得當前的攻擊方式
  public DamageSource getCurrentAttackSource() {
    // 1. 先檢查主手有沒有武器 (針對 Guard)
    GameItem weapon = state.equipment.get(EquipmentSlot.MAIN_HAND); // 假設您有實作裝備系統

    if (weapon != null) {
      // 有武器：回傳武器資訊
      // 這裡假設 weapon 有對應欄位，或從 Template 查
      return new DamageSource(weapon.getTemplate().name(),
          weapon.getTemplate().equipmentProp().attackVer(),
          weapon.getTemplate().equipmentProp().damage(),
          weapon.getTemplate().equipmentProp().attackSpeed());
    }

    // 2. 沒武器：回傳天生武器 (針對 Rat 或 空手的人)
    return new DamageSource(template.attackNoun(), template.attackVerb(), template.baseDamage(),
        template.attackSpeed());
  }
}


--- File: PlayerActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import org.slf4j.MDC;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.behavior.GuestBehavior;
import com.example.htmlmud.domain.actor.behavior.InGameBehavior;
import com.example.htmlmud.domain.actor.behavior.PlayerBehavior;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.context.MudContext;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.ConnectionState;
import com.example.htmlmud.protocol.GameCommand;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

// PlayerActor 處理的訊息類型就是 GameCommand
@Slf4j
public final class PlayerActor extends LivingActor {

  @Getter
  private WebSocketSession session;

  @Getter
  private final WorldManager manager;

  @Getter
  @Setter
  private String[] aliases;

  @Getter
  @Setter
  private String nickname;

  @Getter
  @Setter
  private String lookDescription;


  // Actor 內部狀態 (State Machine Context)
  @Getter
  @Setter
  private ConnectionState connectionState = ConnectionState.CONNECTED;

  // 當前的行為腦
  @Setter
  private PlayerBehavior currentBehavior;

  private boolean isDirty = false;



  private PlayerActor(WebSocketSession session, String id, String name, LivingState state,
      WorldManager worldManager, GameServices services) {
    super(id, name, state, services);
    this.session = session;
    this.manager = worldManager;
  }

  // 工廠方法 初始設定為 GuestBehavior
  public static PlayerActor createGuest(WebSocketSession session, WorldManager worldManager,
      GameServices gameServices) {
    String name = "GUEST";
    String playerId = "player-" + session.getId().substring(0, 8);
    PlayerActor actor =
        new PlayerActor(session, playerId, name, new LivingState(), worldManager, gameServices);
    actor.become(new GuestBehavior(worldManager.getAuthService()));
    actor.inventory = new ArrayList<>();
    return actor;
  }

  @Override
  public void start() {
    super.start();
    // 連線歡迎詞
    reply("歡迎光臨 Html Mud 世界！");
    reply("請輸入 帳號 進行登入 或 輸入 'new' 進行註冊：");
  }

  @Override
  protected void handleMessage(ActorMessage msg) {
    super.handleMessage(msg);
  }

  @Override
  protected void doTick(long tickCount, long time) {
    // log.info("player tickCount: {}", tickCount);
    super.doTick(tickCount, time);
  }

  @Override
  protected void doCommand(String traceId, GameCommand cmd) {
    // A. 設定 MDC (給 Log 看)
    MDC.put("traceId", traceId);
    MDC.put("actorName", this.name);

    try {
      // B. 設定 ScopedValue (給 Service 邏輯看)
      ScopedValue.where(MudContext.CURRENT_PLAYER, this).where(MudContext.TRACE_ID, traceId)
          .run(() -> {
            // C. 委派給當前 Behavior 處理
            PlayerBehavior next = currentBehavior.handle(this, cmd);

            // D. 狀態切換
            if (next != null) {
              become(next);
            }
          });
    } finally {
      // E. 清理 MDC
      MDC.clear();
    }
  }

  @Override
  protected void doSendText(WebSocketSession session, String msg) {
    if (session != null && session.isOpen()) {
      try {
        String json =
            services.objectMapper().writeValueAsString(Map.of("type", "TEXT", "content", msg));

        // 這裡才是真正寫入 WebSocket 的地方
        // 因為是在 handleMessage 內執行，保證了 Thread-Safe
        session.sendMessage(new TextMessage(json));
      } catch (IOException e) {
        log.error("Failed to send message to player {}", id, e);
      }
    }
  }

  @Override
  protected void doDeath(String killerId) {
    reply("你已經死亡！即將在重生點復活...");
    super.doDeath(killerId);

    // 玩家死亡邏輯：掉經驗、傳送回城
  }
  // -----------------------------------------------------------------------------------



  // 狀態切換方法
  private void become(PlayerBehavior nextBehavior) {
    this.currentBehavior = nextBehavior;
    this.currentBehavior.onEnter(this); // 觸發進場事件
    log.info("{} 切換行為模式至 {}", this.name, nextBehavior.getClass().getSimpleName());
  }

  private void levelUp() {
    // 從 Context 取得當前 Trace ID
    String currentTraceId = MudContext.traceId();

    // 發送事件
    // publisher.publishEvent(
    // new DomainEvent.PlayerLevelUpEvent(currentTraceId, this.objectId.id(), this.state.level));
  }



  // MudWebSocketHandler 在 afterConnectionClosed 時呼叫此方法
  public void handleDisconnect() {
    // 1. 停止 Actor 迴圈
    this.stop();

    // 2. 如果已經登入並存在於世界中，從世界移除
    // 注意：這裡可以做「離線保護」或「延遲登出」
    // 但最簡單的做法是直接移除
    // worldManager.removePlayer(this.getId());

    // 3. 觸發存檔 (Write-Behind)
    // persistenceService.saveAsync(this.toRecord());
  }

  public void reply(String msg) {
    this.send(new ActorMessage.SendText(session, msg));
  }



  // 未整理也
  private void replaceSession(WebSocketSession newSession) {
    // 1. 關閉舊連線 (如果還開著)
    if (this.session != null && this.session.isOpen()) {
      try {
        this.session.close();
      } catch (IOException ignored) {
      }
    }

    // 2. 換上新連線
    this.session = newSession;

    // 3. 重發當前環境資訊
    this.doSendText(session, "\u001B[33m[系統] 連線已恢復。\u001B[0m");
    this.services.commandDispatcher().dispatch(this, "look");
  }

  // 觸發存檔的輔助方法
  private void save() {
    manager.getPlayerPersistenceService().saveAsync(this.toRecord());
  }


  private PlayerRecord toRecord() {
    // 您必須確保 LivingState 有實作 deepCopy，否則會發生併發修改例外
    return new PlayerRecord(this.id, // ID
        this.name, // Username
        this.nickname, // Nickname
        this.currentRoomId, // Room
        this.state.deepCopy(), // 【關鍵】深層複製 State
        new ArrayList<GameItem>(this.inventory) // Inventory
    );
  }

  // 只想提供給 GuestBehavior 使用
  public void fromRecord(GuestBehavior behavior, PlayerRecord record) {
    // 更新玩家基礎資料
    this.id = record.id();
    this.name = record.name();
    this.nickname = record.nickname();
    if (this.nickname == null) {
      this.nickname = record.name();
    }
    this.aliases = new String[] {record.name()};
    this.state = record.state();
    this.currentRoomId = record.currentRoomId();
    this.inventory = record.inventory();
  }

}


--- File: RoomActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import com.example.htmlmud.application.factory.WorldFactory;
import com.example.htmlmud.domain.actor.core.VirtualActor; // 引用您的基礎類別
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.SpawnRule;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.RoomMessage;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
// 1. 繼承 VirtualActor，並指定泛型為 RoomMessage
public class RoomActor extends VirtualActor<RoomMessage> {

  @Getter
  private final String id;

  @Getter
  private final RoomTemplate template;

  @Getter
  private final ZoneTemplate zoneTemplate;

  private final List<SpawnRule> mobSpawnRules;

  private final List<SpawnRule> itemSpawnRules;

  private final WorldFactory worldFactory;

  private final GameServices services;


  // 房間內的玩家 (Runtime State)
  @Getter
  private final List<PlayerActor> players = new ArrayList<>();

  @Getter
  private final List<MobActor> mobs = new ArrayList<>();

  @Getter
  private final List<GameItem> items = new ArrayList<>(); // 地上的物品


  public RoomActor(RoomTemplate template, ZoneTemplate zoneTemplate, GameServices services,
      WorldFactory worldFactory) {
    super("room-" + template.id());
    this.worldFactory = worldFactory;
    this.services = services;

    this.id = template.id();
    this.template = template;
    this.zoneTemplate = zoneTemplate;
    // 從 Template 複製規則 (因為這是固定的)
    this.mobSpawnRules = template.mobSpawnRules();
    this.itemSpawnRules = template.itemSpawnRules();

    // 初始生怪
    spawnInitial("mob", mobSpawnRules);

    // 初始物品
    spawnInitial("item", itemSpawnRules);

  }

  // --- 實作父類別的抽象方法 ---
  @Override
  protected void handleMessage(RoomMessage msg) {
    // 這裡的邏輯跟之前一模一樣，但不需要自己寫 loop 和 try-catch 了
    switch (msg) {
      case RoomMessage.Enter(var actor, var future) -> {
        doEnter(actor, future);
      }
      case RoomMessage.Leave(var actorId) -> {
        doLeave(actorId);
      }
      case RoomMessage.Look(var playerId, var future) -> {
        doLook(playerId, future);
      }
      case RoomMessage.Say(var sourceId, var content) -> {
        doSay(sourceId, content);
      }
      case RoomMessage.TryPickItem(var args, var picker, var future) -> {
        doTryPickItem(args, picker, future);
      }
      case RoomMessage.Tick(var tickCount, var timestamp) -> {
        doTick(tickCount, timestamp);
      }
      case RoomMessage.Broadcast(var message) -> {
        doBroadcast(message);
      }
      case RoomMessage.BroadcastToOthers(var sourceId, var message) -> {
        doBroadcastToOthers(sourceId, message);
      }
      case RoomMessage.FindActor(var actorId, var future) -> {
        doFindActor(actorId, future);
      }

    }
  }

  private void doEnter(LivingActor actor, CompletableFuture<Void> future) {
    switch (actor) {
      case PlayerActor player -> doPlayerEnter(player, future);
      case MobActor mob -> doMobEnter(mob, future);
    }
  }

  private void doPlayerEnter(PlayerActor player, CompletableFuture<Void> future) {
    log.info("Player {} entered room", player.getName());
    player.markEnterRoom();
    if (!players.contains(player)) {
      players.add(player);
      player.setCurrentRoomId(this.id);
    }
    doBroadcastToOthers(player.getId(), "看到 " + player.getName() + " 走了進來。");
    log.info("Player {} entered room {}", player.getNickname(), template.id());
    if (future != null) {
      future.complete(null);
    }
  }

  private void doMobEnter(MobActor mob, CompletableFuture<Void> future) {
    log.info("Mob {} entered room", mob.getName());
    mob.markEnterRoom();
    if (!mobs.contains(mob)) {
      mobs.add(mob);
      mob.setCurrentRoomId(this.id);
    }
    doBroadcast("看到 " + mob.getName() + " 走了進來。");

    if (future != null) {
      future.complete(null);
    }
  }

  private void doLeave(String actorId) {
    CompletableFuture<LivingActor> future = new CompletableFuture<>();
    findActor(actorId, future);
    LivingActor actor = future.join();
    if (actor == null) {
      return;
    }
    switch (actor) {
      case PlayerActor player -> doPlayerLeave(player);
      case MobActor mob -> doMobLeave(mob);
    }
  }

  private void doPlayerLeave(PlayerActor player) {
    if (players.remove(player)) {
      doBroadcastToOthers(player.getId(), player.getName() + " 離開了。");
    }
  }

  private void doMobLeave(MobActor mob) {
    if (mobs.remove(mob)) {
      doBroadcast(mob.getName() + " 離開了。");
    }
  }

  private void doLook(String playerId, CompletableFuture<String> future) {
    log.info("Player {} Look room", playerId);

    StringBuilder sb = new StringBuilder();
    sb.append("\u001B[1;36m").append(template.name()).append("\u001B[0m\r\n");
    sb.append(template.description()).append("\r\n");

    if (template.exits() != null && !template.exits().isEmpty()) {
      sb.append("\u001B[33m[出口]: ").append(String.join(", ", template.exits().keySet()))
          .append("\u001B[0m\r\n");
    }

    StringBuilder others = new StringBuilder();
    players.stream().filter(p -> !p.getId().equals(playerId))
        .forEach(p -> others.append(p.getNickname()).append(" "));

    if (!others.isEmpty()) {
      sb.append("\u001B[35m[這裡有]: \u001B[0m").append(others).append("\r\n");
    }
    future.complete(sb.toString());
  }

  private void doSay(String sourceId, String content) {
    PlayerActor speaker =
        players.stream().filter(p -> p.getId().equals(sourceId)).findFirst().orElse(null);
    String name = (speaker != null) ? speaker.getName() : "有人";
    doBroadcast(name + ": " + content);
  }

  private void doTryPickItem(String args, PlayerActor picker, CompletableFuture<GameItem> future) {
    GameItem targetItem = services.targetSelector().selectItem(this.getItemsSnapshot(), args);
    if (targetItem == null) {
      // actor.reply("這裡沒有看到 '" + args + "'。");
      future.complete(null);
      return;
    }

    this.items.remove(targetItem);

    // 廣播
    doBroadcastToOthers(picker.getId(), picker.getName() + " 撿起了 " + targetItem.getDisplayName());

    // 回傳成功
    future.complete(targetItem);
  }

  // 處理邏輯
  private void doTick(long tickCount, long timestamp) {
    // log.info("{} tickCount: {}", id, tickCount);

    // === 1. World/Zone 層級邏輯 (例如：每 60 秒檢查一次重生) ===
    if (tickCount % zoneTemplate.respawnRate() == 0) {
      checkSpawnRule(); // 檢查是否有怪物死掉很久該重生了
    }

    // === 2. 轉發給 Actor ===
    // 過濾掉 "完全沒事做且沒玩家在場" 的怪物
    if (!players.isEmpty() || mobs.stream().anyMatch(m -> m.getState().isInCombat())) {
      ActorMessage.Tick msg = new ActorMessage.Tick(tickCount, timestamp);

      for (MobActor mob : mobs) {
        mob.send(msg);
      }

      for (PlayerActor player : players) {
        // log.info("send player");
        player.send(msg);
      }
    }
  }

  private void doBroadcast(String message) {
    players.forEach(p -> p.reply(message));
  }

  private void doBroadcastToOthers(String sourceId, String message) {
    players.stream().filter(p -> !p.getId().equals(sourceId)).forEach(p -> p.reply(message));
  }

  private void doFindActor(String actorId, CompletableFuture<LivingActor> future) {

    // 先檢查mob
    for (MobActor mob : mobs) {
      if (mob.getId().equals(actorId)) {
        future.complete(mob);
        return;
      }
    }

    for (PlayerActor player : players) {
      if (player.getId().equals(actorId)) {
        future.complete(player);
        return;
      }
    }

    future.complete(null);
  }



  // 公開給外部呼叫的方法 -------------------------------------------------------------------------
  public void enter(LivingActor actor, CompletableFuture<Void> future) {
    this.send(new RoomMessage.Enter(actor, future));
  }

  public void leave(String actorId) {
    this.send(new RoomMessage.Leave(actorId));
  }

  public void look(String playerId, CompletableFuture<String> future) {
    this.send(new RoomMessage.Look(playerId, future));
  }

  public void say(String sourceId, String content) {
    this.send(new RoomMessage.Say(sourceId, content));
  }

  public void tick(long tickCount, long timestamp) {
    this.send(new RoomMessage.Tick(tickCount, timestamp));
  }

  public void tryPickItem(String args, PlayerActor picker, CompletableFuture<GameItem> future) {
    this.send(new RoomMessage.TryPickItem(args, picker, future));
  }

  public void broadcast(String message) {
    this.send(new RoomMessage.Broadcast(message));
  }

  public void broadcastToOthers(String sourceId, String message) {
    this.send(new RoomMessage.BroadcastToOthers(sourceId, message));
  }

  public void findActor(String actorId, CompletableFuture<LivingActor> future) {
    this.send(new RoomMessage.FindActor(actorId, future));
  }



  // --- 物品操作邏輯 ---

  // --- 輔助方法 (保持不變) ---

  // 產生快照 (只存變動的部分)
  public RoomStateRecord toRecord() {
    String[] args = template.id().split(":");
    String zoneId = args[0];
    String roomId = args[1];
    return new RoomStateRecord(roomId, zoneId, new ArrayList<>(items));
  }

  public List<PlayerActor> getPlayersSnapshot() {
    List<PlayerActor> players = new ArrayList<>(this.players);
    players.sort(Comparator.comparing(PlayerActor::getNickname));
    return players;
  }

  /**
   * 獲取有序快照 排序規則：先根據進入時間 (老鳥在前)，如果時間一樣，再比對 ID
   */
  public List<MobActor> getMobsSnapshot() {
    // 1. 複製 (O(N))
    List<MobActor> snapshot = new ArrayList<>(this.mobs);

    // 2. 排序 (O(N log N))
    // 排序規則：名稱 -> 進入時間 -> ID
    snapshot.sort(Comparator.comparing((MobActor m) -> m.getTemplate().name())
        .thenComparingLong(MobActor::getLastEnterRoomTime).thenComparing(MobActor::getId));

    return snapshot;
  }

  public List<GameItem> getItemsSnapshot() {
    return new ArrayList<>(items);
  }

  private void dropItem(GameItem item) {
    items.add(item);
    // 標記為 Dirty (需要存檔)
    // WorldManager.markDirty(this.template.id());
  }

  private void removeItem(GameItem item) {
    items.remove(item);
    // 標記為 Dirty (需要存檔)
    // WorldManager.markDirty(this.template.id());
  }

  // TODO
  private void checkSpawnRule() {

  }

  /**
   * 房間初次載入時的生怪邏輯
   */
  private void spawnInitial(String type, List<SpawnRule> rules) {
    if (rules == null)
      return;

    for (SpawnRule rule : rules) {
      // 處理機率 (例如：稀有怪只有 10% 機率出現)
      if (Math.random() > rule.respawnChance()) {
        continue;
      }

      // 根據數量生成
      for (int i = 0; i < rule.count(); i++) {
        switch (type) {
          case "mob":
            spawnOneMob(rule);
            break;
          case "item":
            spawnOneItem(rule);
            break;
        }
      }
    }
  }

  private void spawnOneMob(SpawnRule rule) {
    // 1. 呼叫工廠產生 MobActor (這裡會給予 UUID)
    MobActor mob = worldFactory.createMob(rule.id());
    try {
      log.info("{}: {} - {}", mob.getId(), mob.getName(),
          services.objectMapper().writeValueAsString(mob.getTemplate()));
    } catch (Exception e) {
      e.printStackTrace();
    }

    // // 2. 設定位置
    mob.setCurrentRoomId(this.id);

    // // 3. 加入房間列表
    this.mobs.add(mob);

    // // 4. 啟動怪物的 AI
    mob.start();

    log.info("Spawned {} in room {}", mob.getTemplate().name(), this.id);
  }

  private void spawnOneItem(SpawnRule rule) {
    GameItem item = worldFactory.createItem(rule.id());
    if (item == null) {
      return;
    }

    this.items.add(item);
    log.info("Spawned {} in room {}", item.getDisplayName(), this.id);
  }

}


--- File: GameServices.java ---

package com.example.htmlmud.domain.context;

import java.util.concurrent.ScheduledExecutorService;
import org.springframework.context.ApplicationEventPublisher;
import com.example.htmlmud.application.command.CommandDispatcher;
import com.example.htmlmud.application.command.parser.TargetSelector;
import com.example.htmlmud.domain.service.CombatService;
import com.fasterxml.jackson.databind.ObjectMapper;

public record GameServices(

    ObjectMapper objectMapper,

    CombatService combatService,

    CommandDispatcher commandDispatcher,

    ScheduledExecutorService scheduler,

    ApplicationEventPublisher eventPublisher,

    TargetSelector targetSelector

) {

}


--- File: MudContext.java ---

package com.example.htmlmud.domain.context;

import com.example.htmlmud.domain.actor.impl.PlayerActor;

public class MudContext {

  // 1. 當前操作的玩家 Actor (最重要的)
  public static final ScopedValue<PlayerActor> CURRENT_PLAYER = ScopedValue.newInstance();

  // 2. 當前的 Trace ID (除錯用)
  public static final ScopedValue<String> TRACE_ID = ScopedValue.newInstance();

  // 輔助方法：取得當前玩家，如果沒設定(例如系統背景作業)則拋出異常
  public static PlayerActor currentPlayer() {
    return CURRENT_PLAYER
        .orElseThrow(() -> new IllegalStateException("錯誤：嘗試在非 Request Scope 獲取 CurrentPlayer"));
  }

  // 輔助方法：取得當前 TraceId，沒綁定就回傳 "SYSTEM"
  public static String traceId() {
    return TRACE_ID.orElse("UNKNOWN");
  }

}


--- File: MudKeys.java ---

package com.example.htmlmud.domain.context;

public class MudKeys {

  public static final String PLAYER_ID = "MUD_PLAYER_ID";

  public static final String AUTH_RETRY_COUNT_KEY = "AUTH_RETRY_COUNT";

}


--- File: DomainEvent.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;
import com.example.htmlmud.domain.actor.impl.PlayerActor;

/**
 * 領域事件的根介面 使用 sealed 限制只有特定的 record 可以實作它
 */
public sealed interface DomainEvent permits DomainEvent.SessionEvent, DomainEvent.SystemEvent,
    DomainEvent.WorldEvent, PlayerEvents, MobEvents {

  // 所有事件都必須有的 metadata
  Instant occurredOn();

  // 預設實作，方便取得當下時間
  static Instant now() {
    return Instant.now();
  }

  /**
   * 連線相關事件
   */
  sealed interface SessionEvent extends DomainEvent
      permits SessionEvent.Established, SessionEvent.MessageReceived, SessionEvent.Closed {

    String sessionId();

    record Established(String sessionId, Instant occurredOn) implements SessionEvent {
    }

    record MessageReceived(String sessionId, String message, Instant occurredOn)
        implements SessionEvent {
    }

    record Closed(String sessionId, String reason, int statusCode, Instant occurredOn)
        implements SessionEvent {
    }
  }

  /**
   * 系統指令與認證事件
   */
  sealed interface SystemEvent extends DomainEvent
      permits SystemEvent.Authenticate, SystemEvent.RegisterUsername, SystemEvent.RegisterPassword,
      SystemEvent.Login, SystemEvent.Logout {

    String sessionId();

    record RegisterUsername(String sessionId, String input, Instant occurredOn)
        implements SystemEvent {
    }

    record RegisterPassword(String sessionId, String input, Instant occurredOn)
        implements SystemEvent {
    }


    record Login(String sessionId, String input, Instant occurredOn) implements SystemEvent {
    }

    record Authenticate(String sessionId, String input, Instant occurredOn) implements SystemEvent {
    }

    record Logout(String sessionId, PlayerActor player, Instant occurredOn) implements SystemEvent {
    }
  }

  /**
   * 遊戲世界運行事件
   */
  sealed interface WorldEvent extends DomainEvent permits WorldEvent.Tick {

    record Tick(long gameTickTime, Instant occurredOn) implements WorldEvent {
    }
  }

}


--- File: MobEvents.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;
import java.util.Map;

public sealed interface MobEvents extends DomainEvent permits MobEvents.MobDead {
  // 怪物死亡
  record MobDead(String mobId, String killerId, // 誰殺的
      Map<String, Double> dropItems, // 掉落物預覽
      Instant occurredOn) implements MobEvents {
  }
}


--- File: PlayerEvents.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;

public sealed interface PlayerEvents extends DomainEvent
    permits PlayerEvents.LoggedIn, PlayerEvents.LoggedOut, PlayerEvents.LevelUp {

  // 1. 玩家登入事件
  record LoggedIn(String playerId, String username, String ipAddress, Instant occurredOn)
      implements PlayerEvents {
    public LoggedIn(String playerId, String username, String ipAddress) {
      this(playerId, username, ipAddress, DomainEvent.now());
    }
  }

  // 2. 玩家登出事件
  record LoggedOut(String playerId, Instant occurredOn) implements PlayerEvents {
    public LoggedOut(String playerId) {
      this(playerId, DomainEvent.now());
    }
  }

  // 3. 玩家升級
  record LevelUp(String playerId, int newLevel, Instant occurredOn) implements PlayerEvents {
    public LevelUp(String playerId, int newLevel) {
      this(playerId, newLevel, DomainEvent.now());
    }
  }
}


--- File: ConsumableProp.java ---

package com.example.htmlmud.domain.model;

public record ConsumableProp(

    String effect,

    int value

) {
}


--- File: DamageType.java ---

package com.example.htmlmud.domain.model;

/**
 * 枚举，表示战斗系统中的不同伤害类型。
 */
public enum DamageType {
  /**
   * 物理伤害，通常来自武器或徒手攻击。
   */
  PHYSICAL,

  /**
   * 魔法伤害，来自法术或附魔物品。
   */
  MAGICAL,

  /**
   * 内伤，影响气或精神，通常能穿透物理护甲。
   */
  INTERNAL
}


--- File: Direction.java ---

package com.example.htmlmud.domain.model;

import lombok.Getter;

@Getter
public enum Direction {
  NORTH("north", "n", "北方"),

  SOUTH("south", "s", "南方"),

  EAST("east", "e", "東方"),

  WEST("west", "w", "西方"),

  NORTHEAST("northeast", "ne", "東北方"),

  NORTHWEST("northwest", "nw", "西北方"),

  SOUTHEAST("southeast", "se", "東南方"),

  SOUTHWEST("southwest", "sw", "西南方"),

  UP("up", "u", "上方"),

  DOWN("down", "d", "下方");

  private final String fullName;
  private final String shortName;
  private final String displayName;

  Direction(String fullName, String shortName, String displayName) {
    this.fullName = fullName;
    this.shortName = shortName;
    this.displayName = displayName;
  }

  // 解析輸入字串 (例如輸入 "n" 或 "North" 都能找到)
  public static Direction parse(String input) {
    if (input == null)
      return null;
    String normalized = input.trim().toLowerCase();
    for (Direction d : values()) {
      if (d.fullName.equals(normalized) || d.shortName.equals(normalized)) {
        return d;
      }
    }
    return null;
  }

  // 取得反方向 (用於：你往北走，別人看到你從"南"邊來)
  public Direction opposite() {
    return switch (this) {
      case NORTH -> SOUTH;
      case SOUTH -> NORTH;
      case EAST -> WEST;
      case WEST -> EAST;
      case NORTHEAST -> SOUTHWEST;
      case NORTHWEST -> SOUTHEAST;
      case SOUTHEAST -> NORTHWEST;
      case SOUTHWEST -> NORTHEAST;
      case UP -> DOWN;
      case DOWN -> UP;
    };
  }
}


--- File: Effect.java ---

package com.example.htmlmud.domain.model;

public enum Effect {

  // debuffs
  POISONED("中毒"), // 中毒
  STUNED("昏迷"), // 昏迷
  SILENCED("禁言"), // 禁言
  FEAR("恐懼"), // 恐懼
  SLOW("減速"), // 減速
  WEAKENED("虛弱"), // 虛弱
  CURSED("詛咒"), // 詛咒
  BURNING("燃燒"), // 燃燒
  FROZEN("冰凍"), // 冰凍
  PARALYZED("麻痺"), // 麻痺
  CONFUSED("混亂"), // 混亂
  ENTANGLED("糾纏"), // 糾纏
  DISEASED("疾病"), // 疾病
  FATIGUED("疲勞"), // 疲勞
  CHARMED("魅惑"), // 魅惑
  POOR_VISION("視力不良"), // 視力不良
  DEAFENED("失聰"), // 失聰
  BLINDED("失明"), // 失明
  SAPPED("能量耗盡"), // 能量耗盡
  ANCHORED("定身"), // 定身
  CURSED_WEAPON("詛咒武器"), // 詛咒武器

  // buffs
  HEALING("治療"), // 治療
  REGENERATION("再生"), // 再生
  HASTE("加速"), // 加速
  SANCTUARY("聖護"), // 聖護
  STRENGTHEN("強化"), // 強化
  SHIELD("盾牌"), // 盾牌
  INVIGORATE("振奮"), // 振奮
  PROTECTION("保護"), // 保護
  BLESSING("祝福"), // 祝福
  FORTITUDE("堅韌"), // 堅韌
  CLARITY("清晰"), // 清晰
  SWIFTNESS("敏捷"), // 敏捷
  RESISTANCE("抵抗"), // 抵抗
  LUCK("幸運"), // 幸運
  VISION("視野"), // 視野
  ENERGY_BOOST("能量提升"), // 能量提升
  COURAGE("勇氣"), // 勇氣
  TRANQUILITY("寧靜"), // 寧靜
  FURY("狂怒"), // 狂怒
  BRAVERY("勇敢"), // 勇敢
  FOCUSING("專注中"), // 專注中

  // neutral
  INVISIBLE("隱形"); // 隱形

  private final String description;

  Effect(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }
}


--- File: EquipmentProp.java ---

package com.example.htmlmud.domain.model;

public record EquipmentProp(

    EquipmentSlot slot, // 裝備位置

    String attackVer, // 攻擊動詞: "咬", "抓", "揮拳"

    int damage, // 基礎傷害

    int defense, // 基礎防禦

    int weight, // 重量

    int attackSpeed, // 攻速

    int maxDurability // 最大耐久 100

) {
}


--- File: EquipmentSlot.java ---

package com.example.htmlmud.domain.model;

// 裝備部位 (這也是一種 Enum)
public enum EquipmentSlot {

  // 裝備部位
  HEAD("頭部"),

  FACE("臉部"),

  NECK("頸部"),

  SHOULDERS("肩部"),

  ARMS("手臂"),

  WRISTS("腕部"),

  HANDS("手部"),

  BODY("身體"),

  CHEST("胸部"),

  BACK("背部"),

  WAIST("腰部"),

  LEGS("腿部"),

  FEET("腳部"),

  FINGER_1("戒指1"), FINGER_2("戒指2"),


  // 武器部位
  MAIN_HAND("主手"),

  OFF_HAND("副手");

  private final String displayName;

  EquipmentSlot(String displayName) {
    this.displayName = displayName;
  }

  public String getDisplayName() {
    return displayName;
  }
}


--- File: GameItem.java ---

package com.example.htmlmud.domain.model;

import java.util.HashMap;
import java.util.Map;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Data // Lombok
@NoArgsConstructor
@AllArgsConstructor
public class GameItem {

  // 1. 唯一識別 (UUID)
  // 每個物品都有獨立 ID，方便追蹤 (例如防止複製 Bug)
  private String id;

  @Getter
  private ItemTemplate template;

  // 動態數據 (會變的)
  private int level;
  private int currentDurability; // 耐久性
  private int amount; // 堆疊數量 (如果是藥水/錢幣)

  // 隨機數值/詞綴 (Affixes)
  // 例如：{ "attack_bonus": 5, "crafter": "玩家A" }
  private Map<String, Object> dynamicProps = new HashMap<>();

  // 輔助方法：獲取顯示名稱 (包含強化等級)
  // e.g., "鐵劍 (+5)"
  public String getDisplayName() {
    if (level > 1) {
      return template.name() + " (+" + level + ")";
    }
    return template.name();
  }

  // 業務邏輯直接寫在 POJO 裡
  public void decreaseDurability(int amount) {
    this.currentDurability -= amount;
    if (this.currentDurability < 0)
      this.currentDurability = 0;
  }
}


--- File: ItemLocation.java ---

package com.example.htmlmud.domain.model;

public enum ItemLocation {

  GROUND("地上"),

  INVENTORY("背包中"),

  EQUIPPED("裝備中"),

  CONTAINER("在容器內");

  private final String description;

  ItemLocation(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }
}


--- File: ItemType.java ---

package com.example.htmlmud.domain.model;

/**
 * 物品類型定義
 */
public enum ItemType {
  /** 裝備類 */
  EQUIPMENT("裝備"),
  /** 消耗品 (藥水、食物等) */
  CONSUMABLE("消耗品"),
  /** 關鍵物品 (任務道具、鑰匙) */
  KEY_ITEM("關鍵物品"),
  /** 材料 (鍛造、煉金原料) */
  MATERIAL("材料"),
  /** 其他 */
  OTHER("其他");

  private final String description;

  ItemType(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }
}


--- File: LivingState.java ---

package com.example.htmlmud.domain.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import java.util.HashMap;
import java.util.Map;

// 這個物件會被序列化存入 players.state_json 和 mobs.state_json
@JsonIgnoreProperties(ignoreUnknown = true)
public class LivingState {
  // public String sex; // 性別
  // public String race; // 種族 (人類、精靈等，通常會給予不同的初始屬性加成)

  public int level = 1;
  public int age = 12; // 年齡 age
  public int maxAge = 100; // 最大年齡
  public int hp;
  public int maxHp;
  public int mp;
  public int maxMp;
  public int stamina; // 體力值
  public int maxStamina; // 最大體力值
  private int qi = 50; // 氣 (用於武功傷害計算)
  private int maxQi; // 最大氣值
  private int san; // 理智值
  private int maxSan; // 最大理智值

  private int exp = 0; // 經驗值
  private int combatExp = 0; // 戰鬥經驗值


  // 基礎屬性
  public int str = 5; // 力量 strength (影響 物理傷害、角色負重上限)
  public int intelligence = 5; // 智力 intelligence (影響 魔法傷害、法力上限MP、學習技能的速度)
  public int agi = 5; // 敏捷 agility (影響 攻擊速度、躲避率Evasion、命中率Hit Rate)
  public int con = 5; // 體質 constitution (影響 生命值HP上限、防禦力、體力恢復速度)
  private int wis; // 智慧 wisdom (影響 魔法威力)
  private int dex = 5; // 靈巧 dexterity (影響 物理威力)
  private int cha; // 魅力 charisma
  private int luk; // 福緣 luck
  private int karma; // 因果 karma
  private int spi; // 靈性 spirit
  private int cou; // 膽識 courage
  private int conce; // 定力 concentration
  private int app; // 容貌 appearance

  private int reputation; // 名聲 (影響 與 NPC 的互動)
  private int potential; // 潛力 (影響 學習特定高級武功的限制)


  // === 戰鬥狀態 ===
  @JsonIgnore
  public transient boolean isInCombat = false;
  // 當前鎖定的攻擊目標 ID (null 代表沒在打架)
  @JsonIgnore
  public transient String combatTargetId;

  @JsonIgnore
  public transient long nextAttackTime = 0; // 下一次可以攻擊的時間點 (System.currentTimeMillis)

  // 戰鬥狀態 (不存入 DB，或是標記 @JsonIgnore)
  @JsonIgnore
  public transient boolean isDead = false;

  // === 裝備欄位 ===
  public Map<EquipmentSlot, GameItem> equipment = new HashMap<>();

  // 衍生屬性 (快取用，每次穿脫裝備後重新計算 通常不存 DB，由基礎屬性計算，但為了簡單先存這裡)
  public int damage = 1; // 攻擊力
  public int defense = 0; // 防禦力
  public int attackSpeed = 2000; // 攻擊速度 (毫秒，例如 2000 代表 2秒打一次)
  public int weightCapacity;

  // 建構子與輔助方法...
  @JsonIgnore
  public boolean isDead() {
    return hp <= 0;
  }

  // 判斷是否在戰鬥中
  @JsonIgnore
  public boolean isInCombat() {
    return isInCombat && combatTargetId != null;
  }

  public LivingState deepCopy() {
    LivingState copy = new LivingState();
    copy.level = this.level;
    copy.hp = this.hp;
    copy.maxHp = this.maxHp;
    copy.mp = this.mp;
    copy.maxMp = this.maxMp;
    // Map 也要複製
    // if (this.attributes != null) {
    // copy.attributes = new HashMap<>(this.attributes);
    // }
    copy.str = this.str;
    copy.dex = this.dex;
    copy.con = this.con;
    copy.damage = this.damage;
    copy.defense = this.defense;
    copy.attackSpeed = this.attackSpeed;
    // copy.isDead = this.isDead;
    // copy.isInCombat = this.isInCombat;
    // copy.nextAttackTime = this.nextAttackTime;
    return copy;
  }
}


--- File: LivingState2.java ---

package com.example.htmlmud.domain.model;

public enum LivingState2 {

  STANDING("站立"),

  SITTING("坐下"),

  RESTING("躺下休息"),

  SLEEPING("睡覺"),

  FIGHTING("戰鬥中"),

  STUNNED("暈眩"),

  DEAD("死亡");

  private final String description;

  LivingState2(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }

}


--- File: MobKind.java ---

package com.example.htmlmud.domain.model;

public enum MobKind {
  FRIENDLY, // 友善 (村長, 商人)
  NEUTRAL, // 中立 (鹿, 黃牛 - 被打才會反擊)
  AGGRESSIVE, // 主動攻擊 (哥布林, 狼)
  BOSS // 首領 (顯示時可能會有特殊顏色)
}


--- File: PlayerRecord.java ---

package com.example.htmlmud.domain.model;

import java.util.List;

// 這是在 Actor 之間傳遞的快照 (Snapshot)
public record PlayerRecord(

    String id,

    String name,

    String nickname,

    String currentRoomId,

    // 注意：如果是 Record，這裡最好是 Deep Copy 後的資料
    LivingState state,

    List<GameItem> inventory

) {
}


--- File: RoomFlag.java ---

package com.example.htmlmud.domain.model;

public enum RoomFlag {
  // Environment
  INDOORS, OUTDOORS, DARK, UNDERWATER,
  // Combat
  SAFE_ZONE, NO_PVP, ARENA,
  // Movement
  NO_RECALL, NO_TELEPORT, PRIVATE,
  // Special
  NO_MAGIC, BANK, SHOP
}


--- File: RoomStateRecord.java ---

package com.example.htmlmud.domain.model;

import java.util.List;

public record RoomStateRecord(String roomId, String zoneId, List<GameItem> droppedItems) {

}


--- File: Equipment.java ---

package com.example.htmlmud.domain.model.map;

import lombok.Builder;

@Builder(toBuilder = true)
public record Equipment(

    String head, // 頭部

    String face, // 臉部

    String neck, // 頸部

    String shoulders, // 肩部

    String arms, // 手臂

    String wrists, // 腕部

    String hands, // 手部

    String body, // 身體

    String chest, // 胸部

    String back, // 背部

    String waist, // 腰部

    String legs, // 腿部

    String feet, // 脚部

    String finger_1, // 戒指1

    String finger_2, // 戒指2

    String mainHand, // 主手

    String offHand // 副手
) {
}


--- File: ItemTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.Map;
import com.example.htmlmud.domain.model.EquipmentSlot;
import com.example.htmlmud.domain.model.ConsumableProp;
import com.example.htmlmud.domain.model.EquipmentProp;
import com.example.htmlmud.domain.model.ItemLocation;
import com.example.htmlmud.domain.model.ItemType;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;

// 5. 物品/裝備重置 (ItemReset)
@Builder(toBuilder = true)
public record ItemTemplate(

    String id,

    String name, // "鐵劍"

    @JsonProperty("keywords") String[] aliases,

    String description, // "一把普通的鐵劍。"

    // ItemLocation location, // "inventory"(背包), "weapon"(手), "body"(身)...

    ItemType type,

    EquipmentProp equipmentProp, // 装備屬性

    ConsumableProp consumableProp, // 消秏品屬性

    String quality, // 品質 common,

    int value, // 價值

    int level, // 等級

    // 屬性加成 (例如：力量+5)
    Map<String, Integer> bonusStats,

    Map<String, Object> extraProps // 其他靜態屬性

) {
}


--- File: MobTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.Map;
import java.util.Set;
import com.example.htmlmud.domain.model.MobKind;
import lombok.Builder;

@Builder(toBuilder = true)
public record MobTemplate(

    String id,

    String name,

    String[] aliases,

    MobKind kind,

    int level,

    int maxHp,

    int maxMp,

    int maxStamina,

    int maxSan,

    String roomDescription,

    String lookDescription,

    int expReward, // 死亡給多少經驗

    boolean isAggressive, // 是否主動攻擊

    boolean isInvincible, // 是否無敵

    Set<String> dialogues, // 預設對話庫
    // 掉落表 ID, 商店列表 ID...
    Integer shopId,

    // === 天生攻擊定義 (Natural Attack) ===
    // 如果手上沒武器，就用這個設定
    String attackVerb, // 攻擊動詞: "咬", "抓", "揮拳"
    String attackNoun, // 攻擊部位: "尖銳的牙齒", "利爪", "拳頭"
    int baseDamage, // 天生基礎傷害
    int baseDefense, // 天生防禦力
    int attackSpeed, // 天生攻速
    int weight, // 天生重量

    Map<String, String> equipment // 装備

) {
}


--- File: RoomExit.java ---

package com.example.htmlmud.domain.model.map;

import com.example.htmlmud.infra.persistence.json.ExitDeserializer;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import lombok.Builder;

// 3. 出口 (RoomExit) - 支援單向、門鎖、隱藏
@Builder(toBuilder = true)
@JsonDeserialize(using = ExitDeserializer.class)
public record RoomExit(

    @JsonProperty("targetId") String targetRoomId, // 目標房間 ID

    String doorName, // 門的名稱 (null 代表無門，直接通行)

    boolean isLocked, // 預設是否上鎖

    String keyId, // 需要的鑰匙 Template ID

    boolean isHidden, // 是否隱藏 (需 search)

    boolean pickProof // 是否無法被盜賊撬開？

) {
  // 為了方便 JSON 簡寫 (如果只有 targetId)，可以透過 Custom Deserializer 處理，
  // 或者在 Java 程式碼中提供一個簡易建構的靜態方法。
  public static RoomExit of(String targetId) {
    return new RoomExit(targetId, null, false, null, false, false);
  }
}


--- File: RoomTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.List;
import java.util.Map;
import java.util.Set;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;

// 2. 房間 (Room)
@Builder(toBuilder = true)
public record RoomTemplate(

    String id, // e.g., square

    String zoneId,

    String name, // e.g., "中央廣場"

    String description, // 描述

    List<String> flags, // e.g., ["SAFE", "OUTDOORS"]

    Map<String, RoomExit> exits, // Key: 方向 (north, east), Value: 出口詳細資訊

    @JsonProperty("population") List<SpawnRule> mobSpawnRules,

    @JsonProperty("items") List<SpawnRule> itemSpawnRules,

    @JsonProperty("extra_data") Map<String, Object> extraData // 額外擴充資料 (e.g. 腳本觸發參數)

) {
}


--- File: SpawnRule.java ---

package com.example.htmlmud.domain.model.map;

import lombok.Builder;

// Mob/Item 重生設定 (Mob/Item Reset)
@Builder(toBuilder = true)
public record SpawnRule(

    String id, // 怪物原型 mobTemplateId

    int count, // 該房間上限幾隻

    int respawnTime, // 重生秒數 (-1 代表不重生，0 代表使用區域預設)

    double respawnChance // 重生機率 (0.0 - 1.0)

) {
}


--- File: ZoneTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.List;

// 1. 區域 (Zone) - 靜態地圖檔的根物件
public record ZoneTemplate(

    String id, // e.g., "area_newbie"

    String name, // e.g., "新手村"

    int minLevel,

    int maxLevel,

    int respawnRate, // 怪物重生間隔 (秒)

    List<String> authors, // 作者與可修改者

    List<String> flags // e.g., ["SAFE", "OUTDOORS"]

) {
}


--- File: DamageSource.java ---

package com.example.htmlmud.domain.model.vo;

public record DamageSource(

    String name, // 來源名稱 (ex: "生鏽鐵劍", "巨大的門牙")
    String verb, // 動詞 (ex: "揮砍", "咬")
    int damage, // 數值
    int speed // 攻速

) {
}


--- File: CombatService.java ---

package com.example.htmlmud.domain.service;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadLocalRandom;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.stereotype.Service;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.LivingState;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class CombatService {

  private final ObjectProvider<WorldManager> servicesProvider;

  /**
   * 執行一次攻擊判定
   *
   * @return 造成的傷害值 (0 代表未命中或被格擋)
   */
  public int calculateDamage(LivingActor attacker, LivingActor defender) {
    LivingState attState = attacker.getState();
    LivingState defState = defender.getState();

    // 1. 命中判定 (範例：敏捷越高，命中越高)
    // 假設基礎命中 80% + (攻方敏捷 - 守方敏捷)%
    double hitChance = 0.8 + ((attState.agi - defState.agi) * 0.01);
    if (ThreadLocalRandom.current().nextDouble() > hitChance) {
      return -1; // -1 代表 Miss
    }

    // 2. 傷害公式 (範例：攻擊力 - 防禦力，浮動 10%)
    log.info("attState.damage:{} defState.defense:{}", attState.damage, defState.defense);
    int rawDmg = attState.damage - defState.defense;
    if (rawDmg <= 0)
      rawDmg = 1; // 至少造成 1 點傷害

    // 加入浮動 (0.9 ~ 1.1)
    double variance = 0.9 + (ThreadLocalRandom.current().nextDouble() * 0.2);
    int finalDmg = (int) (rawDmg * variance);

    return finalDmg;
  }

  /**
   * 計算獲得經驗值 (範例)
   */
  public int calculateExp(LivingActor mob, LivingActor player) {
    return mob.getState().level * 10;
  }

  public LivingActor processAutoAttack(LivingActor attacker, String roomId, String targetId) {
    WorldManager manager = servicesProvider.getObject();

    // 1. 檢查攻速冷卻
    // 2. 檢查目標是否還在房間裡 / 是否還活著
    // 這裡需要透過 WorldManager 取得真實的 Actor 物件
    RoomActor room = manager.getRoomActor(roomId);
    CompletableFuture<LivingActor> future = new CompletableFuture<>();
    room.findActor(targetId, future);
    LivingActor target = future.join();
    log.info("attacker.getName:{} target getName:{}", attacker.getName(), target.getName());

    if (target == null || target.getState().hp <= 0) {
      stopCombat(attacker, target); // 目標消失或死亡，停止戰鬥
      return target;
    }

    // 3. 執行攻擊 (呼叫 CombatService)
    // 這裡會用到我們上一輪討論的 DamageSource
    int dmg = calculateDamage(attacker, target);

    // 4. 應用傷害
    // target.onAttacked(attacker);

    // 5. 發送訊息給房間所有人
    // attacker.equip(null)
    String verb = "攻擊"; // 或是從 weapon.getVerb() 取得 "揮砍"
    String msg = String.format("%s 用 %s %s %s，造成 %d 點傷害！", attacker.getName(), "拳頭", verb,
        target.getName(), dmg);
    room.broadcast(msg);

    return target;
  }

  public void stopCombat(LivingActor attacker, LivingActor target) {
    attacker.getState().isInCombat = false;
    attacker.getState().combatTargetId = null;
    target.getState().isInCombat = false;
    target.getState().combatTargetId = null;
  }
}


--- File: LivingStateService.java ---

package com.example.htmlmud.domain.service;

import com.example.htmlmud.domain.event.PlayerEvents;
import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class LivingStateService {

  private final ApplicationEventPublisher eventPublisher;

  public void processLevelUp(String playerId, int currentExp) {
    // 1. 執行核心邏輯 (計算等級、加屬性...)
    // int newLevel = calculateLevel(currentExp);

    // 2. 狀態改變完成後，發布事件 (這是一個 Fact)
    // 這行程式碼不關心誰要聽，它只負責說「這件事發生了」
    // eventPublisher.publishEvent(new PlayerEvents.LevelUp(playerId, newLevel, null));
  }
}


--- File: ItemTemplateMapper.java ---

package com.example.htmlmud.infra.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.infra.persistence.entity.ItemTemplateEntity;

@Mapper(componentModel = "spring",
    // 忽略沒對應到的欄位 (重要！防止 MapStruct 報錯說 record 缺欄位)
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    // 當來源是 null 時不覆蓋目標 (選用，視需求而定)
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface ItemTemplateMapper {

  // 1. Entity -> Record (載入時用)
  // MapStruct 會自動對應相同名稱的欄位 (nickname -> nickname)
  ItemTemplate toRecord(ItemTemplateEntity entity);

  // 2. Record -> Entity (存檔時用)
  // 這裡我們通常是用 "更新" 模式，而不是 "新建"
  // @MappingTarget 代表要把 source 的值填入 target
  void updateEntityFromRecord(ItemTemplate source, @MappingTarget ItemTemplateEntity target);
}


--- File: PlayerMapper.java ---

package com.example.htmlmud.infra.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;

@Mapper(componentModel = "spring",
    // 忽略沒對應到的欄位 (重要！防止 MapStruct 報錯說 record 缺欄位)
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    // 當來源是 null 時不覆蓋目標 (選用，視需求而定)
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface PlayerMapper {

  // 1. Entity -> Record (載入時用)
  // MapStruct 會自動對應相同名稱的欄位 (nickname -> nickname)
  PlayerRecord toRecord(CharacterEntity entity);

  // 2. Record -> Entity (存檔時用)
  // 這裡我們通常是用 "更新" 模式，而不是 "新建"
  // @MappingTarget 代表要把 source 的值填入 target
  void updateEntityFromRecord(PlayerRecord source, @MappingTarget CharacterEntity target);
}


--- File: CharacterEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.time.LocalDateTime;
import java.util.List;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.LivingState;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "characters",
    indexes = {@Index(name = "idx_uid_name", columnList = "uid,name", unique = true)})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CharacterEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  // 邏輯關聯 (這裡存 ID 比較簡單，避免 N+1 或 Lazy Loading 問題)
  @Column(nullable = false)
  private String uid;

  private String name;

  private String nickname;

  @Column(name = "look_description")
  private String lookDescription;

  @Column(name = "current_room_id")
  private String currentRoomId;

  // 關鍵：自動將 Java 物件序列化為 MySQL JSON
  // 使用 MySQL 8.4 JSON 類型儲存擴充資料 (例如: HP, Mana, EXP, 背包)
  // 這樣未來新增屬性不用一直改 Table Schema
  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "state_json")
  private LivingState state;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "inventory_json")
  private List<GameItem> inventory; // 背包系統

  // @JdbcTypeCode(SqlTypes.JSON)
  // @Column(name = "skills_json")
  // public PlayerSkills skills; // 技能系統 對應 skills_json

  // @JdbcTypeCode(SqlTypes.JSON)
  // @Column(name = "config_json")
  // public PlayerConfig config; // 設定檔 對應 config_json

  private LocalDateTime createdAt;

  private LocalDateTime modifyAt;

  @PrePersist
  protected void onCreate() {
    createdAt = LocalDateTime.now();
    if (currentRoomId == null)
      currentRoomId = "newbie_village:entrance"; // 預設新手村
  }
}


--- File: ItemTemplateEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name = "item_templates")
@Data
public class ItemTemplateEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  private String name;

  private String description;

  private String slot;

  @Column(name = "max_durability")
  private Integer maxDurability;

  @Column(name = "base_attack")
  private Integer baseAttack;

  @Column(name = "base_defense")
  private Integer baseDefense;

  private Double chance;

}


--- File: RoomStateEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.util.List;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import com.example.htmlmud.domain.model.GameItem;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name = "rooms_state")
@IdClass(RoomStateId.class)
@Data
public class RoomStateEntity {

  @Id
  @Column(name = "room_id", nullable = false)
  private String roomId;

  @Id
  @Column(name = "zone_id", nullable = false)
  private String zoneId;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "dropped_items_json")
  private List<GameItem> droppedItems;

}


--- File: RoomStateId.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.io.Serializable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoomStateId implements Serializable {
  private String roomId;
  private String zoneId;
}


--- File: UserEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.time.LocalDateTime;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  @Column(unique = true, nullable = false)
  private String username;

  @Column(nullable = false)
  private String passwordHash;

  private LocalDateTime createdAt;

  private LocalDateTime lastLoginAt;

  // 這裡甚至不需要關聯 Character 列表，除非後台管理需要
}


--- File: ExitDeserializer.java ---

package com.example.htmlmud.infra.persistence.json;

import java.io.IOException;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;

public class ExitDeserializer extends JsonDeserializer<RoomExit> {

  @Override
  public RoomExit deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    // 1. 判斷當前 JSON Token 是字串還是物件
    if (p.currentToken() == JsonToken.VALUE_STRING) {
      // 【簡寫模式】 "north": "square"
      // 直接把字串當成 targetId
      return RoomExit.of(p.getText());
    } else if (p.currentToken() == JsonToken.START_OBJECT) {
      // 【詳寫模式】 "east": { "targetId": "village_elder_house", "doorName": "厚重的鐵門", "isLocked": true,
      // "isHidden": false, "keyId": "village_elder_key", "pickProof": true }
      // 讀取整個物件節點
      JsonNode node = p.getCodec().readTree(p);

      // 優先讀取 "targetId" (與 RoomExit 的 JsonProperty 一致)，若無則讀取 "targetId"
      String targetId = node.has("targetId") ? node.get("targetId").asText() : null;

      // 讀取選填欄位 (處理 null)
      String doorName = node.has("doorName") ? node.get("doorName").asText() : null;
      boolean isLocked = node.has("isLocked") && node.get("isLocked").asBoolean();
      String keyId = node.has("keyId") ? node.get("keyId").asText() : null;
      boolean isHidden = node.has("isHidden") && node.get("isHidden").asBoolean();
      boolean pickProof = node.has("pickProof") && node.get("pickProof").asBoolean();

      return new RoomExit(targetId, doorName, isLocked, keyId, isHidden, pickProof);
    }

    throw new IOException("Invalid exit format: expected String or Object");
  }
}


--- File: CharacterRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;

public interface CharacterRepository extends JpaRepository<CharacterEntity, String> {
  Optional<CharacterEntity> findByUidAndName(String uid, String name);

  boolean existsByUidAndName(String uid, String name);

}


--- File: ItemTemplateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.ItemTemplateEntity;

public interface ItemTemplateRepository extends JpaRepository<ItemTemplateEntity, String> {

}


--- File: RoomStateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.RoomStateEntity;
import com.example.htmlmud.infra.persistence.entity.RoomStateId;

public interface RoomStateRepository extends JpaRepository<RoomStateEntity, RoomStateId> {

  Optional<RoomStateEntity> findByRoomIdAndZoneId(String roomId, String zoneId);

}


--- File: TemplateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class TemplateRepository {

  // 儲存所有的靜態資料
  // Key: 絕對 ID (e.g., "newbie_village:sword")
  private final Map<String, ZoneTemplate> zoneTemplates = new ConcurrentHashMap<>();
  private final Map<String, RoomTemplate> roomTemplates = new ConcurrentHashMap<>();
  private final Map<String, MobTemplate> mobTemplates = new ConcurrentHashMap<>();
  private final Map<String, ItemTemplate> itemTemplates = new ConcurrentHashMap<>();

  // 註冊方法
  public void registerZone(ZoneTemplate tpl) {
    zoneTemplates.put(tpl.id(), tpl);
  }

  // 查詢方法
  public Optional<ZoneTemplate> findZone(String id) {
    return Optional.ofNullable(zoneTemplates.get(id));
  }

  // 這是給 MapLoader 呼叫的，用來填入資料
  public void registerRoom(RoomTemplate tpl) {
    roomTemplates.put(tpl.id(), tpl);
  }

  // 查詢方法
  public Optional<RoomTemplate> findRoom(String id) {
    return Optional.ofNullable(roomTemplates.get(id));
  }

  public void registerMob(MobTemplate tpl) {
    mobTemplates.put(tpl.id(), tpl);
  }

  public Optional<MobTemplate> findMob(String id) {
    return Optional.ofNullable(mobTemplates.get(id));
  }

  public void registerItem(ItemTemplate tpl) {
    itemTemplates.put(tpl.id(), tpl);
  }

  public Optional<ItemTemplate> findItem(String id) {
    return Optional.ofNullable(itemTemplates.get(id));
  }


  // 檢查資料完整性 (Server 啟動時檢查)
  public void validate() {
    // 檢查 room 的 exit 是否指向存在的 room id
    // 檢查 mob 的 loot table 是否指向存在的 item id
  }
}


--- File: UserRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.UserEntity;

public interface UserRepository extends JpaRepository<UserEntity, String> {

  Optional<UserEntity> findByUsername(String username);

  boolean existsByUsername(String username);

}


--- File: PlayerPersistenceService.java ---

package com.example.htmlmud.infra.persistence.service;

import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.infra.mapper.PlayerMapper;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

@Slf4j
@Service
@RequiredArgsConstructor
public class PlayerPersistenceService {

  private final PlayerMapper mapper; // 注入 MapStruct
  private final CharacterRepository playerRepository;

  // 1. 緩衝佇列 (Thread-Safe)
  // LinkedBlockingQueue 是最適合生產者-消費者模式的結構
  private final BlockingQueue<PlayerRecord> saveQueue = new LinkedBlockingQueue<>();

  // 控制迴圈的旗標
  private volatile boolean running = true;

  /**
   * 【對外 API】非同步存檔 Actor 呼叫這個方法時，幾乎是瞬間完成的。
   */
  public void saveAsync(PlayerRecord record) {
    if (record == null)
      return;

    // 丟入佇列，如果不滿就立刻返回，不會阻塞
    if (!saveQueue.offer(record)) {
      log.error("存檔佇列已滿！可能資料庫寫入過慢，資料遺失風險: {}", record.id());
    }
  }

  /**
   * 2. 啟動背景消費者執行緒 使用 @PostConstruct 在 Bean 建立後自動執行
   */
  @PostConstruct
  public void init() {
    // 啟動一個虛擬執行緒來專門處理存檔
    Thread.ofVirtual().name("db-writer-player").start(this::processQueue);
  }

  /**
   * 3. 消費者迴圈 (批次寫入邏輯)
   */
  private void processQueue() {
    log.info("Write-Behind DB Writer started.");

    // 用來暫存批次資料的 List
    List<PlayerRecord> batch = new ArrayList<>();

    while (running) {
      try {
        // A. 從佇列取出一筆 (如果空的，這裡會阻塞等待，節省 CPU)
        // 使用 poll 設定超時，這樣我們可以定期檢查 running 狀態或處理剩餘批次
        PlayerRecord record = saveQueue.poll(1, java.util.concurrent.TimeUnit.SECONDS);

        if (record != null) {
          batch.add(record);
        }

        // B. 檢查是否需要寫入 DB (滿足數量 或 佇列沒東西了但還有殘存資料)
        // 條件：累積滿 50 筆 OR (佇列空了 且 手上還有資料)
        if (batch.size() >= 50 || (record == null && !batch.isEmpty())) {
          flushBatch(batch);
        }

        // C. 額外優化：如果佇列裡還有很多，一口氣全部撈出來 (Drain)
        // 這能大幅提升高負載時的吞吐量
        if (!saveQueue.isEmpty() && batch.size() < 100) {
          saveQueue.drainTo(batch, 100 - batch.size());
          flushBatch(batch); // 再寫一次
        }

      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("DB Writer thread interrupted.");
        break;
      } catch (Exception e) {
        log.error("DB Writer loop error", e);
      }
    }
  }

  /**
   * 4. 實際寫入資料庫
   */
  private void flushBatch(List<PlayerRecord> batch) {
    if (batch.isEmpty())
      return;

    // 使用 Map 來去重，只保留每個 Room 的最新狀態
    Map<String, PlayerRecord> latestRecords = new HashMap<>();
    for (PlayerRecord rec : batch) {
      latestRecords.put(rec.id(), rec);
    }

    // 只寫入去重後的資料
    for (PlayerRecord rec : latestRecords.values()) {
      // 直接用 CharacterRepo 查 (查出來的物件本來就沒有密碼)
      playerRepository.findById(rec.id()).ifPresent(entity -> {

        // Record -> Entity (MapStruct 自動更新)
        // 這行程式碼取代了原本手寫的 entity.setNickname(), entity.setState()...
        mapper.updateEntityFromRecord(rec, entity);

        // 存檔
        playerRepository.save(entity);
      });
    }
  }

  /**
   * 5. 優雅關機 (Graceful Shutdown) 當 Spring Boot 關閉時，確保佇列裡的資料都寫完
   */
  @PreDestroy
  public void shutdown() {
    log.info("Shutting down PersistenceService...");
    running = false; // 停止迴圈讀取

    // 把佇列中剩下的全部寫完
    List<PlayerRecord> remaining = new ArrayList<>();
    saveQueue.drainTo(remaining);

    if (!remaining.isEmpty()) {
      log.info("Flushing remaining {} records...", remaining.size());
      flushBatch(remaining);
    }

    log.info("PersistenceService shutdown complete.");
  }
}


--- File: RoomPersistenceService.java ---

package com.example.htmlmud.infra.persistence.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.springframework.stereotype.Service;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.infra.persistence.repository.RoomStateRepository;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoomPersistenceService {

  private final RoomStateRepository roomRepository;

  // 1. 緩衝佇列 (Thread-Safe)
  // LinkedBlockingQueue 是最適合生產者-消費者模式的結構
  private final BlockingQueue<RoomStateRecord> saveQueue = new LinkedBlockingQueue<>();

  // 控制迴圈的旗標
  private volatile boolean running = true;


  /**
   * 【對外 API】非同步存檔 Actor 呼叫這個方法時，幾乎是瞬間完成的。
   */
  public void saveAsync(RoomStateRecord record) {
    if (record == null)
      return;

    // 丟入佇列，如果不滿就立刻返回，不會阻塞
    if (!saveQueue.offer(record)) {
      log.error("存檔佇列已滿！可能資料庫寫入過慢，資料遺失風險: roomId:{} zoneId:{}", record.roomId(), record.zoneId());
    }
  }


  /**
   * 2. 啟動背景消費者執行緒 使用 @PostConstruct 在 Bean 建立後自動執行
   */
  @PostConstruct
  public void init() {
    // 啟動一個虛擬執行緒來專門處理存檔
    Thread.ofVirtual().name("db-writer-room").start(this::processQueue);
  }

  /**
   * 3. 消費者迴圈 (批次寫入邏輯)
   */
  private void processQueue() {
    log.info("Write-Behind DB Writer Room started.");

    // 用來暫存批次資料的 List
    List<RoomStateRecord> batch = new ArrayList<>();

    while (running) {
      try {
        // A. 從佇列取出一筆 (如果空的，這裡會阻塞等待，節省 CPU)
        // 使用 poll 設定超時，這樣我們可以定期檢查 running 狀態或處理剩餘批次
        RoomStateRecord record = saveQueue.poll(1, java.util.concurrent.TimeUnit.SECONDS);

        if (record != null) {
          batch.add(record);
        }

        // B. 檢查是否需要寫入 DB (滿足數量 或 佇列沒東西了但還有殘存資料)
        // 條件：累積滿 50 筆 OR (佇列空了 且 手上還有資料)
        if (batch.size() >= 50 || (record == null && !batch.isEmpty())) {
          flushBatch(batch);
        }

        // C. 額外優化：如果佇列裡還有很多，一口氣全部撈出來 (Drain)
        // 這能大幅提升高負載時的吞吐量
        if (!saveQueue.isEmpty() && batch.size() < 100) {
          saveQueue.drainTo(batch, 100 - batch.size());
          flushBatch(batch); // 再寫一次
        }

      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("DB Writer thread interrupted.");
        break;
      } catch (Exception e) {
        log.error("DB Writer loop error", e);
      }
    }
  }

  /**
   * 4. 實際寫入資料庫
   */
  private void flushBatch(List<RoomStateRecord> batch) {
    if (batch.isEmpty())
      return;

    // 使用 Map 來去重，只保留每個 Room 的最新狀態
    Map<String, RoomStateRecord> latestRecords = new HashMap<>();
    for (RoomStateRecord rec : batch) {
      // key 可以是 roomId + zoneId
      String key = rec.zoneId() + ":" + rec.roomId();
      latestRecords.put(key, rec);
    }

    // 只寫入去重後的資料
    for (RoomStateRecord rec : latestRecords.values()) {
      // 直接用 CharacterRepo 查 (查出來的物件本來就沒有密碼)
      roomRepository.findByRoomIdAndZoneId(rec.roomId(), rec.zoneId()).ifPresent(entity -> {

        // entity.setId(rec.id());
        // entity.setDroppedItems(rec.items());
        // entity.setItems(rec.items());

        // 存檔
        roomRepository.save(entity);
      });
    }
  }

  /**
   * 5. 優雅關機 (Graceful Shutdown) 當 Spring Boot 關閉時，確保佇列裡的資料都寫完
   */
  @PreDestroy
  public void shutdown() {
    log.info("Shutting down PersistenceService...");
    running = false; // 停止迴圈讀取

    // 把佇列中剩下的全部寫完
    List<RoomStateRecord> remaining = new ArrayList<>();
    saveQueue.drainTo(remaining);

    if (!remaining.isEmpty()) {
      log.info("Flushing remaining {} records...", remaining.size());
      flushBatch(remaining);
    }

    log.info("PersistenceService shutdown complete.");
  }

}


--- File: MudWebSocketHandler.java ---

package com.example.htmlmud.infra.server;

import java.util.UUID;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class MudWebSocketHandler extends TextWebSocketHandler {
  private final GameServices gameServices;
  private final WorldManager worldManager;
  private final SessionRegistry sessionRegistry;

  @Override
  public void afterConnectionEstablished(WebSocketSession session) {
    // 包裝 Session
    // 這會自動加上 Lock，確保同時寫入時會排隊，不會噴出 IllegalStateException
    // 參數說明：session, sendTimeLimit(ms), bufferSizeLimit(bytes)
    WebSocketSession concurrentSession =
        new ConcurrentWebSocketSessionDecorator(session, 1000, 64 * 1024);

    try {

      // Guest階段 使用工廠方法建立 Guest Actor (ID=0)
      // 將必要的 Service 注入給 Actor，讓 Actor 擁有處理業務的能力
      PlayerActor actor = PlayerActor.createGuest(concurrentSession, worldManager, gameServices);

      // 啟動 Actor 的虛擬執行緒 (Virtual Thread)
      actor.start();

      // 註冊到網路層 SessionRegistry
      sessionRegistry.register(concurrentSession, actor);

      log.info("連線建立: {} (Guest Actor Created)", concurrentSession.getId());
      // eventPublisher.publishEvent(new SessionEvent.Established(session.getId(), Instant.now()));
    } catch (Exception e) {
      log.error("連線初始化失敗", e);
      try {
        concurrentSession.close();
      } catch (Exception ignored) {
      }
    }
  }

  @Override
  protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {

    // A. 產生 Trace ID (所有 Log 追蹤的源頭)
    // 使用短 UUID 方便閱讀，實務上可用完整的 UUID
    String traceId = UUID.randomUUID().toString().substring(0, 8);

    try {
      PlayerActor actor = sessionRegistry.get(session.getId());
      if (actor != null) {
        // C. 解析指令 (JSON -> Record)
        GameCommand cmd =
            gameServices.objectMapper().readValue(message.getPayload(), GameCommand.class);

        // D. 裝入信封並投遞
        // 這裡不綁定 ScopedValue，因為要跨執行緒傳遞
        actor.send(new ActorMessage.Command(traceId, cmd));
      } else {
        // 找不到 Actor，通常代表連線異常或已被踢除
        log.warn("[{}] 收到訊息但找不到 Actor，關閉連線: {}", traceId, session.getId());
        session.close();
      }
    } catch (Exception e) {
      // JSON 解析失敗或其他錯誤
      log.error("[{}] 訊息處理錯誤: {}", traceId, e.getMessage());
      // 選擇性：回傳錯誤訊息給 Client
    }
  }

  @Override
  public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {

    // 從 Registry 移除並取得 Actor
    PlayerActor actor = sessionRegistry.remove(session.getId());

    if (actor != null) {
      log.info("連線關閉: {} (Actor: {})", session.getId(), actor.getId());

      // 通知 Actor 執行清理邏輯
      // (如果是 Guest 則直接停止，如果是正式玩家則觸發存檔與從 WorldManager 移除)
      actor.handleDisconnect();
    }
  }
}


--- File: SessionRegistry.java ---

package com.example.htmlmud.infra.server;

import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class SessionRegistry {

  private final Map<String, PlayerActor> sessions = new ConcurrentHashMap<>();

  public void register(WebSocketSession session, PlayerActor actor) {
    sessions.put(session.getId(), actor);
  }

  public PlayerActor remove(String sessionId) {
    return sessions.remove(sessionId);
  }

  public PlayerActor get(String sessionId) {
    return sessions.get(sessionId);
  }

  // 額外功能：踢掉某個 Session (例如重複登入踢人)
  // 或是統計當前連線數 (含 Guest)
  public int getConnectionCount() {
    return sessions.size();
  }

}


--- File: WorldInitializer.java ---

package com.example.htmlmud.infra.server;

import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.context.GameServices;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Order(1) // 如果有多個初始化步驟，可以控制順序
@RequiredArgsConstructor
public class WorldInitializer implements ApplicationRunner {

  private final WorldManager worldManager;
  // private final GameLoop gameLoop;


  @Override
  public void run(ApplicationArguments args) throws Exception {
    log.info("=== MUD World Initialization Started ===");

    long start = System.currentTimeMillis();

    // 1. 載入地圖 (從原本 WorldManager 的 @PostConstruct 移過來)
    worldManager.loadWorld();

    // 2. (未來) 啟動全域計時器 (Tick Loop)
    // gameLoop.start();

    // 3. (未來) 載入 NPC 或 排行榜快取

    long duration = System.currentTimeMillis() - start;
    log.info("=== MUD World Ready in {} ms ===", duration);
  }
}


--- File: WorldPulse.java ---

package com.example.htmlmud.infra.server;

import java.util.concurrent.atomic.AtomicLong;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.protocol.RoomMessage;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class WorldPulse {

  private final WorldManager worldManager;

  // 全域計數器，伺服器啟動後開始累加
  private final AtomicLong globalTickCounter = new AtomicLong(0);

  // 設定基礎頻率為 1000ms (1秒)
  // 這是 "戰鬥心跳" 的速度，也是最小單位
  @Scheduled(fixedRate = 5000)
  public void pulse() {
    long currentTick = globalTickCounter.incrementAndGet();
    long now = System.currentTimeMillis();

    // 優化：只對「活躍」的房間發送
    worldManager.getActiveRooms().values().forEach(room -> {

      // Active Room 定義：有玩家在裡面，重生時間，或者有未結束的戰鬥/腳本
      boolean isRespawnTick = (currentTick % room.getZoneTemplate().respawnRate() == 0);
      if (!room.getPlayers().isEmpty() || isRespawnTick
          || room.getMobs().stream().anyMatch(m -> m.getState().isInCombat())) {
        room.send(new RoomMessage.Tick(currentTick, now));
      }
    });

    // 可選：每 60 秒印一次 Log 確保心臟還在跳
    if (currentTick % 60 == 0) {
      log.debug("World Pulse alive. Tick: {}", currentTick);

    }
  }

  // 每 1000 毫秒 (1秒) 執行一次
  // @Scheduled(fixedRate = 1000)
  // public void tick() {
  // // 只針對「有人」或「活躍」的房間進行更新，效能最佳化
  // worldManager.getActiveRooms().values().forEach(room -> {
  // // 使用 Virtual Thread 並行處理每個房間的邏輯
  // Thread.ofVirtual().name("room-tick-" + room.getId()).start(() -> {
  // try {
  // room.tick();
  // } catch (Exception e) {
  // log.error("Room tick error: {}", room.getId(), e);
  // }
  // });
  // });
  // }
}


--- File: AnsiColor.java ---

package com.example.htmlmud.infra.util;

/**
 * ANSI 顏色碼列舉 包含標準色、高亮色、背景色以及 MUD 常用的 256 色擴展
 */
public enum AnsiColor {

  // --- 控制碼 ---
  RESET("\u001B[0m"), BOLD("\u001B[1m"), // 粗體
  DIM("\u001B[2m"), // 弱體
  ITALIC("\u001B[3m"), // 斜體
  UNDERLINE("\u001B[4m"), // 下劃線
  BLINK("\u001B[5m"), // 閃爍
  INVERSE("\u001B[7m"), // 反白
  HIDDEN("\u001B[8m"), // 隱藏
  STRIKETHROUGH("\u001B[9m"), // 刪除線

  // --- 標準前景色 (Standard Foreground) ---
  BLACK("\u001B[30m"), // 常用於深灰
  RED("\u001B[31m"), // 常用於紅色
  GREEN("\u001B[32m"), // 常用於綠色
  YELLOW("\u001B[33m"), // 常用於黃色
  BLUE("\u001B[34m"), // 常用於藍色
  MAGENTA("\u001B[35m"), // 常用於紫紅色
  CYAN("\u001B[36m"), // 常用於青色
  WHITE("\u001B[37m"), // 常用於白色

  // --- 高亮前景色 (Bright Foreground) ---
  BRIGHT_BLACK("\u001B[90m"), // 常用於高亮深灰
  BRIGHT_RED("\u001B[91m"), // 常用於高亮紅色
  BRIGHT_GREEN("\u001B[92m"), // 常用於高亮綠色
  BRIGHT_YELLOW("\u001B[93m"), // 常用於高亮黃色
  BRIGHT_BLUE("\u001B[94m"), // 常用於高亮藍色
  BRIGHT_MAGENTA("\u001B[95m"), // 常用於高亮紫紅色
  BRIGHT_CYAN("\u001B[96m"), // 常用於高亮青色
  BRIGHT_WHITE("\u001B[97m"), // 常用於高亮白色

  // --- MUD 特選 256 色 (Extended Colors) ---
  // 裝備與物品常用色
  ORANGE("\u001B[38;5;208m"), // 傳說物品
  GOLD("\u001B[38;5;220m"), // 金幣、神器
  SILVER("\u001B[38;5;250m"), // 銀幣、金屬
  BRONZE("\u001B[38;5;136m"), // 銅幣
  PINK("\u001B[38;5;205m"), // 特殊/女性角色
  PURPLE("\u001B[38;5;129m"), // 史詩物品

  // 元素與環境常用色
  LAVA_RED("\u001B[38;5;196m"), // 熔岩、致命傷害
  ICE_BLUE("\u001B[38;5;51m"), // 冰凍、魔法
  NATURE_GREEN("\u001B[38;5;46m"), // 劇毒、治療
  DARK_GREY("\u001B[38;5;236m"), // 陰影、潛形
  LIGHT_GREY("\u001B[38;5;244m"), // 石頭、牆壁
  BROWN("\u001B[38;5;94m"), // 木頭、泥土

  // --- 背景色 (Background) ---
  BG_BLACK("\u001B[40m"), // 常用於背景色深灰
  BG_RED("\u001B[41m"), // 常用於背景色紅色
  BG_GREEN("\u001B[42m"), // 常用於背景色綠色
  BG_YELLOW("\u001B[43m"), // 常用於背景色黃色
  BG_BLUE("\u001B[44m"), // 常用於背景色藍色
  BG_MAGENTA("\u001B[45m"), // 常用於背景色紫紅色
  BG_CYAN("\u001B[46m"), // 常用於背景色青色
  BG_WHITE("\u001B[47m"); // 常用於背景色白色

  private final String code;

  AnsiColor(String code) {
    this.code = code;
  }

  @Override
  public String toString() {
    return code;
  }

  public String getCode() {
    return code;
  }
}


--- File: ColorText.java ---

package com.example.htmlmud.infra.util;

public class ColorText {

  // 1. 基礎包裝方法
  public static String wrap(AnsiColor color, String text) {
    return color + text + AnsiColor.RESET;
  }

  // 2. 複合樣式 (例如：粗體紅色)
  public static String wrap(AnsiColor color, AnsiColor style, String text) {
    return style + "" + color + text + AnsiColor.RESET;
  }

  // --- 語義化 Helper Methods (MUD 專用) ---

  // 系統訊息 (青色)
  public static String system(String text) {
    return wrap(AnsiColor.CYAN, text);
  }

  // 錯誤訊息 (紅色)
  public static String error(String text) {
    return wrap(AnsiColor.RED, text);
  }

  // 警告訊息 (黃色)
  public static String warn(String text) {
    return wrap(AnsiColor.YELLOW, text);
  }

  // NPC 名稱 (綠色)
  public static String npc(String name) {
    return wrap(AnsiColor.GREEN, name);
  }

  // 怪物名稱 (紅色粗體)
  public static String mob(String name) {
    return wrap(AnsiColor.RED, AnsiColor.BOLD, name);
  }

  // 玩家名稱 (亮藍色)
  public static String player(String name) {
    return wrap(AnsiColor.BRIGHT_BLUE, name);
  }

  // 物品 (金色)
  public static String item(String name) {
    return wrap(AnsiColor.GOLD, name);
  }

  // 傷害數值 (熔岩紅)
  public static String damage(int dmg) {
    return wrap(AnsiColor.LAVA_RED, String.valueOf(dmg));
  }

  // 治療數值 (自然綠)
  public static String heal(int amount) {
    return wrap(AnsiColor.NATURE_GREEN, String.valueOf(amount));
  }

  // 房間名稱 (亮白色)
  public static String room(String name) {
    return wrap(AnsiColor.BRIGHT_WHITE, name);
  }

  // 房間描述 (預設色/灰色)
  public static String roomDesc(String desc) {
    return wrap(AnsiColor.LIGHT_GREY, desc);
  }

  // 出口名稱 (黃色)
  public static String exit(String name) {
    return wrap(AnsiColor.YELLOW, name);
  }

  // 物品描述 (白色)
  public static String itemDesc(String desc) {
    return wrap(AnsiColor.WHITE, desc);
  }

  // 物品稀有度 (紫色)
  public static String rarity(String rarity) {
    return wrap(AnsiColor.PURPLE, rarity);
  }
}


--- File: IdUtils.java ---

package com.example.htmlmud.infra.util;

public class IdUtils {

  /**
   * 解析 ID：將相對 ID 轉為絕對 ID * @param currentZoneId 當前所在的區域 ID (e.g., "newbie_village")
   * 
   * @param rawId 原始 ID (可能是 "square" 或 "dark_forest:clearing")
   * @return 完整的絕對 ID
   */
  public static String resolveId(String currentZoneId, String rawId) {
    if (rawId == null || rawId.isBlank()) {
      return null;
    }
    // 如果已經有冒號，就回傳原始值；否則加上前綴
    if (rawId.contains(":")) {
      return rawId;
    }
    return currentZoneId + ":" + rawId;
  }
}


--- File: ActorMessage.java ---

package com.example.htmlmud.protocol;

import java.util.concurrent.CompletableFuture;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.model.EquipmentSlot;
import com.example.htmlmud.domain.model.GameItem;

public sealed interface ActorMessage
    permits ActorMessage.Tick, ActorMessage.Command, ActorMessage.Die, ActorMessage.SendText,
    ActorMessage.OnAttacked, ActorMessage.Equip, ActorMessage.Unequip {

  /**
   * 心跳訊息
   *
   * @param tickCount 全域累計的 Tick 次數 (用來取餘數判斷頻率)
   * @param timestamp 當前時間戳
   */
  record Tick(long tickCount, long timestamp) implements ActorMessage {
  }

  record Command(String traceId, GameCommand command) implements ActorMessage {
  }

  record Die(String killerId) implements ActorMessage {
  }

  record SendText(WebSocketSession session, String content) implements ActorMessage {
  }

  record OnAttacked(LivingActor actor) implements ActorMessage {
  }

  record Equip(GameItem item, CompletableFuture<String> future) implements ActorMessage {
  }

  record Unequip(EquipmentSlot slot, CompletableFuture<String> future) implements ActorMessage {
  }

}


--- File: ConnectionState.java ---

package com.example.htmlmud.protocol;

public enum ConnectionState {
  CONNECTED, // 剛連線：等待輸入帳號 或 'new'
  ENTERING_PASSWORD, // 已輸入帳號，等待密碼
  CREATING_USERNAME, // 正在輸入新帳號名稱
  CREATING_PASSWORD, // 正在設定新密碼
  ENTERING_CHAR_NAME, // 正在輸入新角色名稱
  ENTERING_CHAR_GENDER, // 正在選擇性別
  ENTERING_CHAR_RACE, // 正在選擇種族
  ENTERING_CHAR_CLASS, // 正在選擇職業
  ENTERING_CHAR_ATTRIBUTES, // 正在選擇等級
  IN_GAME // 遊戲中：正常遊玩
}


--- File: GameCommand.java ---

package com.example.htmlmud.protocol;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

// 定義外部傳來的 JSON 指令
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonSubTypes({
    // @JsonSubTypes.Type(value = GameCommand.Login.class, name = "LOGIN"),
    // @JsonSubTypes.Type(value = GameCommand.Move.class, name = "MOVE"),
    // @JsonSubTypes.Type(value = GameCommand.Chat.class, name = "CHAT"),
    @JsonSubTypes.Type(value = GameCommand.Input.class, name = "INPUT") // <--- 您的核心需求
})
public sealed interface GameCommand {
  // 1. 登入指令 (維持結構化，因為安全性)
  // record Login(String username, String password) implements GameCommand {
  // }
  // 2. 通用字串指令 (您的 MVP 核心)
  // 玩家輸入 "kill goblin", "look", "north" 全部都包在這裡面
  record Input(String text) implements GameCommand {
  }
  // record Move(String direction) implements GameCommand {}
  // record Chat(String content) implements GameCommand {}
}


--- File: RoomMessage.java ---

package com.example.htmlmud.protocol;

import java.util.concurrent.CompletableFuture;
import com.example.htmlmud.domain.actor.impl.LivingActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.GameItem;

/**
 * 定義所有發送給 RoomActor 的內部訊息協定 使用 Sealed Interface 限制訊息類型，配合 switch pattern matching
 */
public sealed interface RoomMessage permits RoomMessage.Enter, RoomMessage.Leave,
    RoomMessage.TryPickItem, RoomMessage.Look, RoomMessage.Say, RoomMessage.Tick,
    RoomMessage.Broadcast, RoomMessage.BroadcastToOthers, RoomMessage.FindActor {

  record Tick(long tickCount, long timestamp) implements RoomMessage {
  }

  /**
   * LivingActor進入房間
   *
   * @param LivingActor 實例
   * @param future 用於通知移動完成 (可選)
   */
  record Enter(LivingActor actor, CompletableFuture<Void> future) implements RoomMessage {
  }

  /**
   * LivingActor離開房間
   *
   * @param actorId 離開的 Actor ID
   */
  record Leave(String actorId) implements RoomMessage {
  }

  /**
   * 查看房間 (Look 指令)
   *
   * @param playerId 發出指令的玩家 ID (用於過濾"自己看到自己")
   * @param result 用於回傳房間描述字串
   */
  record Look(String playerId, CompletableFuture<String> result) implements RoomMessage {
  }

  /**
   * 說話/廣播
   *
   * @param sourcePlayerId 說話者 ID
   * @param content 內容
   */
  record Say(String sourcePlayerId, String content) implements RoomMessage {
  }

  record TryPickItem(String itemId, PlayerActor picker, CompletableFuture<GameItem> future)
      implements RoomMessage {
  }

  record Broadcast(String message) implements RoomMessage {
  }

  record BroadcastToOthers(String sourceId, String message) implements RoomMessage {
  }

  record FindActor(String actorId, CompletableFuture<LivingActor> future) implements RoomMessage {
  }

}


--- File: HtmlmudApplicationTests.java ---

package com.example.htmlmud;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HtmlmudApplicationTests {

	@Test
	void contextLoads() {
	}

}
