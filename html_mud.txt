

--- File: HtmlmudApplication.java ---

package com.example.htmlmud;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HtmlmudApplication {

	public static void main(String[] args) {
		SpringApplication.run(HtmlmudApplication.class, args);
	}

}


--- File: CommandDispatcher.java ---

package com.example.htmlmud.application.command;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.impl.MoveCommand;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.logic.command.annotation.CommandAlias;
import com.example.htmlmud.domain.model.Direction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class CommandDispatcher {

  // 指令註冊表: "look" -> LookCommand Object
  private final Map<String, PlayerCommand> commandMap = new HashMap<>();

  // Spring 會自動注入所有實作 PlayerCommand 的 Bean (LookCommand, MoveCommand...)
  public CommandDispatcher(List<PlayerCommand> commands) {
    for (PlayerCommand cmd : commands) {
      // 1. 註冊主鍵 (例如 "look", "move")
      register(cmd.getKey(), cmd);

      // 2. 【核心修改】檢查是否有 Alias 註解
      if (cmd.getClass().isAnnotationPresent(CommandAlias.class)) {
        CommandAlias annotation = cmd.getClass().getAnnotation(CommandAlias.class);

        // 3. 註冊所有別名
        for (String alias : annotation.value()) {
          register(alias, cmd);
        }
      }

      // 額外處理 MoveCommand 的方向縮寫 (因為這不是單純的別名，還涉及參數轉換)
      // 建議還是保留在程式碼裡特殊處理，或者用另一種 @DirectionAlias 處理
      registerDirectionAliases(commands);
    }
  }

  private void register(String key, PlayerCommand cmd) {
    commandMap.put(key.toLowerCase(), cmd);
  }

  // 處理方向鍵 (n, s, e, w)
  private void registerDirectionAliases(List<PlayerCommand> commands) {
    // 找到 MoveCommand
    PlayerCommand moveCmd =
        commands.stream().filter(c -> c.getKey().equals("move")).findFirst().orElse(null);

    if (moveCmd != null) {
      for (Direction d : Direction.values()) {
        register(d.getShortName(), moveCmd); // n, s, e, w
        register(d.getFullName(), moveCmd); // north, south...
      }
    }
  }

  /**
   * 核心派發邏輯
   *
   * @param input 玩家輸入的原始字串，例如 "look north" 或 "kill goblin"
   */
  public void dispatch(PlayerActor actor, String input) {
    if (input == null || input.isBlank())
      return;

    // 1. 切割字串： "kill goblin" -> key="kill", args="goblin"
    String[] parts = input.trim().split("\\s+", 2); // 只切成兩份
    String key = parts[0].toLowerCase();
    String args = parts.length > 1 ? parts[1] : "";

    log.info("key:{}, args:{}", key, args);
    // 2. 查找指令
    PlayerCommand command = commandMap.get(key);

    if (command != null) {
      // 【關鍵修正】
      // 如果玩家輸入的是 "n"，我們需要把 "n" 當作參數傳給 MoveCommand
      // 或者是 MoveCommand 內部 logic 要知道 "n" 等於 "move n"
      if (command instanceof MoveCommand && Direction.parse(key) != null) {
        // 如果指令本身就是方向 (例如輸入 "n")，把 key 當作 args 傳進去
        command.execute(actor, key);
      } else {
        // 否則正常執行 (例如 "move north")
        command.execute(actor, args);
      }
    } else {
      // 4. 找不到指令的預設處理
      actor.reply("我不懂 '" + key + "' 是什麼意思。輸入 'help' 查看指令列表。");
    }
  }
}


--- File: PlayerCommand.java ---

package com.example.htmlmud.application.command;

import com.example.htmlmud.domain.actor.impl.PlayerActor;

public interface PlayerCommand {

  // 該指令的觸發關鍵字，例如 "look", "l"
  String getKey();

  // 執行邏輯
  // actor: 誰發出的指令 (操作者 Context)
  // args: 指令參數 (例如 'look north' 的 'north')
  void execute(PlayerActor actor, String args);

  // 描述 (給 help 指令用)
  default String getDescription() {
    return "無描述";
  }
}


--- File: GetCommand.java ---

package com.example.htmlmud.application.command.impl;

import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.logic.command.annotation.CommandAlias;
import com.example.htmlmud.protocol.RoomMessage;
import lombok.RequiredArgsConstructor;

@Component
@CommandAlias("get")
@RequiredArgsConstructor
public class GetCommand implements PlayerCommand {

  @Override
  public String getKey() {
    return "get";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 1. 基本檢查
    if (args.isEmpty()) {
      actor.reply("你要撿什麼？");
      return;
    }

    // 2. 找到房間 Actor
    String roomId = actor.getCurrentRoomId();
    RoomActor room = actor.getManager().getRoomActor(roomId);

    // 3. 發送請求 (這是非同步的)
    // 注意：這裡有兩種做法
    // 方法 A: 發後不理 (Fire-and-Forget)，結果由 ActorMessage 回傳處理
    // 方法 B: 使用 CompletableFuture 等待結果 (較直觀，但在 Actor 模型中要小心死鎖)

    // 這裡示範更符合 Actor 精神的 "Ask Pattern" (或是透過回呼)
    // 為了簡單起見，我們假設 RoomActor 有一個同步的安全方法 (如果都在同一台機器)
    // 或者發送一個 "AttemptPick" 訊息

    room.send(new RoomMessage.TryPickItem(args, actor));
  }
}


--- File: KillCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.List;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.application.command.parser.TargetSelector;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.logic.command.annotation.CommandAlias;
import lombok.RequiredArgsConstructor;

@Component
@CommandAlias("k")
@RequiredArgsConstructor
public class KillCommand implements PlayerCommand {

  private final TargetSelector targetSelector; // 注入工具

  @Override
  public String getKey() {
    return "kill";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    if (args.isBlank()) {
      actor.reply("你要攻擊誰？");
      return;
    }

    // 1. 取得房間內的怪物列表
    RoomActor room = actor.getManager().getRoomActor(actor.getCurrentRoomId());
    // 這裡假設 room 有 getMobsSnapshot() 回傳 List<MobActor>
    // 注意：為了線程安全，這裡最好是 Snapshot 或是能確保讀取安全的列表
    List<MobActor> mobsInRoom = room.getMobsSnapshot();

    // 2. 交給 Selector 處理複雜字串
    // args 可能是 "red goblin", "elite soldier 2"
    MobActor target = targetSelector.selectMob(mobsInRoom, args);

    if (target == null) {
      actor.reply("這裡沒有看到 '" + args + "'。");
      return;
    }

    // 3. 執行戰鬥邏輯
    actor.reply("你開始攻擊 " + target.getTemplate().name() + "！");
    target.onAttacked(actor, 10);
  }
}


--- File: LookCommand.java ---

package com.example.htmlmud.application.command.impl;

import java.util.List;
import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.logic.command.annotation.CommandAlias;
import com.example.htmlmud.domain.model.MobKind;
import com.example.htmlmud.infra.util.AnsiColor;
import com.example.htmlmud.infra.util.ColorText;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component // 註冊為 Spring Bean
@RequiredArgsConstructor
@CommandAlias({"l", "see", "ls"}) // 支援 l, see, ls
public class LookCommand implements PlayerCommand {

  @Override
  public String getKey() {
    return "look";
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 1. 取得玩家當前位置 ID
    String roomId = actor.getCurrentRoomId();

    log.info("args:{}", args);

    // 2. 查詢房間資料 (使用 WorldManager)
    RoomActor roomActor = actor.getManager().getRoomActor(roomId);

    if (roomActor == null) {
      actor.reply("你處於一片虛空之中... (RoomID: " + roomId + " 不存在)");
      return;
    }

    // 3. 產生房間描述
    String roomDescription = buildRoomDescription(actor, roomActor);



    // 4. 回傳給玩家
    actor.reply(roomDescription);
  }

  private String buildRoomDescription(PlayerActor actor, RoomActor room) {
    StringBuilder sb = new StringBuilder();

    // 標題 (亮白色)
    sb.append(ColorText.room("=== " + room.getTemplate().name() + " ===")).append("\r\n");

    // 描述 (預設色/灰色)
    sb.append(ColorText.roomDesc(room.getTemplate().description())).append("\r\n");

    // 出口 (黃色)
    sb.append(ColorText.exit("[出口]: "));
    if (room.getTemplate().exits().isEmpty()) {
      sb.append("無");
    } else {
      sb.append(String.join(", ", room.getTemplate().exits().keySet()));
    }
    sb.append("\r\n");

    // 取得房間內的生物 (玩家與怪物，經過排序)
    List<PlayerActor> players = room.getPlayersSnapshot();
    List<MobActor> mobs = room.getMobsSnapshot();
    log.info("players: {}, mobs: {}", players.size(), mobs.size());


    // 1. 篩選出 其他玩家 (亮藍色，排除自己)
    List<String> otherPlayerNames = players.stream().filter(p -> !p.getId().equals(actor.getId()))
        .map(p -> ColorText.player(p.getNickname() + "(" + p.getName() + ")")).toList();

    // 2. 篩選出 NPC (綠色顯示)
    List<String> npcNames = mobs.stream().filter(m -> m.getTemplate().kind() == MobKind.FRIENDLY)
        .map(m -> ColorText.npc(m.getTemplate().name() + "(" + m.getTemplate().aliases()[0] + ")"))
        .toList();

    // 3. 篩選出 怪物 (紅色顯示)
    List<String> monsterNames = mobs.stream().filter(
        m -> m.getTemplate().kind() == MobKind.AGGRESSIVE || m.getTemplate().kind() == MobKind.BOSS)
        .map(m -> ColorText.mob(m.getTemplate().name() + "(" + m.getTemplate().aliases()[0] + ")")) // 紅色代表危險
        .toList();

    if (!otherPlayerNames.isEmpty()) {
      sb.append(ColorText.wrap(AnsiColor.BRIGHT_MAGENTA, "[玩家]: "))
          .append(String.join(", ", otherPlayerNames)).append("\r\n");
    }
    if (!npcNames.isEmpty()) {
      sb.append(ColorText.npc("[人物]: ")).append(String.join(", ", npcNames)).append("\r\n");
    }
    if (!monsterNames.isEmpty()) {
      sb.append(ColorText.wrap(AnsiColor.RED, "[怪物]: ")).append(String.join(", ", monsterNames))
          .append("\r\n");
    }

    return sb.toString();
  }
}


--- File: MoveCommand.java ---

package com.example.htmlmud.application.command.impl;

import org.springframework.stereotype.Component;
import com.example.htmlmud.application.command.PlayerCommand;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.model.Direction;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.example.htmlmud.infra.util.AnsiColor;
import com.example.htmlmud.infra.util.ColorText;
import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class MoveCommand implements PlayerCommand {

  @Override
  public String getKey() {
    return "move"; // 主鍵是 move，但我們會註冊 alias (n, s, e, w)
  }

  @Override
  public void execute(PlayerActor actor, String args) {
    // 1. 解析方向
    // 玩家可能輸入 "move north" 或者直接輸入 "north" (由 Dispatcher 轉發)
    Direction dir = Direction.parse(args);

    if (dir == null) {
      actor.reply("你要往哪個方向移動？");
      return;
    }

    // 2. 取得當前房間
    String currentRoomId = actor.getCurrentRoomId();
    RoomActor currentRoom = actor.getManager().getRoomActor(currentRoomId);

    if (currentRoom == null) {
      actor.reply("你在一片虛空中，無法移動。");
      return;
    }

    // 3. 檢查出口
    // 假設 Room.exits 是 Map<String, Integer> (key 是 direction full name)
    // Integer nextRoomId = currentRoom.getTemplate().exits().get(dir.getFullName());
    RoomExit exit = currentRoom.getTemplate().exits().get(dir.getFullName());


    if (exit == null) {
      actor.reply("往 " + dir.getDisplayName() + " 沒有出路。");
      return;
    }

    // 檢查要去的房間是否存在
    String targetRoomId = exit.targetRoomId();
    RoomActor targetRoom = actor.getManager().getRoomActor(targetRoomId);

    if (targetRoom == null) {
      actor.reply("前方房間 " + targetRoomId + " 施工中，無法前往。");
      return;
    }


    // --- 移動成功，開始處理流程 ---

    // 4. 舊房間廣播 (離場)
    String leaveMsg = ColorText.wrap(AnsiColor.YELLOW,
        actor.getNickname() + " 往 " + dir.getDisplayName() + " 離開了。");
    actor.getManager().broadcastToRoom(currentRoomId, leaveMsg, actor.getId());

    // 5. 更新玩家位置
    // 注意：這裡只改記憶體，State Pattern + Write-Behind 會負責存檔
    // String targetRoomId = exit.targetRoomId();
    actor.setCurrentRoomId(targetRoomId);

    // 6. 新房間廣播 (進場)
    // 計算反方向 (例如往北走，新房間的人會看到你從南方來)
    String arriveMsg = ColorText.wrap(AnsiColor.YELLOW,
        actor.getNickname() + " 從 " + dir.opposite().getDisplayName() + " 過來了。");
    actor.getManager().broadcastToRoom(targetRoomId, arriveMsg, actor.getId());

    // 7. 自動 Look (讓玩家看到新環境)
    // 直接調用 Dispatcher 執行 look 指令
    actor.getServices().commandDispatcher().dispatch(actor, "look");
  }
}


--- File: TargetSelector.java ---

package com.example.htmlmud.application.command.parser;

import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.model.map.MobTemplate;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class TargetSelector {

  // 用來解析 "name index" (例如: goblin 2)
  private static final Pattern TRAILING_NUMBER = Pattern.compile("^(.*)\\s+(\\d+)$");

  // 用來解析 "index.name" (例如: 2.goblin)
  private static final Pattern DOT_NOTATION = Pattern.compile("^(\\d+)\\.(.*)$");

  /**
   * 從列表中找到符合描述的目標
   *
   * @param candidates 房間裡的所有怪物 (或物品)
   * @param input 玩家輸入的字串 (例如 "elite soldier 3")
   * @return 找到的 Mob，若無則回傳 null
   */
  public MobActor selectMob(List<MobActor> candidates, String input) {
    if (input == null || input.isBlank())
      return null;

    // 1. 解析輸入，分離出 "名稱關鍵字" 和 "第幾個"
    ParsedTarget parsed = parseInput(input);
    String keyword = parsed.name.toLowerCase();
    int targetIndex = parsed.index; // 1-based index

    int matchCount = 0;

    // 2. 遍歷候選名單
    for (MobActor mob : candidates) {
      // 3. 檢查是否匹配
      if (isMatch(mob, keyword)) {
        matchCount++;
        // 4. 如果匹配次數等於玩家指定的索引，就是它了
        if (matchCount == targetIndex) {
          return mob;
        }
      }
    }

    return null; // 找不到
  }

  private boolean isMatch(MobActor mob, String keyword) {
    MobTemplate tpl = mob.getTemplate();

    // 規則 A: 直接比對 Name (忽略大小寫)
    if (tpl.name().toLowerCase().contains(keyword))
      return true;

    // 規則 B: 比對 Aliases
    // 只要 Alias 列表裡有任何一個字串 "包含" 玩家輸入的關鍵字
    // 例如 alias=["red goblin king"], input="red goblin" -> true
    // 例如 alias=["goblin"], input="red" -> false
    if (tpl.aliases() != null) {
      for (String alias : tpl.aliases()) {
        if (alias.toLowerCase().contains(keyword)) {
          return true;
        }
      }
    }
    return false;
  }

  // --- 解析邏輯 ---

  private record ParsedTarget(String name, int index) {
  }

  private ParsedTarget parseInput(String input) {
    input = input.trim();

    // 檢查 "2.goblin" 格式
    Matcher dotMatcher = DOT_NOTATION.matcher(input);
    if (dotMatcher.find()) {
      int idx = Integer.parseInt(dotMatcher.group(1));
      String name = dotMatcher.group(2);
      return new ParsedTarget(name, idx);
    }

    // 檢查 "goblin 2" 格式
    Matcher trailMatcher = TRAILING_NUMBER.matcher(input);
    if (trailMatcher.find()) {
      String name = trailMatcher.group(1);
      int idx = Integer.parseInt(trailMatcher.group(2));
      return new ParsedTarget(name, idx);
    }

    // 預設: 找第 1 個
    return new ParsedTarget(input, 1);
  }
}


--- File: WorldFactory.java ---

package com.example.htmlmud.application.factory;

import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.stereotype.Service;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.infra.persistence.repository.TemplateRepository;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class WorldFactory {

  private final ObjectProvider<WorldManager> managerProvider;

  private final ObjectProvider<GameServices> servicesProvider;

  private final TemplateRepository templateRepo;

  /**
   * 建立房間 Actor
   */
  public RoomActor createRoom(String roomId) {
    RoomTemplate roomTpl = templateRepo.findRoom(roomId).orElse(null);
    if (roomTpl == null) {
      log.error("Create Room failed: RoomTemplate not found {}", roomId);
      return null;
    }

    ZoneTemplate zoneTpl = templateRepo.findZone(roomTpl.zoneId()).orElse(null);
    if (zoneTpl == null) {
      log.error("Create Room failed: ZoneTemplate not found {}", roomTpl.zoneId());
      return null;
    }

    // 這裡負責組裝：RoomActor 需要 Template + ZoneTemplate
    return new RoomActor(roomTpl, zoneTpl);
  }

  /**
   * 建立怪物 Actor (包含 AI 啟動邏輯)
   */
  public MobActor createMob(String templateId) {
    // 1. 查 Template (Record)
    MobTemplate tpl = templateRepo.findMob(templateId).orElse(null);
    if (tpl == null) {
      log.error("MobTemplate ID not found: " + templateId);
      return null;
    }

    // 2. new Actor (State 自動生成)
    MobActor mob = new MobActor(tpl, managerProvider.getObject(), servicesProvider.getObject());

    // 3. 這裡可以處理「菁英怪」或「隨機稱號」邏輯
    // if (Math.random() < 0.1) mob.setPrefix("狂暴的");

    // 4. 啟動 AI (重要：Factory 負責讓它動起來，或者由 Manager 統一啟動)
    mob.start();

    return mob;
  }

  /**
   * 建立物品實體 (處理隨機數值)
   */
  public GameItem createItem(String templateId) {
    ItemTemplate tpl = templateRepo.findItem(templateId).orElse(null);
    if (tpl == null) {
      log.error("Create Item failed: Template not found {}", templateId);
      return null;
    }

    GameItem item = new GameItem();
    item.setId(UUID.randomUUID().toString()); // 生成唯一 ID
    item.setTemplateId(tpl.id());
    item.setCurrentDurability(tpl.maxDurability());
    item.setAmount(1);

    // --- 處理隨機屬性 (RNG) ---
    // 這是 Factory 最有價值的地方，不要讓 Manager 變髒
    if (tpl.chance() < 1.0) {
      // 處理掉落率邏輯...
    }

    // 範例：10% 機率出現稀有屬性
    if (ThreadLocalRandom.current().nextDouble() < 0.1) {
      item.getDynamicProps().put("quality", "RARE");
      item.getDynamicProps().put("attack_bonus", 5);
    }

    return item;
  }
}


--- File: AuditLogEventListener.java ---

package com.example.htmlmud.application.listener;

import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.event.DomainEvent;
import com.example.htmlmud.domain.event.MobEvents;
import com.example.htmlmud.domain.event.PlayerEvents;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AuditLogEventListener {
  @Async // <--- 關鍵：丟到另一個 Thread (或 Virtual Thread) 執行
  @EventListener
  public void logPlayerAction(DomainEvent event) {
    // 這裡使用了 switch pattern matching (Java 21+)
    // 可以優雅地處理所有 DomainEvent
    String logMsg = switch (event) {
      case PlayerEvents.LoggedIn e -> "使用者登入: " + e.username() + " IP:" + e.ipAddress();
      case PlayerEvents.LevelUp e -> "玩家升級: " + e.newLevel();
      case MobEvents.MobDead e -> "怪物死亡: " + e.mobId();
      default -> "未知事件: " + event.getClass().getSimpleName();
    };

    // 模擬寫入 DB
    log.info("[AUDIT LOG] " + event.occurredOn() + " - " + logMsg);
  }
}


--- File: PlayerLoginListener.java ---

package com.example.htmlmud.application.listener;

import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.protocol.RoomMessage;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;

import java.util.concurrent.CompletableFuture;

@Slf4j
@Component
@RequiredArgsConstructor
public class PlayerLoginListener {

  private final WorldManager worldManager;

  @Autowired
  private ObjectMapper objectMapper;

  // @EventListener
  // public void onPlayerLogin(PlayerLoginEvent event) {
  // var entity = event.getPlayerEntity();
  // var session = event.getSession();

  // log.info("處理玩家登入事件: {}", entity.getUsername());
  /*
   * try { // 1. 建立 Actor (這裡是 Domain Logic) PlayerActor playerActor = new
   * PlayerActor(entity.getId(), session, entity.state, objectMapper);
   *
   * // 2. 設定上次位置 playerActor.setCurrentRoomId(entity.getCurrentRoomId());
   *
   * // 3. 綁定 Session (讓 WebSocketHandler 知道這個 session 有主人了) session.getAttributes().put("actor",
   * playerActor);
   *
   * // 4. 歡迎訊息 playerActor.sendText("\u001B[32m登入成功！歡迎回到 MUD 世界 (Event Driven)。\u001B[0m");
   *
   * // 5. 進入房間邏輯 var room = worldManager.getRoomActor(playerActor.getCurrentRoomId()); var future =
   * new CompletableFuture<Void>();
   *
   * // 讓玩家進入房間 // room.receive(new RoomMessage.PlayerEnter(playerActor, future));
   *
   * // 進入後自動 Look // future.thenRun(() -> playerActor.send("look"));
   *
   * } catch (Exception e) { log.error("玩家登入後續處理失敗", e); try { session.sendMessage(new
   * TextMessage("系統錯誤：無法進入世界")); } catch (Exception ignored) { } }
   */
  // }
}


--- File: QuestEventListener.java ---

package com.example.htmlmud.application.listener;

import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.event.PlayerEvents;

@Component
public class QuestEventListener {
  @EventListener
  public void checkLevelUpQuest(PlayerEvents.LevelUp event) {
    // 檢查該玩家是否有 "升到 10 級" 的任務
    // if (event.newLevel() >= 10) ...
    System.out.println("任務檢查: 玩家 " + event.playerId() + " 升級了。");
  }
}


--- File: SessionEventListener.java ---

package com.example.htmlmud.application.listener;

import java.io.IOException;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.event.DomainEvent.SessionEvent;
import com.example.htmlmud.infra.server.SessionRegistry;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class SessionEventListener {

  @Autowired
  private ObjectMapper objectMapper;

  @Autowired
  private SessionRegistry sessionRegistry;

  @EventListener
  public void onEstablished(SessionEvent.Established event) throws IOException {
    log.info("系統收到連線建立事件: {}", event.sessionId());

    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());

    // String welcomeMsg = """
    // \u001B[36m
    // ==========================================
    // 歡迎來到 HTML MUD (Java 25 Edition)
    // ==========================================
    // \u001B[0m
    // 請輸入以下指令開始:
    // 1. 註冊: \u001B[33mregister <帳號> <密碼>\u001B[0m
    // 2. 登入: \u001B[33mlogin <帳號> <密碼>\u001B[0m
    // """;
    String welcomeMsg = "歡迎來到 HTML MUD 世界！\r\n請輸入帳號 (或輸入 new 註冊)：";
    if (session != null && session.isOpen()) {
      String json = objectMapper.writeValueAsString(Map.of("type", "TEXT", "content", welcomeMsg));

      session.sendMessage(new TextMessage(json));
    }
  }

  @EventListener
  public void onMessageReceived(SessionEvent.MessageReceived event) {
    System.out.println("onMessageReceived");
  }

  @EventListener
  public void onClosed(SessionEvent.Closed event) {
    log.info("系統收到連線關閉事件: {} CloseStatus:{}", event.sessionId(), event.reason());
  }

}


--- File: SystemEventListener.java ---

package com.example.htmlmud.application.listener;

import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.event.DomainEvent.SystemEvent;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import com.example.htmlmud.infra.server.SessionRegistry;
import com.example.htmlmud.protocol.ConnectionState;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class SystemEventListener {

  private static final int MAX_AUTH_RETRIES = 5;

  // 基礎保留字（非指令類的關鍵字）
  private final Set<String> reservedWords = new HashSet<>(
      Set.of("new", "quit", "exit", "wizard", "admin", "system", "root", "guest", "player"));

  @Autowired
  private ObjectMapper objectMapper;

  @Autowired
  private WorldManager worldManager;

  @Autowired
  private SessionRegistry sessionRegistry;

  @Autowired
  private UserRepository userRepository;



  @EventListener
  public void onRegisterUsername(SystemEvent.RegisterUsername event) throws Exception {
    log.info("onRegisterUsername");
    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();

    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validateUsername(event.input());

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount,
            event.input());
        actor.sendText("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 註冊帳號失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    // actor.setTempUsername(event.input());

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n只能包含英文字母與數字且長度必須在 6 到 32 個字元之間。\r\n請輸入密碼:";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    actor.setConnectionState(ConnectionState.CREATING_PASSWORD);
  }

  @EventListener
  public void onRegisterPassword(SystemEvent.RegisterPassword event) throws IOException {
    log.info("onRegisterPassword");

    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validatePassword(event.input());

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount,
            event.input());
        actor.sendText("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 註冊密碼失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    // actor.setTempPassword(event.input());

    // 新增玩家帳密


    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n註冊完成，請重新登入。";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    actor.sendText(msg);

    actor.setConnectionState(ConnectionState.CONNECTED);
  }

  @EventListener
  public void onLogin(SystemEvent.Login event) {
    log.info("onLogin");
  }

  @EventListener
  public void onAuthenticate(SystemEvent.Authenticate event) throws IOException {
    log.info("onAuthenticate");
    PlayerActor actor = sessionRegistry.get(event.sessionId());
    WebSocketSession session = actor.getSession();
    // WebSocketSession session = sessionRegistry.get(event.sessionId());
    // PlayerActor actor = worldManager.getPlayer(session);

    if ("new".equalsIgnoreCase(event.input())) {
      doRegister(session, actor);
    } else {
      doLoginUsername(session, actor, event);
    }
  }

  @EventListener
  public void onLogout(SystemEvent.Logout event) {}


  private void doRegister(WebSocketSession session, PlayerActor actor) throws IOException {
    log.info("doRegister");

    String msg = "【註冊流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 4 到 20 個字元之間。\r\n請輸入您想使用的帳號名稱:";
    // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
    actor.setConnectionState(ConnectionState.CREATING_USERNAME);
  }

  private void doLoginUsername(WebSocketSession session, PlayerActor actor,
      SystemEvent.Authenticate event) throws IOException {
    log.info("doLoginUsername");

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = validateUsername(event.input());

    // 如果格式正確，檢查資料庫是否存在該帳號
    if (errorReason == null && !userRepository.existsByUsername(event.input())) {
      errorReason = "帳號不存在。";
    }

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 驗證失敗次數過多 ({})，強制中斷。最後輸入: {}", event.sessionId(), retryCount, event.input());
        actor.sendText("嘗試次數過多，連線即將關閉。");
        session.close();
        return;
      }

      log.info("連線 {} 驗證失敗: {} (剩餘次數: {})", event.sessionId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    // actor.setTempUsername(event.input());

    String msg = "請輸入密碼:";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    String json = objectMapper.writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
    session.sendMessage(new TextMessage(json));

    actor.setConnectionState(ConnectionState.ENTERING_PASSWORD);
  }


  /**
   * 驗證用戶名是否合法
   *
   * @return 錯誤訊息，若合法則回傳 null
   */
  private String validateUsername(String input) {
    if (input == null || input.isEmpty()) {
      return "帳號名稱不能為空。";
    }
    if (!input.matches("^[a-zA-Z]+$")) {
      log.info("{}", input);
      return "帳號名稱只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。";
    }
    if (input.length() < 4 || input.length() > 20) {
      return "帳號名稱長度必須在 4 到 20 個字元之間。";
    }
    if (reservedWords.contains(input.toLowerCase())) {
      return "「" + input + "」是系統保留字或指令，請選擇其他名稱。";
    }
    return null;
  }

  /**
   * 驗證密碼是否合法
   *
   * @param input 輸入的密碼
   * @return 錯誤訊息，若合法則回傳 null
   */
  private String validatePassword(String input) {
    if (input == null || input.isEmpty()) {
      return "密碼不能為空。";
    }
    if (!input.matches("^[a-zA-Z0-9]+$")) {
      return "密碼只能包含英文字母與數字。";
    }
    if (input.length() < 6 || input.length() > 32) {
      return "密碼長度必須在 6 到 32 個字元之間。";
    }
    return null;
  }

}


--- File: AuthService.java ---

package com.example.htmlmud.application.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.entity.UserEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService {

  // 基礎保留字（非指令類的關鍵字）
  private final Set<String> reservedWords = new HashSet<>(
      Set.of("new", "quit", "exit", "wizard", "admin", "system", "root", "guest", "player"));

  // 使用 BCrypt，Spring Security 內建，或者自己 new 一個
  private final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

  private final UserRepository userRepository;

  private final CharacterRepository playerRepository;


  public boolean exists(String username) {
    return userRepository.existsByUsername(username);
  }

  /**
   * 註冊新帳號
   */
  @Transactional
  public CharacterEntity register(String username, String rawPassword) {
    if (userRepository.existsByUsername(username)) {
      throw new IllegalArgumentException("帳號已存在");
    }

    LocalDateTime now = LocalDateTime.now();
    UserEntity newUser = UserEntity.builder().username(username)
        .passwordHash(passwordEncoder.encode(rawPassword)).createdAt(now).lastLoginAt(now).build();
    userRepository.save(newUser);

    CharacterEntity characterEntity = new CharacterEntity();
    characterEntity.setUid(newUser.getId());
    characterEntity.setName(username);
    // characterEntity.setNickname(username);
    characterEntity.setCurrentRoomId(null);
    characterEntity.setState(new LivingState());
    characterEntity.setCreatedAt(now);
    characterEntity.setModifyAt(now);

    return playerRepository.save(characterEntity);
  }

  /**
   * 登入驗證
   */
  @Transactional
  public UserEntity login(String username, String rawPassword) {
    log.info("login username:{} password: {}", username, rawPassword);
    UserEntity user = userRepository.findByUsername(username)
        .orElseThrow(() -> new IllegalArgumentException("帳號不存在"));

    if (!passwordEncoder.matches(rawPassword, user.getPasswordHash())) {
      throw new IllegalArgumentException("密碼錯誤");
    }

    // 更新最後登入時間
    user.setLastLoginAt(LocalDateTime.now());
    return userRepository.save(user);
  }


  /**
   * 驗證用戶名是否合法
   *
   * @return 錯誤訊息，若合法則回傳 null
   */
  public String validateUsername(String input) {
    if (input == null || input.isEmpty()) {
      return "帳號名稱不能為空。";
    }
    if (!input.matches("^[a-zA-Z]+$")) {
      return "帳號名稱只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。";
    }
    if (input.length() < 4 || input.length() > 20) {
      return "帳號名稱長度必須在 4 到 20 個字元之間。";
    }
    if (reservedWords.contains(input.toLowerCase())) {
      return "「" + input + "」是系統保留字或指令，請選擇其他名稱。";
    }
    return null;
  }

  /**
   * 驗證密碼是否合法
   *
   * @param input 輸入的密碼
   * @return 錯誤訊息，若合法則回傳 null
   */
  public String validatePassword(String input) {
    if (input == null || input.isEmpty()) {
      return "密碼不能為空。";
    }
    if (!input.matches("^[a-zA-Z0-9]+$")) {
      return "密碼只能包含英文字母與數字。";
    }
    if (input.length() < 4 || input.length() > 32) {
      return "密碼長度必須在 4 到 32 個字元之間。";
    }
    return null;
  }

}


--- File: PlayerService.java ---

package com.example.htmlmud.application.service;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Service;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.mapper.PlayerMapper;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import com.example.htmlmud.infra.persistence.repository.UserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class PlayerService {

  private final UserRepository userRepository;

  private final CharacterRepository characterRepository;

  private final PlayerMapper mapper; // 注入 MapStruct

  // 模擬 DB: Username -> Password
  private final Map<String, String> userDb = new ConcurrentHashMap<>();

  // public PlayerService() {
  // // 預設一個測試帳號 (帳號: admin, 密碼: 123)
  // userDb.put("admin", "123");
  // }



  // public void register(PlayerActor actor) {

  // userDb.put(username.toLowerCase(), password);
  // }

  public boolean verifyPassword(String username, String password) {
    String stored = userDb.get(username.toLowerCase());
    return stored != null && stored.equals(password);
  }

  public PlayerRecord loadRecord(String uid, String username) {
    // 1. DB -> Entity
    CharacterEntity entity = characterRepository.findByUidAndName(uid, username)
        .orElseThrow(() -> new IllegalArgumentException("角色不存在 uid:" + uid + ", name:" + username));

    // 2. Entity -> Record (MapStruct 自動轉)
    // 注意：這裡得到的 Record 內含的 State 是 Entity 裡解序列化出來的
    return mapper.toRecord(entity);
  }
}


--- File: WorldManager.java ---

package com.example.htmlmud.application.service;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.LinkedBlockingQueue;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.stereotype.Service;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.factory.WorldFactory;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.actor.impl.RoomActor;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.infra.mapper.ItemTemplateMapper;
import com.example.htmlmud.infra.persistence.repository.ItemTemplateRepository;
import com.example.htmlmud.infra.persistence.repository.RoomStateRepository;
import com.example.htmlmud.infra.persistence.repository.TemplateRepository;
import com.example.htmlmud.infra.persistence.service.PlayerPersistenceService;
import com.example.htmlmud.infra.util.IdUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.annotation.PreDestroy;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class WorldManager {

  @Getter
  private final AuthService authService;

  @Getter
  private final PlayerService playerService;

  @Getter
  private final WorldFactory worldFactory; // 注入 Factory

  @Getter
  private final PlayerPersistenceService playerPersistenceService;

  // private final WorldFactory worldFactory;
  private final ObjectMapper objectMapper;
  private final ResourcePatternResolver resourceResolver;
  private final RoomStateRepository roomStateRepository;
  private final ItemTemplateRepository itemTemplateRepository;
  private final ItemTemplateMapper itemTemplateMapper;

  // 1. Static Data Cache: 存放唯讀的 Room 設定檔 (POJO/Record)
  // 雖然伺服器通常會載入全地圖，但 Caffeine 可以幫我們管理記憶體上限
  // private final Cache<String, RoomTemplate> staticRoomCache =
  // Caffeine.newBuilder().maximumSize(10_000) // 假設地圖上限
  // .expireAfterAccess(1, TimeUnit.HOURS) // 沒人用的房間資料可被釋放 (視需求)
  // .recordStats().build();

  // 怪物原型快取
  // private final Cache<String, MobTemplate> staticMobCache =
  // Caffeine.newBuilder().maximumSize(5_000).expireAfterAccess(1, TimeUnit.HOURS).build();

  private final TemplateRepository templateRepo;

  // 2. Runtime Actors: 存放正在運作的 RoomActor
  // 使用 ConcurrentHashMap 確保並發存取安全
  private final ConcurrentHashMap<String, RoomActor> activeRooms = new ConcurrentHashMap<>();

  // 3. Write-Behind Queue: 存放待寫入資料庫的變更
  private final BlockingQueue<RoomStateUpdate> persistenceQueue = new LinkedBlockingQueue<>();

  // 快取：ID -> Player 實體
  private final ConcurrentHashMap<String, PlayerActor> activePlayers = new ConcurrentHashMap<>();

  private volatile boolean isRunning = true;



  /**
   * 伺服器啟動時載入地圖
   */
  public void loadWorld() {
    log.info("Starting World Loading...");

    // 讀取 global 資料

    // 讀取 newbie_village 資料
    loadZone("newbie_village");



    // 啟動 Write-Behind 消費者執行緒
    // startPersistenceWorker();
  }


  private void loadZone(String zone) {
    try {

      // 讀取 zone 資料
      Resource resource =
          resourceResolver.getResource("classpath:data/zones/" + zone + "/manifest.json");
      if (resource == null) {
        log.error("Zone manifest not found: {}", zone);
        return;
      }
      ZoneTemplate zoneTemplate =
          objectMapper.readValue(resource.getInputStream(), ZoneTemplate.class);
      log.info("{}", objectMapper.writeValueAsString(zoneTemplate));
      templateRepo.registerZone(zoneTemplate);
      String zoneId = zoneTemplate.id();

      // 讀取 room 資料
      resource = resourceResolver.getResource("classpath:data/zones/" + zone + "/rooms.json");
      if (resource == null) {
        log.error("Zone rooms not found: {}", zone);
        return;
      }

      // 使用 TypeReference 來正確讀取 JSON 陣列為 Set<RoomTemplate>
      Set<RoomTemplate> rooms = objectMapper.readValue(resource.getInputStream(),
          new TypeReference<Set<RoomTemplate>>() {});

      for (RoomTemplate room : rooms) {
        log.info("{}", objectMapper.writeValueAsString(room));
        // 更新exits里的targetRoomId
        if (room.exits() != null) {
          for (Map.Entry<String, RoomExit> entry : room.exits().entrySet()) {
            RoomExit roomExit = entry.getValue();
            String newTargetRoomId = IdUtils.resolveId(zoneId, roomExit.targetRoomId());
            RoomExit newRoomExit = roomExit.toBuilder().targetRoomId(newTargetRoomId).build();
            entry.setValue(newRoomExit);
          }
        }

        // 更新 room.id
        String newRoomId = zoneId + ":" + room.id();
        RoomTemplate newRoom = room.toBuilder().id(newRoomId).zoneId(zoneId).build();
        templateRepo.registerRoom(newRoom);
      }


      // 讀取 mob 資料
      resource = resourceResolver.getResource("classpath:data/zones/" + zone + "/mobs.json");
      if (resource == null) {
        log.error("Zone mobs not found: {}", zone);
        return;
      }

      Set<MobTemplate> mobs = objectMapper.readValue(resource.getInputStream(),
          new TypeReference<Set<MobTemplate>>() {});
      for (MobTemplate mob : mobs) {
        log.info("{}", objectMapper.writeValueAsString(mob));

        String newMobId = zoneId + ":" + mob.id();
        MobTemplate newMob = mob.toBuilder().id(newMobId).build();
        templateRepo.registerMob(newMob);
      }


      // 讀取 item 資料

    } catch (IOException e) {
      log.error("Could not read rooms resources", e);
    }
  }
  /*
   * public void loadWorld_old() { log.info("Starting World Loading..."); try { // 讀取
   * classpath:maps/ 下所有的 json
   *
   * // 讀取 mob 資料
   *
   * // 讀取 item 資料
   *
   * // 讀取 room 資料
   *
   * Resource[] resources = resourceResolver.getResources("classpath:maps/*.json"); // Resource[]
   * resources = resourceResolver.getResources("classpath:maps/** /*.json");
   *
   *
   * for (Resource res : resources) { try { ZoneTemplate zone =
   * objectMapper.readValue(res.getInputStream(), ZoneTemplate.class); String zoneId = zone.id();
   * log.info("Loading Zone: {} ({}) - {} rooms", zone.name(), zoneId, zone.rooms().size());
   *
   * // 將房間放入 Cache，建立全域索引 for (RoomTemplate room : zone.rooms()) {
   *
   * // 更新exits里的targetRoomId for (Map.Entry<String, RoomExit> entry : room.exits().entrySet()) {
   * RoomExit roomExit = entry.getValue(); String newTargetRoomId = zoneId + ":" +
   * roomExit.targetRoomId(); RoomExit newRoomExit =
   * roomExit.toBuilder().targetRoomId(newTargetRoomId).build(); entry.setValue(newRoomExit); }
   *
   * String newRoomId = zoneId + ":" + room.id(); RoomTemplate newRoom =
   * room.toBuilder().id(newRoomId).build(); staticRoomCache.put(newRoomId, newRoom); }
   *
   * // 將怪物原型放入 Cache log.info("zone.mobTemplates().size: {}", zone.mobTemplates().size()); for
   * (MobTemplate mob : zone.mobTemplates()) { String newMobId = zoneId + ":" + mob.id();
   * MobTemplate newMob = mob.toBuilder().id(newMobId).build(); staticMobCache.put(newMobId,
   * newMob); }
   *
   * // 3. 根據 mob_resets 產生怪物實體 if (zone.mobResets() != null) { for (Population reset :
   * zone.mobResets()) {
   *
   * MobTemplate mobTpl = staticMobCache.getIfPresent(zoneId + ":" + reset.mobTemplateId());
   *
   * if (mobTpl != null) { RoomActor roomActor = getRoomActor(zoneId + ":" + reset.roomId());
   *
   * for (int i = 0; i < reset.count(); i++) { // 建立 MobActor 並設定初始房間 MobActor mobActor = new
   * MobActor(mobTpl, null); log.info("Spawned Mob: {} in Room: {}", mobTpl.name(), reset.roomId());
   * mobActor.setCurrentRoomId(roomActor.getId()); log.info("MobTemplate:{}",
   * objectMapper.writeValueAsString(mobActor));
   *
   * // 把 mob 塞到房間里 roomActor.getMobs().add(mobActor); mobActor.start(); } } else {
   * log.info("MobTemplate is null"); } } } } catch (IOException e) {
   * log.error("Failed to load map file: {}", res.getFilename(), e); } } } catch (IOException e) {
   * log.error("Could not read map resources", e); }
   *
   * // 啟動 Write-Behind 消費者執行緒 startPersistenceWorker(); }
   */

  // 啟動時載入世界
  /*
   * public void loadWorld2() { List<RoomStateEntity> entities = roomStateRepository.findAll();
   *
   * for (RoomStateEntity e : entities) { // 1. 構建靜態 Template RoomStateRecord tpl = new
   * RoomStateRecord(e.getRoomId(), e.getZoneId(), e.getDroppedItems());
   *
   * // 2. 構建動態 Actor (注入掉落物) // RoomActor actor = new RoomActor(tpl, e.getDroppedItems());
   *
   * // activeRooms.put(e.getId(), actor); } }
   */



  /**
   * 核心方法：取得或創建 RoomActor 這是進入遊戲世界的入口
   */
  public RoomActor getRoomActor(String roomId) {
    log.info("getRoomActor roomId: {}", roomId);
    // 1. 如果 Actor 已經存在，直接回傳
    return activeRooms.computeIfAbsent(roomId, id -> {
      RoomActor room = worldFactory.createRoom(id);

      // 可以在這裡觸發初始化事件
      if (room != null) {
        room.spawnInitialMobs(); // 讓房間自己去生怪
      }

      return room;
    });
  }

  public MobTemplate getMobTemplate(String mobId) {
    return templateRepo.findMob(mobId).orElseThrow(() -> {
      log.error("MobTemplate ID not found: " + mobId);
      // return new IllegalArgumentException("MobTemplate ID not found: " + mobId);
      return null;
    });
  }

  // ==========================================
  // Write-Behind Implementation (非同步存檔機制)
  // ==========================================

  // 定義存檔請求的封包 (Record)
  public record RoomStateUpdate(int roomId, String dataToSave) {
  }

  public void addPlayer(PlayerActor actor) {
    activePlayers.put(actor.getId(), actor);
  }

  public PlayerActor getPlayer(WebSocketSession session) {
    String playerId = (String) session.getAttributes().get(MudKeys.PLAYER_ID);
    return getPlayer(playerId);
  }

  public PlayerActor getPlayer(String playerId) {
    // TODO 若 playerActor 不存在，則需要從資料庫載入並建立

    return activePlayers.get(playerId);
  }

  public void removePlayer(String playerId) {
    activePlayers.remove(playerId);
  }


  /**
   * RoomActor 呼叫此方法來請求存檔，不會阻塞 Actor 的運作
   */
  public void enqueueSave(int roomId, String data) {
    persistenceQueue.offer(new RoomStateUpdate(roomId, data));
  }

  private void startPersistenceWorker() {
    // 使用 Java 21+ Virtual Thread 來處理後台存檔
    Thread.ofVirtual().name("world-persistence-worker").start(() -> {
      log.info("World Persistence Worker started (Virtual Thread)");
      while (isRunning) {
        try {
          // 阻塞直到有資料進來
          RoomStateUpdate update = persistenceQueue.take();
          processUpdate(update);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          break;
        }
      }
    });
  }

  private void processUpdate(RoomStateUpdate update) {
    // 模擬寫入資料庫 (MySQL JSON)
    // 未來這裡會注入 JPA Repository
    try {
      // 模擬 IO 延遲
      Thread.sleep(10);
      log.debug("[Write-Behind] Saved room {} state to DB: {}", update.roomId(),
          update.dataToSave());
    } catch (Exception e) {
      log.error("Error saving room state", e);
    }
  }

  @PreDestroy
  public void shutdown() {
    isRunning = false;
    // 實際專案中這裡應該要把 Queue 裡的剩餘資料 flush 到資料庫
    log.info("WorldManager shutting down...");
  }

  /**
   * 對房間內的所有人廣播訊息 (除了來源者自己)
   *
   * @param roomId 房間 ID
   * @param message 訊息內容
   * @param excludeActorId 不想收到廣播的人 (通常是移動者本人)，可為 null
   */
  public void broadcastToRoom(String roomId, String message, String excludeActorId) {
    List<PlayerActor> actors = getActorsInRoom(roomId); // 假設您已有此方法

    for (PlayerActor actor : actors) {
      if (excludeActorId != null && actor.getId().equals(excludeActorId)) {
        continue;
      }
      // 直接發送文字
      actor.sendText(message);
    }
  }

  // 簡單的 getActorsInRoom 實作參考 (效率較差，之後可用 Map<RoomId, Set<ActorId>> 優化)
  public List<PlayerActor> getActorsInRoom(String roomId) {
    return activePlayers.values().stream().filter(a -> roomId.equals(a.getCurrentRoomId()))
        .toList();
  }

  /**
   * 建立一個全新的物品實體
   *
   * @param templateId 物品原型 ID
   * @param randomize 是否進行隨機數值浮動
   */
  // public GameItem createItem(int templateId, boolean randomize) {
  // ItemTemplate tpl = loadItemTemplate(templateId);

  // GameItem item = new GameItem();
  // item.setId(UUID.randomUUID().toString());
  // item.setTemplateId(tpl.id());
  // item.setCurrentDurability(tpl.maxDurability());
  // item.setAmount(1);

  // // --- 處理隨機邏輯 (RNG) ---
  // if (randomize) {
  // // 1. 隨機浮動耐久度 (例如：全新 ~ 80% 新)
  // // item.setCurrentDurability(...);

  // // 2. 隨機詞綴 (例如 10% 機率出現 +1 攻擊)
  // if (ThreadLocalRandom.current().nextDouble() < 0.1) {
  // item.getDynamicProps().put("attack_bonus", 1);
  // item.getDynamicProps().put("quality", "RARE");
  // }
  // }

  // return item;
  // }

  // public ItemTemplate loadItemTemplate(int templateId) {
  // // 1. DB -> Entity
  // ItemTemplateEntity entity = itemTemplateRepository.findById(templateId).orElseThrow(
  // () -> new IllegalArgumentException("ItemTemplate ID not found: " + templateId));

  // // 2. Entity -> Record (MapStruct 自動轉)
  // // 注意：這裡得到的 Record 內含的 State 是 Entity 裡解序列化出來的
  // return itemTemplateMapper.toRecord(entity);
  // }
}


--- File: GameConfig.java ---

package com.example.htmlmud.config;

import java.util.concurrent.ScheduledExecutorService;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.example.htmlmud.application.command.CommandDispatcher;
import com.example.htmlmud.domain.context.GameServices;
import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
public class GameConfig {
  @Bean
  public GameServices gameServices(

      ObjectMapper objectMapper,

      ApplicationEventPublisher eventPublisher,

      CommandDispatcher commandDispatcher,

      ScheduledExecutorService scheduler) {
    return new GameServices(

        objectMapper,

        eventPublisher,

        commandDispatcher,

        scheduler);
  }
}


--- File: JacksonConfig.java ---

package com.example.htmlmud.config;

import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class JacksonConfig {

  @Bean
  @Primary // 確保這是預設使用的 ObjectMapper
  public ObjectMapper objectMapper() {
    ObjectMapper mapper = new ObjectMapper();

    // 1. 忽略 JSON 中存在但 Java POJO 中沒有的欄位 (避免新舊版本不相容導致報錯)
    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

    // 2. 允許空的 Bean (某些只有方法的物件序列化時不報錯)
    mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);

    // 3. (選用) 排版輸出，方便 Debug 查看 JSON，正式環境可關閉
    mapper.enable(SerializationFeature.INDENT_OUTPUT);

    return mapper;
  }
}


--- File: SchedulerConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@Configuration
public class SchedulerConfig {

  @Bean(destroyMethod = "shutdown") // 確保伺服器關閉時釋放資源
  public ScheduledExecutorService gameScheduler() {
    // 核心執行緒數設為 2~4 即可。
    // 因為我們只用它來 "觸發" 任務，實際執行會丟給 Virtual Thread，
    // 所以這個 Scheduler 幾乎不會被卡住，不需要太多執行緒。
    return Executors.newScheduledThreadPool(4, Thread.ofPlatform().factory());
  }
}


--- File: SecurityConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class SecurityConfig {
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }
}


--- File: WebSocketConfig.java ---

package com.example.htmlmud.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
import com.example.htmlmud.infra.server.MudWebSocketHandler;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

  private final MudWebSocketHandler mudWebSocketHandler;

  public WebSocketConfig(MudWebSocketHandler mudWebSocketHandler) {
    this.mudWebSocketHandler = mudWebSocketHandler;
  }

  @Override
  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
    registry.addHandler(mudWebSocketHandler, "/ws").setAllowedOrigins("*");
  }
}


--- File: LivingActor.java ---

package com.example.htmlmud.domain.actor;

import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.core.VirtualActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.protocol.ActorMessage;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

// 泛型 T 讓我們可以在子類別擴充更多 Message 類型
@Slf4j
public abstract class LivingActor extends VirtualActor<ActorMessage> {

  @Getter
  protected GameServices services;

  @Getter
  protected WorldManager manager;


  @Getter
  protected String id;

  // 所有生物都有狀態 (HP/MP)
  @Getter
  protected LivingState state;

  // 所有生物都在某個房間 (可能是 null)
  @Getter
  @Setter
  protected String currentRoomId;

  // 用來記錄進入房間的時間戳記 (奈秒精度以防同時進入)
  @Getter
  private long lastEnterRoomTime;

  public LivingActor(String id, LivingState state, WorldManager manager, GameServices services) {
    super(id); // Actor Name: "PLAYER:1"
    this.id = id;
    this.state = state;
    this.manager = manager;
    this.services = services;
  }

  // --- 共用行為邏輯 ---

  // 1. 受傷處理
  public void takeDamage(int amount, String attackerId) {
    if (state.isDead)
      return;

    this.state.hp -= amount;
    log.info("{} took {} damage from {}. HP: {}/{}", id, amount, attackerId, state.hp, state.maxHp);

    // 發送訊息給房間 (讓其他人看到噴血)
    // if (currentRoom != null) {
    // currentRoom.broadcast(...);
    // }

    if (state.hp <= 0) {
      die(attackerId);
    }
  }

  // 2. 死亡處理
  protected void die(String killerId) {
    this.state.hp = 0;
    this.state.isDead = true;
    log.info("{} has been slain by {}!", id, killerId);

    onDeath(killerId); // 樣板方法 (Template Method)，給子類別實作掉寶或重生地
  }

  // 3. 治療處理
  public void heal(int amount) {
    if (state.isDead)
      return;
    this.state.hp = Math.min(state.hp + amount, state.maxHp);
  }

  protected void onAttacked(LivingActor attacker, int damage) {

  }

  // 定義抽象方法，子類別必須實作
  protected void onDeath(String killerId) {

  }

  // 當怪物進入房間時呼叫此方法
  public void markEnterRoom() {
    this.lastEnterRoomTime = System.nanoTime();
  }
}


--- File: AggressiveBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 攻擊行為
public class AggressiveBehavior implements MobBehavior {

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {
    // 主動怪邏輯：看到玩家就攻擊
    // 發送戰鬥指令給 BattleSystem
    self.sayToRoom("滾出去！" + player.getName());
    self.attack(player);
  }

  @Override
  public void onInteract(MobActor self, PlayerActor player, String command) {
    self.sayToRoom("吼！！！(它看起來不想跟你說話)");
    self.attack(player);
  }
}


--- File: GuestBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import java.io.IOException;
import java.util.Map;
import java.util.Optional;
import org.slf4j.MDC;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.MudKeys;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.persistence.entity.UserEntity;
import com.example.htmlmud.protocol.ConnectionState;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
public class GuestBehavior implements PlayerBehavior {

  private static final int MAX_AUTH_RETRIES = 5;

  @Setter
  private String tempUsername; // 暫存正在處理的帳號名

  @Setter
  private String tempPassword; // 暫存正在處理的密碼


  @Override
  public PlayerBehavior handle(PlayerActor actor, GameCommand cmd) {
    MDC.put("actorName", "GUEST");

    try {
      // 目前只處理文字輸入 (Input)
      if (cmd instanceof GameCommand.Input(var text)) {
        switch (actor.getConnectionState()) {
          case CONNECTED -> doConnected(actor, text);
          case CREATING_USERNAME -> doCreatingUsername(actor, text);
          case CREATING_PASSWORD -> doCreatingPassword(actor, text);
          case ENTERING_PASSWORD -> doEnterPassword(actor, text);
          case ENTERING_CHAR_NAME -> doEnteringCharName(actor, text);
          case ENTERING_CHAR_GENDER -> {
          }
          case ENTERING_CHAR_RACE -> {
          }
          case ENTERING_CHAR_CLASS -> {
          }
          case ENTERING_CHAR_ATTRIBUTES -> {
          }
          case IN_GAME -> {
          }
        }
      }
    } finally {
      MDC.clear();
    }

    return null;
  }

  private void doConnected(PlayerActor actor, String input) {
    log.info("doConnected");

    if ("new".equalsIgnoreCase(input.trim())) {
      doRegister(actor);
    } else {
      doEnterUsername(actor, input);
    }
  }

  private void doRegister(PlayerActor actor) {
    log.info("doRegister");

    WebSocketSession session = actor.getSession();
    String msg = "【註冊流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 4 到 20 個字元之間。\r\n請輸入您想使用的帳號名稱:";
    try {
      // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
      actor.setConnectionState(ConnectionState.CREATING_USERNAME);
    } catch (IOException e) {
      log.error("doRegister {}", e.getMessage(), e);
    }
  }

  public void doCreatingUsername(PlayerActor actor, String input) {
    log.info("doCreatingUsername");
    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = actor.getManager().getAuthService().validateUsername(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.sendText("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 註冊帳號失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    this.tempUsername = input;

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n只能包含英文字母與數字且長度必須在 6 到 32 個字元之間。\r\n請輸入密碼:";
    try {
      // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      actor.setConnectionState(ConnectionState.CREATING_PASSWORD);
    } catch (IOException e) {
      log.error("doCreatingUsername {}", e.getMessage(), e);
    }
  }

  public void doCreatingPassword(PlayerActor actor, String input) {
    log.info("doCreatingPassword");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = actor.getManager().getAuthService().validatePassword(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 註冊密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.sendText("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 註冊密碼失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    this.tempPassword = input;

    // 新增玩家帳密
    actor.getManager().getAuthService().register(tempUsername, tempPassword);
    log.info("玩家註冊成功: {}", tempUsername);

    this.tempUsername = null;
    this.tempPassword = null;

    // String msg = "請輸入密碼:";
    String msg = "【註冊流程】\r\n註冊完成，請重新登入。";
    // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
    actor.sendText(msg);

    actor.setConnectionState(ConnectionState.CONNECTED);
    actor.start();
  }

  private void doEnterUsername(PlayerActor actor, String input) {
    log.info("doLoginUsername");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = actor.getManager().getAuthService().validateUsername(input);

    // 如果格式正確，檢查資料庫是否存在該帳號
    if (errorReason == null && !actor.getManager().getAuthService().exists(input)) {
      errorReason = "帳號不存在。";
    }

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 登入帳號失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.sendText("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 登入帳號失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，重置計數
    session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0);

    // 暫存帳號
    this.tempUsername = input;

    String msg = "請輸入密碼:";
    try {
      // 告訴前端：切換輸入模式為密碼 (透過自定義協議，例如 JSON {type: "PWD_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "PWD_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      actor.setConnectionState(ConnectionState.ENTERING_PASSWORD);
    } catch (IOException e) {
      log.error("msg");
    }
  }

  private void doEnterPassword(PlayerActor actor, String input) {
    log.info("doEnterPassword");

    WebSocketSession session = actor.getSession();

    // 取得目前的重試次數
    int retryCount = (int) Optional
        .ofNullable(session.getAttributes().get(MudKeys.AUTH_RETRY_COUNT_KEY)).orElse(0);

    String errorReason = actor.getManager().getAuthService().validatePassword(input);

    if (errorReason != null) {
      retryCount++;
      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, retryCount);

      if (retryCount >= MAX_AUTH_RETRIES) {
        log.warn("連線 {} 登入密碼失敗次數過多 ({})，強制中斷。最後輸入: {}", session.getId(), retryCount, input);
        actor.sendText("嘗試次數過多，連線即將關閉。");
        try {
          session.close();
        } catch (IOException ignored) {
        }

        return;
      }

      log.info("連線 {} 登入密碼失敗: {} (剩餘次數: {})", session.getId(), errorReason,
          MAX_AUTH_RETRIES - retryCount);
      actor.sendText(errorReason + " (剩餘嘗試次數: " + (MAX_AUTH_RETRIES - retryCount) + ")");
      return;
    }

    // 驗證成功，移除計數
    session.getAttributes().remove(MudKeys.AUTH_RETRY_COUNT_KEY);

    // 暫存密碼
    this.tempPassword = input;
    // log.info("玩家登入: {} {}", this.tempUsername, this.tempPassword);

    // 登入玩家帳密
    UserEntity userEntity = actor.getManager().getAuthService().login(tempUsername, tempPassword);
    log.info("玩家登入成功: {} {}", userEntity.getId(), userEntity.getUsername());

    // 載入 player
    try {
      PlayerRecord record = actor.getManager().getPlayerService().loadRecord(userEntity.getId(),
          userEntity.getUsername());
      actor.upgradeIdentity(record);
      actor.setConnectionState(ConnectionState.IN_GAME);

      // 在 PlayerActor.java 中
      log.info("當前狀態: {}", actor.getServices().objectMapper().writeValueAsString(actor.getState()));

    } catch (Exception e) {
      log.error("", e);
      // 進入角色設定流程
      doEnteringCharName(actor, input);
      return;
    }
  }

  private void doEnteringCharName(PlayerActor actor, String input) {
    log.info("doEnteringCharName");

    WebSocketSession session = actor.getSession();
    String msg =
        "【角色設定流程】\r\n只能包含英文字母（不分大小寫），不允許數字、空格或特殊符號。\r\n長度必須在 2 到 20 個字元之間。\r\n請輸入您想使用的角色名稱:";
    try {
      // 告訴前端：切換輸入模式為帳號 (透過自定義協議，例如 JSON {type: "USER_MODE"})
      String json = actor.getServices().objectMapper()
          .writeValueAsString(Map.of("type", "USER_MODE", "content", msg));
      session.sendMessage(new TextMessage(json));

      session.getAttributes().put(MudKeys.AUTH_RETRY_COUNT_KEY, 0); // 重置計數
      actor.setConnectionState(ConnectionState.ENTERING_CHAR_NAME);
    } catch (IOException e) {
      log.error("doRegister {}", e.getMessage(), e);
    }
  }

}


--- File: InGameBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import org.slf4j.MDC;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
public class InGameBehavior implements PlayerBehavior {
  // 這裡可以注入 CommandHandlerRegistry

  @Override
  public void onEnter(PlayerActor actor) {
    log.info("InGameBehavior onEnter()");
    // 進場時自動看一次房間
    // actor.handleGameLogic("look");
    actor.getServices().commandDispatcher().dispatch(actor, "look");
  }

  @Override
  public PlayerBehavior handle(PlayerActor actor, GameCommand cmd) {
    log.info("InGameBehavior handle()");

    MDC.put("actorName", actor.getName());

    try {
      // 目前只處理文字輸入 (Input)
      if (cmd instanceof GameCommand.Input(var text)) {
        // 【關鍵】將文字交給 Dispatcher
        actor.getServices().commandDispatcher().dispatch(actor, text);
      }
      // else if (cmd instanceof GameCommand.Logout) {
      // actor.reply("登出中...");
      // actor.handleDisconnect();
      // // ... 切換回 GuestBehavior ...
      // }
    } finally {
      MDC.clear();
    }

    return null; // 保持 InGame 狀態
  }
}


--- File: MerchantBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 商店行為
public class MerchantBehavior implements MobBehavior {

  private final int shopId;

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {
    // 禮貌性問候
    self.sayToRoom("歡迎光臨！需要買點什麼嗎？(輸入 'list' 查看商品)");
  }

  @Override
  public void onInteract(MobActor self, PlayerActor player, String command) {
    if ("list".equalsIgnoreCase(command)) {
      // 顯示商品列表
      // ShopService.showList(player, shopId);
    } else if (command.startsWith("buy")) {
      // 處理購買
    } else {
      // 隨機講一句話
      String dialog = self.getTemplate().dialogues().iterator().next();
      self.sayToRoom(dialog);
    }
  }

  @Override
  public void onDamaged(MobActor self, LivingActor attacker) {
    // 守衛邏輯：如果被打，可能呼叫警衛，或者單純不理會(因為無敵)
    self.sayToRoom("衛兵！有人在鬧事！");
    // Spawn guards...
  }
}


--- File: MobBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.LivingActor;
import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.protocol.ActorMessage;

public interface MobBehavior {

  // 定期心跳 (例如每秒一次)：決定是否移動、回血、索敵
  default void onTick(MobActor self) {}

  // 當玩家進入視野
  default void onPlayerEnter(MobActor self, PlayerActor player) {}

  // 當玩家與其互動 (例如輸入 "talk guard")
  default void onInteract(MobActor self, PlayerActor player, String command) {}

  // 當受傷時 (仇恨值處理)
  default void onDamaged(MobActor self, LivingActor attacker) {}

  // 處理通用訊息
  default void onMessage(MobActor self, ActorMessage msg) {}
}


--- File: PassiveBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.MobActor;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
// 被動行為 (一般 NPC)
public class PassiveBehavior implements MobBehavior {

  // 在 PassiveBehavior (一般 NPC) 的 onTick
  public void onTick(MobActor self) {
    // 5% 機率隨機移動
    if (Math.random() < 0.05) {
      // 隨機選一個出口移動
      // self.moveTo(randomExit);
    }

    // 10% 機率說夢話
    if (Math.random() < 0.1) {
      self.sayToRoom("今天天氣真好...");
    }
  }

  @Override
  public void onPlayerEnter(MobActor self, PlayerActor player) {

  }

}


--- File: PlayerBehavior.java ---

package com.example.htmlmud.domain.actor.behavior;

import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.protocol.GameCommand;

public interface PlayerBehavior {

  // 處理指令
  // 回傳值：如果是 null 代表狀態不變；如果回傳新的 Behavior，代表狀態切換 (Become)
  PlayerBehavior handle(PlayerActor actor, GameCommand cmd);

  // 當切換到這個狀態時觸發 (Optional)
  default void onEnter(PlayerActor actor) {}
}


--- File: VirtualActor.java ---

package com.example.htmlmud.domain.actor.core;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import com.example.htmlmud.protocol.ActorMessage;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class VirtualActor<T> {

  // 每個 Actor 都有自己的信箱
  protected final BlockingQueue<T> mailbox = new LinkedBlockingQueue<>();
  private final AtomicBoolean running = new AtomicBoolean(true);
  private final AtomicBoolean started = new AtomicBoolean(false);
  private final String actorName;

  public VirtualActor(String actorName) {
    this.actorName = actorName;
  }

  // 啟動 Actor：這會生成一個專屬的 Virtual Thread
  public void start() {
    if (started.compareAndSet(false, true)) {
      Thread.ofVirtual().name("actor-" + actorName).start(this::runLoop);
    } else {
      log.warn("Actor [{}] 已經啟動，忽略重複的啟動請求。", actorName);
    }
  }

  // 非阻塞投遞訊息 (給外部呼叫用)
  public void send(T message) {
    mailbox.offer(message);
  }

  // 核心迴圈
  private void runLoop() {
    log.info("Actor [{}] started on thread: {}", actorName, Thread.currentThread());

    try {
      while (running.get()) {
        // 這裡會 Block，虛擬執行緒會 Unmount，不佔用 OS Thread
        T message = mailbox.take();
        handleMessage(message);
      }
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      log.warn("Actor [{}] interrupted.", actorName);
    } catch (Exception e) {
      log.error("Actor [{}] encountered unexpected error", actorName, e);
    }
  }

  public void stop() {
    if (running.compareAndSet(true, false)) { // 確保只執行一次
      log.info("Stopping Actor [{}]", actorName);
      // 重要：送出一個中斷訊號給執行該 Actor 的 Virtual Thread
      // 因為 runLoop 卡在 mailbox.take()，如果不 interrupt，它會永遠卡在那裡直到有新訊息
      // 注意：這需要你在 start() 時保存 Thread 參照，或者發送一個 Poison Pill
    }
  }

  // 子類別實作具體邏輯
  protected abstract void handleMessage(T message);
}


--- File: MobActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.LivingActor;
import com.example.htmlmud.domain.actor.behavior.AggressiveBehavior;
import com.example.htmlmud.domain.actor.behavior.MerchantBehavior;
import com.example.htmlmud.domain.actor.behavior.MobBehavior;
import com.example.htmlmud.domain.actor.behavior.PassiveBehavior;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.protocol.ActorMessage;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class MobActor extends LivingActor {

  // 仇恨列表 (Key: 攻擊者 ID字串, Value: 仇恨值)
  // 因為 ID 已改為 UUID String，這裡的 Key 也同步調整為 String
  protected final Map<String, Integer> aggroTable = new HashMap<>();

  @Getter
  private final MobTemplate template;

  private ScheduledFuture<?> aiTask; // Heartbeat 排程
  private MobBehavior behavior; // AI 行為 (策略模式)

  /**
   * 建構子： 1. 接收 Template 與 Services 2. 自動生成 UUID 3. 自動從 Template 建立 LivingState
   */
  public MobActor(MobTemplate template, WorldManager worldManager, GameServices gameServices) {
    // 【修正 1】直接使用 UUID 作為 ID，不再依賴 GameObjectId.mob()
    // 【修正 2】呼叫 helper method 建立初始 State，確保血量與 Template 一致
    super(UUID.randomUUID().toString(), createInitialState(template), worldManager, gameServices);

    this.template = template;

    // 初始化行為
    initBehavior();

    log.debug("Mob created: {} (ID: {})", template.name(), this.getId());

    // 【重要】這裡移除了 this.start()，請在外部 (MobFactory) 建立實體後呼叫 mob.start()
  }

  // 輔助方法：根據 Template 產生初始的 LivingState
  private static LivingState createInitialState(MobTemplate tpl) {
    LivingState state = new LivingState();
    state.hp = tpl.maxHp();
    state.maxHp = tpl.maxHp();
    state.level = tpl.level();
    // 如果有 MP, Stamina 等屬性也可在此初始化

    return state;
  }

  private void initBehavior() {
    if (template.shopId() != null) {
      this.behavior = new MerchantBehavior(template.shopId());
    } else if (template.isAggressive()) {
      this.behavior = new AggressiveBehavior();
    } else {
      this.behavior = new PassiveBehavior();
    }
  }

  // --- 生命週期控制 ---

  @Override
  public void start() {
    super.start(); // 啟動 Actor 訊息佇列處理
    // startHeartbeat(); // 啟動 AI 心跳
  }

  @Override
  public void stop() {
    stopHeartbeat(); // 停止 AI
    super.stop(); // 停止 Actor
  }

  // --- 訊息處理 ---

  @Override
  protected void handleMessage(ActorMessage msg) {
    // 1. AI 決策優先 (例如：受到攻擊決定是否逃跑)
    behavior.onMessage(this, msg);

    // 2. 如果父類別有通用邏輯 (如 Buff 結算)，可視需求呼叫
    // super.handleMessage(msg);
  }

  // --- AI 心跳機制 (Heartbeat) ---

  private void startHeartbeat() {
    if (aiTask != null && !aiTask.isCancelled())
      return;

    // Scheduler (Platform Thread) 負責定時觸發
    this.aiTask = services.scheduler().scheduleAtFixedRate(() -> {
      // Virtual Thread 負責執行邏輯
      Thread.ofVirtual().name("mob-tick-" + this.getId()).start(() -> {
        try {
          if (this.state.hp > 0) {
            this.tick();
          } else {
            stopHeartbeat();
          }
        } catch (Exception e) {
          log.error("Mob tick error: {}", this.getId(), e);
        }
      });
    }, 1, 3, TimeUnit.SECONDS); // 延遲1秒開始，每3秒一次
  }

  private void stopHeartbeat() {
    if (aiTask != null) {
      aiTask.cancel(false);
      aiTask = null;
    }
  }

  public void tick() {
    // 委派給 Behavior
    behavior.onTick(this);
  }

  // --- 互動與事件 ---

  public void onPlayerEnter(PlayerActor player) {
    behavior.onPlayerEnter(this, player);
  }

  public void onInteract(PlayerActor player, String command) {
    behavior.onInteract(this, player, command);
  }

  @Override
  public void onAttacked(LivingActor attacker, int damage) {
    // 無敵判定
    if (template.isInvincible()) {
      if (attacker instanceof PlayerActor p) {
        p.sendText(this.template.name() + " 毫髮無傷！");
      }
      return;
    }

    // 1. 扣血 (呼叫父類別)
    super.onAttacked(attacker, damage);

    // 2. 增加仇恨值 (使用 String ID)
    addAggro(attacker.getId(), damage);

    // 3. 通知 AI
    behavior.onDamaged(this, attacker);
  }

  @Override
  protected void onDeath(String killerId) {
    super.onDeath(killerId);
    stopHeartbeat();

    log.info("{} died. Killer: {}", this.template.name(), killerId);
    // 觸發掉寶、給予經驗值等邏輯...
  }

  // 仇恨值管理 (Key 改為 String)
  public void addAggro(String sourceId, int value) {
    aggroTable.merge(sourceId, value, Integer::sum);
  }

  // 取得當前仇恨最高目標 ID
  public String getHighestAggroTarget() {
    return aggroTable.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey)
        .orElse(null);
  }

  // 行為層需要的輔助方法 (Facade)
  public void sayToRoom(String content) {
    // 實作：取得當前 RoomActor 並廣播
    // services.worldManager().getRoom(currentRoomId).broadcast(...)
  }

  public void attack(LivingActor target) {
    // 實作：發送 AttackMessage 給 target
  }
}


--- File: PlayerActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.slf4j.MDC;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.LivingActor;
import com.example.htmlmud.domain.actor.behavior.GuestBehavior;
import com.example.htmlmud.domain.actor.behavior.InGameBehavior;
import com.example.htmlmud.domain.actor.behavior.PlayerBehavior;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.domain.context.MudContext;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.LivingState;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.ConnectionState;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

// PlayerActor 處理的訊息類型就是 GameCommand
@Slf4j
public class PlayerActor extends LivingActor {

  @Getter
  private WebSocketSession session;


  // 當前的行為腦
  private PlayerBehavior currentBehavior;

  @Getter
  @Setter
  private String name;

  @Getter
  @Setter
  private String nickname;

  @Getter
  @Setter
  private String lookDescription;


  // Actor 內部狀態 (State Machine Context)
  @Getter
  @Setter
  private ConnectionState connectionState = ConnectionState.CONNECTED;


  // 背包
  @Getter
  private List<GameItem> inventory = new ArrayList<>();

  private boolean isDirty = false;

  private PlayerActor(WebSocketSession session, String id, LivingState state,
      WorldManager worldManager, GameServices gameServices) {
    super(id, state, worldManager, gameServices);
    this.session = session;
  }

  // 工廠方法
  public static PlayerActor createGuest(WebSocketSession session, WorldManager worldManager,
      GameServices gameServices) {
    PlayerActor actor =
        new PlayerActor(session, session.getId(), new LivingState(), worldManager, gameServices);
    // 初始設定為 GuestBehavior
    actor.become(new GuestBehavior());
    actor.inventory = new ArrayList<>();
    return actor;
  }

  @Override
  public void start() {
    super.start();
    // 連線歡迎詞
    reply("歡迎光臨 Html Mud 世界！");
    reply("請輸入 帳號 進行登入 或 輸入 'new' 進行註冊：");
  }

  @Override
  protected void handleMessage(ActorMessage msg) {
    String traceId = msg.traceId();

    // A. 設定 MDC (給 Log 看)
    MDC.put("traceId", traceId);
    // MDC.put("actorId", this.id);

    try {
      // B. 設定 ScopedValue (給 Service 邏輯看)
      ScopedValue.where(MudContext.CURRENT_PLAYER, this).where(MudContext.TRACE_ID, traceId)
          .run(() -> {

            // C. 委派給當前 Behavior 處理
            PlayerBehavior next = currentBehavior.handle(this, msg.command());

            // D. 狀態切換
            if (next != null) {
              become(next);
            }
          });
    } finally {
      // E. 清理 MDC
      MDC.clear();
    }
    /*
     * // 這裡已經是 Single Thread 環境，完全不用 synchronized // 使用 ScopedValue 重新綁定從信封拿到的 traceId
     * ScopedValue.where(MudContext.TRACE_ID, msg.traceId()).run(() -> { GameCommand cmd =
     * msg.command();
     *
     * // 只處理字串輸入 (Input) if (cmd instanceof GameCommand.Input(var text)) { String cleanText =
     * text.trim(); log.info("[State:{}] Input: {}", state, cleanText);
     *
     * // 根據當前狀態分流 // switch (connectionState) { // case CONNECTED -> handleConnected(cleanText); //
     * case CREATING_USER -> handleRegisterUsername(cleanText); // case CREATING_PASS ->
     * handleRegisterPassword(cleanText); // case ENTERING_PASS -> handleLoginPassword(cleanText);
     * // case PLAYING -> handleGameLogic(cleanText, msg.traceId()); // } handleGameLogic(cleanText,
     * msg.traceId()); } });
     */
    // 這裡是由 Actor 的 Virtual Thread 執行的
    // Actor 直接操作 session 物件發送資料
    // try {
    // switch (cmd) {
    // case GameCommand.Login(var user, var pass) -> {
    // log.info("[Trace:{}] Processing Login: {}", traceId, user);
    // handleLogin(user, pass);
    // }

    // // 核心：所有遊戲指令都在這裡處理
    // case GameCommand.Input(var text) -> {
    // log.info("[Trace:{}] Processing Input: {}", traceId, text);
    // handleStringInput(text);
    // }
    // // case GameCommand.Chat(var content) -> {
    // // log.debug("Chat from {}: {}", playerName, content);

    // // reply("%s 說: %s".formatted(playerName, content));
    // // }
    // // case GameCommand.Move(var dir) -> {
    // // reply("你往 %s 移動了一步。".formatted(dir));
    // // }
    // }
    // } catch (Exception e) {
    // log.error("[Trace:{}] Error", traceId, e);
    // }
  }

  @Override
  protected void onDeath(String killerId) {
    reply("你已經死亡！即將在重生點復活...");
    // 玩家死亡邏輯：掉經驗、傳送回城
  }

  public void sendText(String text) {
    reply(text);
  }

  // 狀態切換方法
  private void become(PlayerBehavior nextBehavior) {
    this.currentBehavior = nextBehavior;
    this.currentBehavior.onEnter(this); // 觸發進場事件
    log.info("{} 切換行為模式至 {}", this.id, nextBehavior.getClass().getSimpleName());
  }

  public void handleDisconnect() {
    // 1. 停止 Actor 迴圈
    this.stop();

    // 2. 如果已經登入並存在於世界中，從世界移除
    // 注意：這裡可以做「離線保護」或「延遲登出」
    // 但最簡單的做法是直接移除
    // worldManager.removePlayer(this.getId());

    // 3. 觸發存檔 (Write-Behind)
    // persistenceService.saveAsync(this.toRecord());
  }

  // --- 狀態處理邏輯 ---
  /*
   * // 1. 剛連線 private void handleConnected(String input) { if ("new".equalsIgnoreCase(input)) {
   * connectionState = ConnectionState.CREATING_USER; reply("【註冊流程】請輸入您想使用的帳號名稱："); } else { //
   * 視為嘗試登入 // if (playerService.exists(input)) { // this.tempUsername = input; // state =
   * State.LOGIN_PASSWORD; // reply("帳號存在，請輸入密碼："); // } else { //
   * reply("找不到帳號 '%s'。請重新輸入，或輸入 'new' 註冊。".formatted(input)); // } } }
   *
   * // 2. 註冊 - 檢查帳號 private void handleRegisterUsername(String input) { if (input.length() < 3) {
   * reply("帳號長度需大於 3 個字元，請重試："); return; } // if (playerService.isReservedWord(input)) { //
   * reply("'%s' 是系統保留字，請換一個：".formatted(input)); // return; // } // if
   * (playerService.exists(input)) { // reply("'%s' 已經被註冊了，請換一個：".formatted(input)); // return; // }
   *
   * this.tempUsername = input; connectionState = ConnectionState.ENTERING_PASS;
   * reply("帳號 '%s' 可用。請設定您的密碼：".formatted(input)); }
   *
   * // 3. 註冊 - 設定密碼 private void handleRegisterPassword(String input) { if (input.length() < 3) {
   * reply("密碼太短，請重試："); return; }
   *
   * // playerService.register(tempUsername, input); // log.info("User registered: {}",
   * tempUsername);
   *
   * reply("註冊成功！已自動為您登入。"); enterGame(); }
   *
   * // 4. 登入 - 驗證密碼 private void handleLoginPassword(String input) { // if
   * (playerService.verifyPassword(tempUsername, input)) { //
   * reply("登入成功！歡迎回來，%s".formatted(tempUsername)); // enterGame(); // } else { //
   * reply("密碼錯誤，請重新輸入："); // } }
   *
   * // 5. 進入遊戲 (轉場) private void enterGame() { connectionState = ConnectionState.PLAYING; //
   * 未來這裡可以加入 WorldManager.joinRoom() handleGameLogic("look", "system-init"); // 自動看一次環境 }
   */
  // 6. 遊戲中邏輯 (Look, Kill, Move...)
  // private void handleGameLogic(String input, String traceId) {
  // String[] parts = handleStringInput(input);
  // String action = parts[0].toLowerCase();

  // switch (action) {
  // case "look" -> {
  // // 範例：組合一個多彩的房間描述
  // StringBuilder sb = new StringBuilder();
  // sb.append(ColorText.wrap(AnsiColor.BRIGHT_WHITE, AnsiColor.BOLD, "=== 新手村廣場 ===\n"));
  // sb.append(ColorText.wrap(AnsiColor.LIGHT_GREY, "這是一個鋪著石板的廣場，四週有些破舊。\n"));
  // sb.append("這裡有一個 ").append(ColorText.npc("村長")).append(" 站在噴泉旁。\n");
  // sb.append("地上掉落了一把 ").append(ColorText.item("生鏽的鐵劍")).append("。\n");
  // sb.append("往北可以看到陰森的 ").append(ColorText.wrap(AnsiColor.DARK_GREY, "黑暗森林")).append("。");

  // reply(sb.toString());
  // } // reply("你看見四週一片漆黑，遠方似乎有微弱的火光。");
  // case "help" -> reply("可用指令: look, say, quit");
  // case "say" -> reply("你說道: " + (parts.length > 1 ? input.substring(4) : "..."));
  // case "quit" -> {
  // reply("再見！");
  // // 這裡可以做 disconnect 邏輯
  // }
  // case "kill" -> {
  // if (parts.length > 1) {
  // reply("你揮劍砍向了 %s！".formatted(parts[1]));
  // } else {
  // reply("你要殺誰？");
  // }
  // }
  // default -> {
  // log.info("Unknown command: {}", action);
  // reply("我不懂 '%s' 是什麼意思。".formatted(action));
  // }
  // }
  // }

  // private void handleLogin(String user, String pass) {
  // log.info("Player logged in: {}", user);

  // reply("歡迎進入 MUD 世界，%s。現在時間：%s".formatted(user, java.time.Instant.now()));
  // // // 1. 查 DB (透過 Service)
  // // PlayerEntity entity = playerRepository.findByUsername(cmd.username());

  // // // 2. 比對密碼 (使用 BCrypt)
  // // if (entity != null && passwordEncoder.matches(cmd.password(), entity.getPasswordHash())) {
  // // this.isLoggedIn = true;
  // // this.playerId = entity.getId();
  // // this.state = loadState(entity); // 載入玩家資料
  // // send("登入成功！");
  // // } else {
  // // send("帳號或密碼錯誤。");
  // // // 可以增加失敗計數器，防止爆破
  // // }
  // }
  // 在 PlayerActor.java 中
  protected void levelUp() {
    // 從 Context 取得當前 Trace ID
    String currentTraceId = MudContext.traceId();

    // 發送事件
    // publisher.publishEvent(
    // new DomainEvent.PlayerLevelUpEvent(currentTraceId, this.objectId.id(), this.state.level));
  }

  public void reply(String msg) {
    try {
      if (session.isOpen()) {
        // 使用 Map 來建立結構，Jackson 會自動處理所有特殊字元的轉義
        String json =
            services.objectMapper().writeValueAsString(Map.of("type", "TEXT", "content", msg));

        session.sendMessage(new TextMessage(json));
      }
    } catch (IOException e) {
      log.error("Reply failed", e);
    }
  }

  // --- 這裡實現您的 "純字串" 邏輯 ---
  private String[] handleStringInput(String text) {
    log.info("Player {} input: {}", name, text);

    // 簡單的傳統 MUD 解析方式
    // 未來這裡可以抽換成更高級的 Parser，但介面(Input text)不用變
    return text.trim().split("\\s+");
  }

  // 供子類別 (PlayerActor) 呼叫，用來切換數據
  protected void swapIdentity(String newId, LivingState newState) {
    this.id = newId;
    this.state = newState;
  }

  // 供 GuestBehavior 呼叫：變身為正式玩家
  public void upgradeIdentity(PlayerRecord record) {
    this.fromRecord(record);
    this.become(new InGameBehavior());
    log.info("Actor 變身成功: {} (InGameBehavior)", this.name);
  }

  public void replaceSession(WebSocketSession newSession) {
    // 1. 關閉舊連線 (如果還開著)
    if (this.session != null && this.session.isOpen()) {
      try {
        this.session.close();
      } catch (IOException ignored) {
      }
    }

    // 2. 換上新連線
    this.session = newSession;

    // 3. 重發當前環境資訊
    this.sendText("\u001B[33m[系統] 連線已恢復。\u001B[0m");
    this.services.commandDispatcher().dispatch(this, "look");
  }

  private void handleLoginSuccess(PlayerRecord record) {
    // 使用父類別的 protected 方法變身
    swapIdentity(record.id(), record.state());

    // 變身後，才加入世界管理
    // WorldManager.joinWorld(this);

    reply("登入成功！");
  }

  // 觸發存檔的輔助方法
  public void save() {
    manager.getPlayerPersistenceService().saveAsync(this.toRecord());
  }


  public PlayerRecord toRecord() {
    // 您必須確保 LivingState 有實作 deepCopy，否則會發生併發修改例外
    return new PlayerRecord(this.id, // ID
        this.name, // Username
        this.nickname, // Nickname
        this.currentRoomId, // Room
        this.state.deepCopy(), // 【關鍵】深層複製 State
        new ArrayList<GameItem>(this.inventory) // Inventory
    );
  }

  public void fromRecord(PlayerRecord record) {
    // 1. 更新基礎資料
    this.name = record.name();
    this.nickname = record.nickname();
    this.currentRoomId = record.currentRoomId();
    this.inventory = record.inventory();


    // 2. 更新狀態 (直接替換引用)
    // 因為 Record 是從 DB 讀出來的新物件，這裡的 state 是全新的，可以直接拿來用
    this.swapIdentity(record.id(), record.state());

    // 3. 標記為已登入
    this.id = record.id();
  }
}


--- File: RoomActor.java ---

package com.example.htmlmud.domain.actor.impl;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import com.example.htmlmud.domain.actor.core.VirtualActor; // 引用您的基礎類別
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.SpawnRule;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import com.example.htmlmud.protocol.RoomMessage;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
// 1. 繼承 VirtualActor，並指定泛型為 RoomMessage
public class RoomActor extends VirtualActor<RoomMessage> {

  @Getter
  private final String id;

  @Getter
  private final RoomTemplate template;

  @Getter
  private final ZoneTemplate zoneTemplate;

  @Getter
  private final Set<SpawnRule> spawnRules;

  // 房間內的玩家 (Runtime State)
  @Getter
  private final Set<PlayerActor> players = ConcurrentHashMap.newKeySet();

  @Getter
  private final Set<MobActor> mobs = ConcurrentHashMap.newKeySet();

  private final List<GameItem> items = new ArrayList<>(); // 地上的物品

  public RoomActor(RoomTemplate template, ZoneTemplate zoneTemplate) {
    this(template, zoneTemplate, new ArrayList<>());
  }

  public RoomActor(RoomTemplate template, ZoneTemplate zoneTemplate, List<GameItem> initialItems) {
    // 2. 傳入 Actor 名稱給父類別 (方便 Log 排查)
    super("room-" + template.id());
    this.id = template.id();
    this.template = template;
    this.zoneTemplate = zoneTemplate;
    // 從 Template 複製規則 (因為這是固定的)
    this.spawnRules = template.spawnRules();

    if (initialItems != null) {
      this.items.addAll(initialItems);
    }
  }

  // --- 實作父類別的抽象方法 ---

  @Override
  protected void handleMessage(RoomMessage msg) {
    // 這裡的邏輯跟之前一模一樣，但不需要自己寫 loop 和 try-catch 了
    switch (msg) {
      case RoomMessage.PlayerEnter(var player, var future) -> {
        log.info("Player {} entered room", player.getId());
        player.markEnterRoom();
        players.add(player);
        broadcastToOthers(player.getId(), "看到 " + player.getNickname() + " 走了進來。");
        log.debug("Player {} entered room {}", player.getNickname(), template.id());
        if (future != null)
          future.complete(null);
      }

      case RoomMessage.PlayerLeave(var playerId) -> {
        players.stream().filter(p -> p.getId().equals(playerId)).findFirst().ifPresent(p -> {
          if (players.remove(p))
            broadcastToOthers(playerId, p.getNickname() + " 離開了。");
        });
      }

      case RoomMessage.Look(var playerId, var future) -> {
        log.info("Player {} Look room", playerId);
        StringBuilder sb = new StringBuilder();
        sb.append("\u001B[1;36m").append(template.name()).append("\u001B[0m\r\n");
        sb.append(template.description()).append("\r\n");

        if (template.exits() != null && !template.exits().isEmpty()) {
          sb.append("\u001B[33m[出口]: ").append(String.join(", ", template.exits().keySet()))
              .append("\u001B[0m\r\n");
        }

        StringBuilder others = new StringBuilder();
        players.stream().filter(p -> !p.getId().equals(playerId))
            .forEach(p -> others.append(p.getNickname()).append(" "));

        if (!others.isEmpty()) {
          sb.append("\u001B[35m[這裡有]: \u001B[0m").append(others).append("\r\n");
        }
        future.complete(sb.toString());
      }

      case RoomMessage.Say(var sourceId, var content) -> {
        PlayerActor speaker =
            players.stream().filter(p -> p.getId().equals(sourceId)).findFirst().orElse(null);
        String name = (speaker != null) ? speaker.getNickname() : "有人";
        broadcast(name + ": " + content);
      }

      case RoomMessage.TryPickItem(var itemId, var picker) -> {
        // 【關鍵併發控制】
        // var item = items.stream().filter(i -> i.id.equals(itemId)).findFirst();
        // if (item.isPresent()) {
        // items.remove(item.get());
        // 回覆給 Command: 成功
        // picker.send(new ActorMessage("...", new InternalCommand.PickSuccess(item.get())));
        // } else {
        // 回覆給 Command: 失敗
        // picker.send(new ActorMessage("...", new InternalCommand.PickFail("東西不在了")));
        // }
      }
    }
  }

  // --- 物品操作邏輯 ---

  // public Optional<Item> pickItem(String keyword) {
  // 簡單搜尋邏輯
  // var found = items.stream().filter(i -> isMatch(i, keyword)) // 需實作 isMatch
  // .findFirst();

  // found.ifPresent(items::remove);
  // return found; // 這裡回傳後，記得要標記 Dirty
  // }

  // --- 輔助方法 (保持不變) ---

  private void broadcast(String message) {
    players.forEach(p -> p.sendText(message));
  }

  private void broadcastToOthers(String sourceId, String message) {
    players.stream().filter(p -> !p.getId().equals(sourceId)).forEach(p -> p.sendText(message));
  }

  // 產生快照 (只存變動的部分)
  public RoomStateRecord toRecord() {
    String[] args = template.id().split(":");
    String zoneId = args[0];
    String roomId = args[1];
    return new RoomStateRecord(roomId, zoneId, new ArrayList<>(items));
  }

  // public void addPlayer(PlayerActor player) {
  // player.markEnterRoom();
  // players.add(player);
  // }

  // public void removePlayer(PlayerActor player) {
  // players.remove(player);
  // }

  public List<PlayerActor> getPlayersSnapshot() {
    List<PlayerActor> players = new ArrayList<>(this.players);
    players.sort(Comparator.comparing(PlayerActor::getNickname));
    return players;
  }

  public void dropItem(GameItem item) {
    items.add(item);
    // 標記為 Dirty (需要存檔)
    // WorldManager.markDirty(this.template.id());
  }

  public void removeItem(GameItem item) {
    items.remove(item);
    // 標記為 Dirty (需要存檔)
    // WorldManager.markDirty(this.template.id());
  }

  public List<GameItem> getItemsSnapshot() {
    return new ArrayList<>(items);
  }



  /**
   * 處理怪物進入
   */
  public void addMob(MobActor mob) {
    // 標記時間
    mob.markEnterRoom();
    mobs.add(mob);
  }

  /**
   * 處理怪物離開
   */
  public void removeMob(MobActor mob) {
    mobs.remove(mob);
  }

  /**
   * 獲取有序快照 排序規則：先根據進入時間 (老鳥在前)，如果時間一樣，再比對 ID
   */
  public List<MobActor> getMobsSnapshot() {
    // 1. 複製 (O(N))
    List<MobActor> snapshot = new ArrayList<>(this.mobs);

    // 2. 排序 (O(N log N))
    // 排序規則：名稱 -> 進入時間 -> ID
    snapshot.sort(Comparator.comparing((MobActor m) -> m.getTemplate().name())
        .thenComparingLong(MobActor::getLastEnterRoomTime).thenComparing(MobActor::getId));

    return snapshot;
  }

  /**
   * 房間初次載入時的生怪邏輯
   */
  public void spawnInitialMobs() {
    if (spawnRules == null)
      return;

    for (SpawnRule rule : spawnRules) {
      // 處理機率 (例如：稀有怪只有 10% 機率出現)
      if (Math.random() > rule.respawnChance()) {
        continue;
      }

      // 根據數量生成
      for (int i = 0; i < rule.count(); i++) {
        spawnOneMob(rule);
      }
    }
  }

  private void spawnOneMob(SpawnRule rule) {
    // 1. 呼叫工廠產生 MobActor (這裡會給予 UUID)
    // MobActor mob = services.mobFactory().createMob(rule.mobTemplateId());

    // // 2. 設定位置
    // mob.setCurrentRoomId(this.id);

    // // 3. 加入房間列表
    // this.mobs.add(mob);

    // // 4. 啟動怪物的 AI
    // mob.start();

    // log.debug("Spawned {} in room {}", mob.getTemplate().name(), this.id);
  }
}


--- File: GameServices.java ---

package com.example.htmlmud.domain.context;

import java.util.concurrent.ScheduledExecutorService;
import org.springframework.context.ApplicationEventPublisher;
import com.example.htmlmud.application.command.CommandDispatcher;
import com.fasterxml.jackson.databind.ObjectMapper;

public record GameServices(

    ObjectMapper objectMapper,

    ApplicationEventPublisher eventPublisher,

    CommandDispatcher commandDispatcher,

    ScheduledExecutorService scheduler

) {

}


--- File: MudContext.java ---

package com.example.htmlmud.domain.context;

import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.fasterxml.jackson.databind.ObjectMapper;

public class MudContext {
  // 1. 當前操作的玩家 Actor (最重要的)
  public static final ScopedValue<PlayerActor> CURRENT_PLAYER = ScopedValue.newInstance();

  // 2. 當前的 Trace ID (除錯用)
  public static final ScopedValue<String> TRACE_ID = ScopedValue.newInstance();

  public static final ScopedValue<ObjectMapper> OBJECT_MAPPER = ScopedValue.newInstance();

  // 輔助方法：取得當前玩家，如果沒設定(例如系統背景作業)則拋出異常
  public static PlayerActor currentPlayer() {
    if (!CURRENT_PLAYER.isBound()) {
      throw new IllegalStateException("當前不在玩家操作的 Context 中！");
    }
    return CURRENT_PLAYER.get();
  }

  // 輔助方法：取得當前 TraceId，沒綁定就回傳 "SYSTEM"
  public static String traceId() {
    return TRACE_ID.isBound() ? TRACE_ID.get() : "UNKNOWN";
  }

}


--- File: MudKeys.java ---

package com.example.htmlmud.domain.context;

public class MudKeys {

  public static final String PLAYER_ID = "MUD_PLAYER_ID";

  public static final String AUTH_RETRY_COUNT_KEY = "AUTH_RETRY_COUNT";

}


--- File: DomainEvent.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;
import com.example.htmlmud.domain.actor.impl.PlayerActor;

/**
 * 領域事件的根介面 使用 sealed 限制只有特定的 record 可以實作它
 */
public sealed interface DomainEvent permits DomainEvent.SessionEvent, DomainEvent.SystemEvent,
    DomainEvent.WorldEvent, PlayerEvents, MobEvents {

  // 所有事件都必須有的 metadata
  Instant occurredOn();

  // 預設實作，方便取得當下時間
  static Instant now() {
    return Instant.now();
  }

  /**
   * 連線相關事件
   */
  sealed interface SessionEvent extends DomainEvent
      permits SessionEvent.Established, SessionEvent.MessageReceived, SessionEvent.Closed {

    String sessionId();

    record Established(String sessionId, Instant occurredOn) implements SessionEvent {
    }

    record MessageReceived(String sessionId, String message, Instant occurredOn)
        implements SessionEvent {
    }

    record Closed(String sessionId, String reason, int statusCode, Instant occurredOn)
        implements SessionEvent {
    }
  }

  /**
   * 系統指令與認證事件
   */
  sealed interface SystemEvent extends DomainEvent
      permits SystemEvent.Authenticate, SystemEvent.RegisterUsername, SystemEvent.RegisterPassword,
      SystemEvent.Login, SystemEvent.Logout {

    String sessionId();

    record RegisterUsername(String sessionId, String input, Instant occurredOn)
        implements SystemEvent {
    }

    record RegisterPassword(String sessionId, String input, Instant occurredOn)
        implements SystemEvent {
    }


    record Login(String sessionId, String input, Instant occurredOn) implements SystemEvent {
    }

    record Authenticate(String sessionId, String input, Instant occurredOn) implements SystemEvent {
    }

    record Logout(String sessionId, PlayerActor player, Instant occurredOn) implements SystemEvent {
    }
  }

  /**
   * 遊戲世界運行事件
   */
  sealed interface WorldEvent extends DomainEvent permits WorldEvent.Tick {

    record Tick(long gameTickTime, Instant occurredOn) implements WorldEvent {
    }
  }

}


--- File: MobEvents.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;
import java.util.Map;

public sealed interface MobEvents extends DomainEvent permits MobEvents.MobDead {
  // 怪物死亡
  record MobDead(String mobId, String killerId, // 誰殺的
      Map<String, Double> dropItems, // 掉落物預覽
      Instant occurredOn) implements MobEvents {
  }
}


--- File: PlayerEvents.java ---

package com.example.htmlmud.domain.event;

import java.time.Instant;

public sealed interface PlayerEvents extends DomainEvent
    permits PlayerEvents.LoggedIn, PlayerEvents.LoggedOut, PlayerEvents.LevelUp {

  // 1. 玩家登入事件
  record LoggedIn(String playerId, String username, String ipAddress, Instant occurredOn)
      implements PlayerEvents {
    public LoggedIn(String playerId, String username, String ipAddress) {
      this(playerId, username, ipAddress, DomainEvent.now());
    }
  }

  // 2. 玩家登出事件
  record LoggedOut(String playerId, Instant occurredOn) implements PlayerEvents {
    public LoggedOut(String playerId) {
      this(playerId, DomainEvent.now());
    }
  }

  // 3. 玩家升級
  record LevelUp(String playerId, int newLevel, Instant occurredOn) implements PlayerEvents {
    public LevelUp(String playerId, int newLevel) {
      this(playerId, newLevel, DomainEvent.now());
    }
  }
}


--- File: CommandAlias.java ---

package com.example.htmlmud.domain.logic.command.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE) // 只能放在類別上
@Retention(RetentionPolicy.RUNTIME) // 執行時期透過反射讀取
public @interface CommandAlias {
  String[] value(); // 允許傳入多個別名，例如 {"l", "see"}
}


--- File: Direction.java ---

package com.example.htmlmud.domain.model;

import lombok.Getter;

@Getter
public enum Direction {
  NORTH("north", "n", "北方"),

  SOUTH("south", "s", "南方"),

  EAST("east", "e", "東方"),

  WEST("west", "w", "西方"),

  NORTHEAST("northeast", "ne", "東北方"),

  NORTHWEST("northwest", "nw", "西北方"),

  SOUTHEAST("southeast", "se", "東南方"),

  SOUTHWEST("southwest", "sw", "西南方"),

  UP("up", "u", "上方"),

  DOWN("down", "d", "下方");

  private final String fullName;
  private final String shortName;
  private final String displayName;

  Direction(String fullName, String shortName, String displayName) {
    this.fullName = fullName;
    this.shortName = shortName;
    this.displayName = displayName;
  }

  // 解析輸入字串 (例如輸入 "n" 或 "North" 都能找到)
  public static Direction parse(String input) {
    if (input == null)
      return null;
    String normalized = input.trim().toLowerCase();
    for (Direction d : values()) {
      if (d.fullName.equals(normalized) || d.shortName.equals(normalized)) {
        return d;
      }
    }
    return null;
  }

  // 取得反方向 (用於：你往北走，別人看到你從"南"邊來)
  public Direction opposite() {
    return switch (this) {
      case NORTH -> SOUTH;
      case SOUTH -> NORTH;
      case EAST -> WEST;
      case WEST -> EAST;
      case NORTHEAST -> SOUTHWEST;
      case NORTHWEST -> SOUTHEAST;
      case SOUTHEAST -> NORTHWEST;
      case SOUTHWEST -> NORTHEAST;
      case UP -> DOWN;
      case DOWN -> UP;
    };
  }
}


--- File: GameItem.java ---

package com.example.htmlmud.domain.model;

import java.util.HashMap;
import java.util.Map;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data // Lombok
@NoArgsConstructor
@AllArgsConstructor
public class GameItem {

  // 1. 唯一識別 (UUID)
  // 每個物品都有獨立 ID，方便追蹤 (例如防止複製 Bug)
  private String id;

  // 2. 指向樣板的指標 (只存 ID)
  private String templateId;

  private int level;

  // 3. 動態數據 (會變的)
  private int currentDurability; // 耐久性
  private int amount; // 堆疊數量 (如果是藥水/錢幣)

  // 4. 隨機數值/詞綴 (Affixes)
  // 例如：{ "attack_bonus": 5, "crafter": "玩家A" }
  private Map<String, Object> dynamicProps = new HashMap<>();

  // 輔助方法：獲取顯示名稱 (包含強化等級)
  // e.g., "鐵劍 (+5)"
  public String getDisplayName(ItemTemplate tpl) {
    if (level > 1) {
      return tpl.name() + " (+" + level + ")";
    }
    return tpl.name();
  }

  // 業務邏輯直接寫在 POJO 裡
  public void decreaseDurability(int amount) {
    this.currentDurability -= amount;
    if (this.currentDurability < 0)
      this.currentDurability = 0;
  }
}


--- File: LivingState.java ---

package com.example.htmlmud.domain.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import java.util.HashMap;
import java.util.Map;

// 這個物件會被序列化存入 players.state_json 和 mobs.state_json
@JsonIgnoreProperties(ignoreUnknown = true)
public class LivingState {
  public String gender;

  public int level = 1;
  public int hp;
  public int maxHp;
  public int mp;
  public int maxMp;

  // 基礎屬性
  public Map<String, Integer> attributes = new HashMap<>(); // STR, DEX, INT

  // 戰鬥狀態 (不存入 DB，或是標記 @JsonIgnore)
  @JsonIgnore
  public transient boolean isDead = false;

  // 建構子與輔助方法...
  @JsonIgnore
  public boolean isDead() {
    return hp <= 0;
  }

  public LivingState deepCopy() {
    LivingState copy = new LivingState();
    copy.level = this.level;
    copy.hp = this.hp;
    copy.maxHp = this.maxHp;
    copy.mp = this.mp;
    copy.maxMp = this.maxMp;
    // Map 也要複製
    if (this.attributes != null) {
      copy.attributes = new HashMap<>(this.attributes);
    }
    return copy;
  }
}


--- File: MobKind.java ---

package com.example.htmlmud.domain.model;

public enum MobKind {
  FRIENDLY, // 友善 (村長, 商人)
  NEUTRAL, // 中立 (鹿, 黃牛 - 被打才會反擊)
  AGGRESSIVE, // 主動攻擊 (哥布林, 狼)
  BOSS // 首領 (顯示時可能會有特殊顏色)
}


--- File: PlayerRecord.java ---

package com.example.htmlmud.domain.model;

import java.util.List;

// 這是在 Actor 之間傳遞的快照 (Snapshot)
public record PlayerRecord(

    String id,

    String name,

    String nickname,

    String currentRoomId,

    // 注意：如果是 Record，這裡最好是 Deep Copy 後的資料
    LivingState state,

    List<GameItem> inventory

) {
}


--- File: RoomFlag.java ---

package com.example.htmlmud.domain.model;

public enum RoomFlag {
  // Environment
  INDOORS, OUTDOORS, DARK, UNDERWATER,
  // Combat
  SAFE_ZONE, NO_PVP, ARENA,
  // Movement
  NO_RECALL, NO_TELEPORT, PRIVATE,
  // Special
  NO_MAGIC, BANK, SHOP
}


--- File: RoomStateRecord.java ---

package com.example.htmlmud.domain.model;

import java.util.List;

public record RoomStateRecord(String roomId, String zoneId, List<GameItem> droppedItems) {

}


--- File: ItemTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.Map;

// 5. 物品/裝備重置 (ItemReset)
public record ItemTemplate(

    String id,

    String name, // "鐵劍"

    String description, // "一把普通的鐵劍。"

    String slot, // "inventory"(背包), "weapon"(手), "body"(身)...

    int maxDurability, // 最大耐久 100

    int baseAttack, // 基礎攻擊 10

    int baseDefense, // 基礎防禦 10

    double chance, // 0.0 - 1.0 (機率)

    Map<String, Object> extraProps // 其他靜態屬性
) {
}


--- File: MobTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.Set;
import com.example.htmlmud.domain.model.MobKind;
import lombok.Builder;

@Builder(toBuilder = true)
public record MobTemplate(

    String id,

    String name,

    String[] aliases,

    MobKind kind,

    int level,

    int maxHp,

    int damage,

    String roomDescription,

    String lookDescription,

    int expReward, // 死亡給多少經驗

    boolean isAggressive, // 是否主動攻擊

    boolean isInvincible, // 是否無敵

    Set<String> dialogues, // 預設對話庫
    // 掉落表 ID, 商店列表 ID...
    Integer shopId) {
}


--- File: RoomExit.java ---

package com.example.htmlmud.domain.model.map;

import com.example.htmlmud.infra.persistence.json.ExitDeserializer;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import lombok.Builder;

// 3. 出口 (RoomExit) - 支援單向、門鎖、隱藏
@Builder(toBuilder = true)
@JsonDeserialize(using = ExitDeserializer.class)
public record RoomExit(

    @JsonProperty("targetId") String targetRoomId, // 目標房間 ID

    String doorName, // 門的名稱 (null 代表無門，直接通行)

    boolean isLocked, // 預設是否上鎖

    String keyId, // 需要的鑰匙 Template ID

    boolean isHidden, // 是否隱藏 (需 search)

    boolean pickProof // 是否無法被盜賊撬開？

) {
  // 為了方便 JSON 簡寫 (如果只有 targetId)，可以透過 Custom Deserializer 處理，
  // 或者在 Java 程式碼中提供一個簡易建構的靜態方法。
  public static RoomExit of(String targetId) {
    return new RoomExit(targetId, null, false, null, false, false);
  }
}


--- File: RoomTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.List;
import java.util.Map;
import java.util.Set;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;

// 2. 房間 (Room)
@Builder(toBuilder = true)
public record RoomTemplate(

    String id, // e.g., square

    String zoneId,

    String name, // e.g., "中央廣場"

    String description, // 描述

    List<String> flags, // e.g., ["SAFE", "OUTDOORS"]

    Map<String, RoomExit> exits, // Key: 方向 (north, east), Value: 出口詳細資訊

    Set<SpawnRule> spawnRules,

    List<String> items, // [ "newbie_village:village_bread" ]

    @JsonProperty("extra_data") Map<String, Object> extraData // 額外擴充資料 (e.g. 腳本觸發參數)

) {
}


--- File: SpawnRule.java ---

package com.example.htmlmud.domain.model.map;

import com.fasterxml.jackson.annotation.JsonProperty;

// 4. 怪物重生設定 (MobReset)
public record SpawnRule(

    @JsonProperty("mobId") String mobTemplateId, // 怪物原型 mobTemplateId

    int count, // 該房間上限幾隻

    int respawnTime, // 重生秒數 (-1 代表不重生，0 代表使用區域預設)

    double respawnChance // 重生機率 (0.0 - 1.0)

) {
}


--- File: ZoneTemplate.java ---

package com.example.htmlmud.domain.model.map;

import java.util.List;

// 1. 區域 (Zone) - 靜態地圖檔的根物件
public record ZoneTemplate(

    String id, // e.g., "area_newbie"

    String name, // e.g., "新手村"

    int minLevel,

    int maxLevel,

    int respawnRate, // 怪物重生間隔 (秒)

    List<String> authors, // 作者與可修改者

    List<String> flags // e.g., ["SAFE", "OUTDOORS"]

) {
}


--- File: LivingStateService.java ---

package com.example.htmlmud.domain.service;

import com.example.htmlmud.domain.event.PlayerEvents;
import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class LivingStateService {

  private final ApplicationEventPublisher eventPublisher;

  public void processLevelUp(String playerId, int currentExp) {
    // 1. 執行核心邏輯 (計算等級、加屬性...)
    // int newLevel = calculateLevel(currentExp);

    // 2. 狀態改變完成後，發布事件 (這是一個 Fact)
    // 這行程式碼不關心誰要聽，它只負責說「這件事發生了」
    // eventPublisher.publishEvent(new PlayerEvents.LevelUp(playerId, newLevel, null));
  }
}


--- File: ItemTemplateMapper.java ---

package com.example.htmlmud.infra.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.infra.persistence.entity.ItemTemplateEntity;

@Mapper(componentModel = "spring",
    // 忽略沒對應到的欄位 (重要！防止 MapStruct 報錯說 record 缺欄位)
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    // 當來源是 null 時不覆蓋目標 (選用，視需求而定)
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface ItemTemplateMapper {

  // 1. Entity -> Record (載入時用)
  // MapStruct 會自動對應相同名稱的欄位 (nickname -> nickname)
  ItemTemplate toRecord(ItemTemplateEntity entity);

  // 2. Record -> Entity (存檔時用)
  // 這裡我們通常是用 "更新" 模式，而不是 "新建"
  // @MappingTarget 代表要把 source 的值填入 target
  void updateEntityFromRecord(ItemTemplate source, @MappingTarget ItemTemplateEntity target);
}


--- File: PlayerMapper.java ---

package com.example.htmlmud.infra.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.ReportingPolicy;
import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;

@Mapper(componentModel = "spring",
    // 忽略沒對應到的欄位 (重要！防止 MapStruct 報錯說 record 缺欄位)
    unmappedTargetPolicy = ReportingPolicy.IGNORE,
    // 當來源是 null 時不覆蓋目標 (選用，視需求而定)
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface PlayerMapper {

  // 1. Entity -> Record (載入時用)
  // MapStruct 會自動對應相同名稱的欄位 (nickname -> nickname)
  PlayerRecord toRecord(CharacterEntity entity);

  // 2. Record -> Entity (存檔時用)
  // 這裡我們通常是用 "更新" 模式，而不是 "新建"
  // @MappingTarget 代表要把 source 的值填入 target
  void updateEntityFromRecord(PlayerRecord source, @MappingTarget CharacterEntity target);
}


--- File: CharacterEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.time.LocalDateTime;
import java.util.List;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import com.example.htmlmud.domain.model.GameItem;
import com.example.htmlmud.domain.model.LivingState;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Index;
import jakarta.persistence.PrePersist;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "characters",
    indexes = {@Index(name = "idx_uid_name", columnList = "uid,name", unique = true)})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CharacterEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  // 邏輯關聯 (這裡存 ID 比較簡單，避免 N+1 或 Lazy Loading 問題)
  @Column(nullable = false)
  private String uid;

  private String name;

  private String nickname;

  @Column(name = "look_description")
  private String lookDescription;

  @Column(name = "current_room_id")
  private String currentRoomId;

  // 關鍵：自動將 Java 物件序列化為 MySQL JSON
  // 使用 MySQL 8.4 JSON 類型儲存擴充資料 (例如: HP, Mana, EXP, 背包)
  // 這樣未來新增屬性不用一直改 Table Schema
  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "state_json")
  private LivingState state;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "inventory_json")
  private List<GameItem> inventory; // 背包系統

  // @JdbcTypeCode(SqlTypes.JSON)
  // @Column(name = "skills_json")
  // public PlayerSkills skills; // 技能系統 對應 skills_json

  // @JdbcTypeCode(SqlTypes.JSON)
  // @Column(name = "config_json")
  // public PlayerConfig config; // 設定檔 對應 config_json

  private LocalDateTime createdAt;

  private LocalDateTime modifyAt;

  @PrePersist
  protected void onCreate() {
    createdAt = LocalDateTime.now();
    if (currentRoomId == null)
      currentRoomId = "newbie_village:entrance"; // 預設新手村
  }
}


--- File: ItemTemplateEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name = "item_templates")
@Data
public class ItemTemplateEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  private String name;

  private String description;

  private String slot;

  @Column(name = "max_durability")
  private Integer maxDurability;

  @Column(name = "base_attack")
  private Integer baseAttack;

  @Column(name = "base_defense")
  private Integer baseDefense;

  private Double chance;

}


--- File: RoomStateEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.util.List;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import com.example.htmlmud.domain.model.GameItem;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.IdClass;
import jakarta.persistence.Table;
import lombok.Data;

@Entity
@Table(name = "rooms_state")
@IdClass(RoomStateId.class)
@Data
public class RoomStateEntity {

  @Id
  @Column(name = "room_id", nullable = false)
  private String roomId;

  @Id
  @Column(name = "zone_id", nullable = false)
  private String zoneId;

  @JdbcTypeCode(SqlTypes.JSON)
  @Column(name = "dropped_items_json")
  private List<GameItem> droppedItems;

}


--- File: RoomStateId.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.io.Serializable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class RoomStateId implements Serializable {
  private String roomId;
  private String zoneId;
}


--- File: UserEntity.java ---

package com.example.htmlmud.infra.persistence.entity;

import java.time.LocalDateTime;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.UUID)
  private String id;

  @Column(unique = true, nullable = false)
  private String username;

  @Column(nullable = false)
  private String passwordHash;

  private LocalDateTime createdAt;

  private LocalDateTime lastLoginAt;

  // 這裡甚至不需要關聯 Character 列表，除非後台管理需要
}


--- File: ExitDeserializer.java ---

package com.example.htmlmud.infra.persistence.json;

import java.io.IOException;
import com.example.htmlmud.domain.model.map.RoomExit;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;

public class ExitDeserializer extends JsonDeserializer<RoomExit> {

  @Override
  public RoomExit deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
    // 1. 判斷當前 JSON Token 是字串還是物件
    if (p.currentToken() == JsonToken.VALUE_STRING) {
      // 【簡寫模式】 "north": "square"
      // 直接把字串當成 targetId
      return RoomExit.of(p.getText());
    } else if (p.currentToken() == JsonToken.START_OBJECT) {
      // 【詳寫模式】 "east": { "targetId": "village_elder_house", "doorName": "厚重的鐵門", "isLocked": true,
      // "isHidden": false, "keyId": "village_elder_key", "pickProof": true }
      // 讀取整個物件節點
      JsonNode node = p.getCodec().readTree(p);

      // 優先讀取 "targetId" (與 RoomExit 的 JsonProperty 一致)，若無則讀取 "targetId"
      String targetId = node.has("targetId") ? node.get("targetId").asText() : null;

      // 讀取選填欄位 (處理 null)
      String doorName = node.has("doorName") ? node.get("doorName").asText() : null;
      boolean isLocked = node.has("isLocked") && node.get("isLocked").asBoolean();
      String keyId = node.has("keyId") ? node.get("keyId").asText() : null;
      boolean isHidden = node.has("isHidden") && node.get("isHidden").asBoolean();
      boolean pickProof = node.has("pickProof") && node.get("pickProof").asBoolean();

      return new RoomExit(targetId, doorName, isLocked, keyId, isHidden, pickProof);
    }

    throw new IOException("Invalid exit format: expected String or Object");
  }
}


--- File: CharacterRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;

public interface CharacterRepository extends JpaRepository<CharacterEntity, String> {
  Optional<CharacterEntity> findByUidAndName(String uid, String name);

  boolean existsByUidAndName(String uid, String name);

}


--- File: ItemTemplateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.ItemTemplateEntity;

public interface ItemTemplateRepository extends JpaRepository<ItemTemplateEntity, String> {

}


--- File: RoomStateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.RoomStateEntity;
import com.example.htmlmud.infra.persistence.entity.RoomStateId;

public interface RoomStateRepository extends JpaRepository<RoomStateEntity, RoomStateId> {

  Optional<RoomStateEntity> findByRoomIdAndZoneId(String roomId, String zoneId);

}


--- File: TemplateRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import org.springframework.stereotype.Component;
import com.example.htmlmud.domain.model.map.ItemTemplate;
import com.example.htmlmud.domain.model.map.MobTemplate;
import com.example.htmlmud.domain.model.map.RoomTemplate;
import com.example.htmlmud.domain.model.map.ZoneTemplate;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Component
@RequiredArgsConstructor
@Slf4j
public class TemplateRepository {

  // 儲存所有的靜態資料
  // Key: 絕對 ID (e.g., "newbie_village:sword")
  private final Map<String, ZoneTemplate> zoneTemplates = new ConcurrentHashMap<>();
  private final Map<String, RoomTemplate> roomTemplates = new ConcurrentHashMap<>();
  private final Map<String, MobTemplate> mobTemplates = new ConcurrentHashMap<>();
  private final Map<String, ItemTemplate> itemTemplates = new ConcurrentHashMap<>();

  // 註冊方法
  public void registerZone(ZoneTemplate tpl) {
    zoneTemplates.put(tpl.id(), tpl);
  }

  // 查詢方法
  public Optional<ZoneTemplate> findZone(String id) {
    return Optional.ofNullable(zoneTemplates.get(id));
  }

  // 這是給 MapLoader 呼叫的，用來填入資料
  public void registerRoom(RoomTemplate tpl) {
    roomTemplates.put(tpl.id(), tpl);
  }

  // 查詢方法
  public Optional<RoomTemplate> findRoom(String id) {
    return Optional.ofNullable(roomTemplates.get(id));
  }

  public void registerMob(MobTemplate tpl) {
    mobTemplates.put(tpl.id(), tpl);
  }

  public Optional<MobTemplate> findMob(String id) {
    return Optional.ofNullable(mobTemplates.get(id));
  }

  public void registerItem(ItemTemplate tpl) {
    itemTemplates.put(tpl.id(), tpl);
  }

  public Optional<ItemTemplate> findItem(String id) {
    return Optional.ofNullable(itemTemplates.get(id));
  }


  // 檢查資料完整性 (Server 啟動時檢查)
  public void validate() {
    // 檢查 room 的 exit 是否指向存在的 room id
    // 檢查 mob 的 loot table 是否指向存在的 item id
  }
}


--- File: UserRepository.java ---

package com.example.htmlmud.infra.persistence.repository;

import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.htmlmud.infra.persistence.entity.UserEntity;

public interface UserRepository extends JpaRepository<UserEntity, String> {

  Optional<UserEntity> findByUsername(String username);

  boolean existsByUsername(String username);

}


--- File: PlayerPersistenceService.java ---

package com.example.htmlmud.infra.persistence.service;

import com.example.htmlmud.domain.model.PlayerRecord;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.infra.mapper.PlayerMapper;
import com.example.htmlmud.infra.persistence.entity.CharacterEntity;
import com.example.htmlmud.infra.persistence.repository.CharacterRepository;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

@Slf4j
@Service
@RequiredArgsConstructor
public class PlayerPersistenceService {

  private final PlayerMapper mapper; // 注入 MapStruct
  private final CharacterRepository playerRepository;

  // 1. 緩衝佇列 (Thread-Safe)
  // LinkedBlockingQueue 是最適合生產者-消費者模式的結構
  private final BlockingQueue<PlayerRecord> saveQueue = new LinkedBlockingQueue<>();

  // 控制迴圈的旗標
  private volatile boolean running = true;

  /**
   * 【對外 API】非同步存檔 Actor 呼叫這個方法時，幾乎是瞬間完成的。
   */
  public void saveAsync(PlayerRecord record) {
    if (record == null)
      return;

    // 丟入佇列，如果不滿就立刻返回，不會阻塞
    if (!saveQueue.offer(record)) {
      log.error("存檔佇列已滿！可能資料庫寫入過慢，資料遺失風險: {}", record.id());
    }
  }

  /**
   * 2. 啟動背景消費者執行緒 使用 @PostConstruct 在 Bean 建立後自動執行
   */
  @PostConstruct
  public void init() {
    // 啟動一個虛擬執行緒來專門處理存檔
    Thread.ofVirtual().name("db-writer-player").start(this::processQueue);
  }

  /**
   * 3. 消費者迴圈 (批次寫入邏輯)
   */
  private void processQueue() {
    log.info("Write-Behind DB Writer started.");

    // 用來暫存批次資料的 List
    List<PlayerRecord> batch = new ArrayList<>();

    while (running) {
      try {
        // A. 從佇列取出一筆 (如果空的，這裡會阻塞等待，節省 CPU)
        // 使用 poll 設定超時，這樣我們可以定期檢查 running 狀態或處理剩餘批次
        PlayerRecord record = saveQueue.poll(1, java.util.concurrent.TimeUnit.SECONDS);

        if (record != null) {
          batch.add(record);
        }

        // B. 檢查是否需要寫入 DB (滿足數量 或 佇列沒東西了但還有殘存資料)
        // 條件：累積滿 50 筆 OR (佇列空了 且 手上還有資料)
        if (batch.size() >= 50 || (record == null && !batch.isEmpty())) {
          flushBatch(batch);
        }

        // C. 額外優化：如果佇列裡還有很多，一口氣全部撈出來 (Drain)
        // 這能大幅提升高負載時的吞吐量
        if (!saveQueue.isEmpty() && batch.size() < 100) {
          saveQueue.drainTo(batch, 100 - batch.size());
          flushBatch(batch); // 再寫一次
        }

      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("DB Writer thread interrupted.");
        break;
      } catch (Exception e) {
        log.error("DB Writer loop error", e);
      }
    }
  }

  /**
   * 4. 實際寫入資料庫
   */
  private void flushBatch(List<PlayerRecord> batch) {
    if (batch.isEmpty())
      return;

    // 使用 Map 來去重，只保留每個 Room 的最新狀態
    Map<String, PlayerRecord> latestRecords = new HashMap<>();
    for (PlayerRecord rec : batch) {
      latestRecords.put(rec.id(), rec);
    }

    // 只寫入去重後的資料
    for (PlayerRecord rec : latestRecords.values()) {
      // 直接用 CharacterRepo 查 (查出來的物件本來就沒有密碼)
      playerRepository.findById(rec.id()).ifPresent(entity -> {

        // Record -> Entity (MapStruct 自動更新)
        // 這行程式碼取代了原本手寫的 entity.setNickname(), entity.setState()...
        mapper.updateEntityFromRecord(rec, entity);

        // 存檔
        playerRepository.save(entity);
      });
    }
  }

  /**
   * 5. 優雅關機 (Graceful Shutdown) 當 Spring Boot 關閉時，確保佇列裡的資料都寫完
   */
  @PreDestroy
  public void shutdown() {
    log.info("Shutting down PersistenceService...");
    running = false; // 停止迴圈讀取

    // 把佇列中剩下的全部寫完
    List<PlayerRecord> remaining = new ArrayList<>();
    saveQueue.drainTo(remaining);

    if (!remaining.isEmpty()) {
      log.info("Flushing remaining {} records...", remaining.size());
      flushBatch(remaining);
    }

    log.info("PersistenceService shutdown complete.");
  }
}


--- File: RoomPersistenceService.java ---

package com.example.htmlmud.infra.persistence.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import org.springframework.stereotype.Service;
import com.example.htmlmud.domain.model.RoomStateRecord;
import com.example.htmlmud.infra.persistence.repository.RoomStateRepository;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Service
@RequiredArgsConstructor
public class RoomPersistenceService {

  private final RoomStateRepository roomRepository;

  // 1. 緩衝佇列 (Thread-Safe)
  // LinkedBlockingQueue 是最適合生產者-消費者模式的結構
  private final BlockingQueue<RoomStateRecord> saveQueue = new LinkedBlockingQueue<>();

  // 控制迴圈的旗標
  private volatile boolean running = true;


  /**
   * 【對外 API】非同步存檔 Actor 呼叫這個方法時，幾乎是瞬間完成的。
   */
  public void saveAsync(RoomStateRecord record) {
    if (record == null)
      return;

    // 丟入佇列，如果不滿就立刻返回，不會阻塞
    if (!saveQueue.offer(record)) {
      log.error("存檔佇列已滿！可能資料庫寫入過慢，資料遺失風險: roomId:{} zoneId:{}", record.roomId(), record.zoneId());
    }
  }


  /**
   * 2. 啟動背景消費者執行緒 使用 @PostConstruct 在 Bean 建立後自動執行
   */
  @PostConstruct
  public void init() {
    // 啟動一個虛擬執行緒來專門處理存檔
    Thread.ofVirtual().name("db-writer-room").start(this::processQueue);
  }

  /**
   * 3. 消費者迴圈 (批次寫入邏輯)
   */
  private void processQueue() {
    log.info("Write-Behind DB Writer Room started.");

    // 用來暫存批次資料的 List
    List<RoomStateRecord> batch = new ArrayList<>();

    while (running) {
      try {
        // A. 從佇列取出一筆 (如果空的，這裡會阻塞等待，節省 CPU)
        // 使用 poll 設定超時，這樣我們可以定期檢查 running 狀態或處理剩餘批次
        RoomStateRecord record = saveQueue.poll(1, java.util.concurrent.TimeUnit.SECONDS);

        if (record != null) {
          batch.add(record);
        }

        // B. 檢查是否需要寫入 DB (滿足數量 或 佇列沒東西了但還有殘存資料)
        // 條件：累積滿 50 筆 OR (佇列空了 且 手上還有資料)
        if (batch.size() >= 50 || (record == null && !batch.isEmpty())) {
          flushBatch(batch);
        }

        // C. 額外優化：如果佇列裡還有很多，一口氣全部撈出來 (Drain)
        // 這能大幅提升高負載時的吞吐量
        if (!saveQueue.isEmpty() && batch.size() < 100) {
          saveQueue.drainTo(batch, 100 - batch.size());
          flushBatch(batch); // 再寫一次
        }

      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.warn("DB Writer thread interrupted.");
        break;
      } catch (Exception e) {
        log.error("DB Writer loop error", e);
      }
    }
  }

  /**
   * 4. 實際寫入資料庫
   */
  private void flushBatch(List<RoomStateRecord> batch) {
    if (batch.isEmpty())
      return;

    // 使用 Map 來去重，只保留每個 Room 的最新狀態
    Map<String, RoomStateRecord> latestRecords = new HashMap<>();
    for (RoomStateRecord rec : batch) {
      // key 可以是 roomId + zoneId
      String key = rec.zoneId() + ":" + rec.roomId();
      latestRecords.put(key, rec);
    }

    // 只寫入去重後的資料
    for (RoomStateRecord rec : latestRecords.values()) {
      // 直接用 CharacterRepo 查 (查出來的物件本來就沒有密碼)
      roomRepository.findByRoomIdAndZoneId(rec.roomId(), rec.zoneId()).ifPresent(entity -> {

        // entity.setId(rec.id());
        // entity.setDroppedItems(rec.items());
        // entity.setItems(rec.items());

        // 存檔
        roomRepository.save(entity);
      });
    }
  }

  /**
   * 5. 優雅關機 (Graceful Shutdown) 當 Spring Boot 關閉時，確保佇列裡的資料都寫完
   */
  @PreDestroy
  public void shutdown() {
    log.info("Shutting down PersistenceService...");
    running = false; // 停止迴圈讀取

    // 把佇列中剩下的全部寫完
    List<RoomStateRecord> remaining = new ArrayList<>();
    saveQueue.drainTo(remaining);

    if (!remaining.isEmpty()) {
      log.info("Flushing remaining {} records...", remaining.size());
      flushBatch(remaining);
    }

    log.info("PersistenceService shutdown complete.");
  }

}


--- File: MudWebSocketHandler.java ---

package com.example.htmlmud.infra.server;

import java.util.UUID;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;
import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import com.example.htmlmud.domain.context.GameServices;
import com.example.htmlmud.protocol.ActorMessage;
import com.example.htmlmud.protocol.GameCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class MudWebSocketHandler extends TextWebSocketHandler {
  private final GameServices gameServices;
  private final WorldManager worldManager;
  private final SessionRegistry sessionRegistry;

  @Override
  public void afterConnectionEstablished(WebSocketSession session) {
    try {

      // Guest階段 使用工廠方法建立 Guest Actor (ID=0)
      // 將必要的 Service 注入給 Actor，讓 Actor 擁有處理業務的能力
      PlayerActor actor = PlayerActor.createGuest(session, worldManager, gameServices);

      // 啟動 Actor 的虛擬執行緒 (Virtual Thread)
      actor.start();

      // 註冊到網路層 SessionRegistry
      sessionRegistry.register(session, actor);

      log.info("連線建立: {} (Guest Actor Created)", session.getId());
      // eventPublisher.publishEvent(new SessionEvent.Established(session.getId(), Instant.now()));
    } catch (Exception e) {
      log.error("連線初始化失敗", e);
      try {
        session.close();
      } catch (Exception ignored) {
      }
    }
  }

  @Override
  protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {

    // A. 產生 Trace ID (所有 Log 追蹤的源頭)
    // 使用短 UUID 方便閱讀，實務上可用完整的 UUID
    String traceId = UUID.randomUUID().toString().substring(0, 8);

    try {
      PlayerActor actor = sessionRegistry.get(session.getId());
      if (actor != null) {
        // C. 解析指令 (JSON -> Record)
        GameCommand cmd =
            gameServices.objectMapper().readValue(message.getPayload(), GameCommand.class);

        // D. 裝入信封並投遞
        // 這裡不綁定 ScopedValue，因為要跨執行緒傳遞
        actor.send(new ActorMessage(traceId, cmd));
      } else {
        // 找不到 Actor，通常代表連線異常或已被踢除
        log.warn("[{}] 收到訊息但找不到 Actor，關閉連線: {}", traceId, session.getId());
        session.close();
      }
    } catch (Exception e) {
      // JSON 解析失敗或其他錯誤
      log.error("[{}] 訊息處理錯誤: {}", traceId, e.getMessage());
      // 選擇性：回傳錯誤訊息給 Client
    }
  }

  @Override
  public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {

    // 從 Registry 移除並取得 Actor
    PlayerActor actor = sessionRegistry.remove(session.getId());

    if (actor != null) {
      log.info("連線關閉: {} (Actor: {})", session.getId(), actor.getId());

      // 通知 Actor 執行清理邏輯
      // (如果是 Guest 則直接停止，如果是正式玩家則觸發存檔與從 WorldManager 移除)
      actor.handleDisconnect();
    }
  }
}


--- File: SessionRegistry.java ---

package com.example.htmlmud.infra.server;

import org.springframework.stereotype.Component;
import org.springframework.web.socket.WebSocketSession;
import com.example.htmlmud.domain.actor.impl.PlayerActor;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Component
public class SessionRegistry {

  private final Map<String, PlayerActor> sessions = new ConcurrentHashMap<>();

  public void register(WebSocketSession session, PlayerActor actor) {
    sessions.put(session.getId(), actor);
  }

  public PlayerActor remove(String sessionId) {
    return sessions.remove(sessionId);
  }

  public PlayerActor get(String sessionId) {
    return sessions.get(sessionId);
  }

  // 額外功能：踢掉某個 Session (例如重複登入踢人)
  // 或是統計當前連線數 (含 Guest)
  public int getConnectionCount() {
    return sessions.size();
  }

}


--- File: WorldInitializer.java ---

package com.example.htmlmud.infra.server;

import com.example.htmlmud.application.service.WorldManager;
import com.example.htmlmud.domain.context.GameServices;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@Order(1) // 如果有多個初始化步驟，可以控制順序
@RequiredArgsConstructor
public class WorldInitializer implements ApplicationRunner {

  private final WorldManager worldManager;
  // private final GameLoop gameLoop;


  @Override
  public void run(ApplicationArguments args) throws Exception {
    log.info("=== MUD World Initialization Started ===");

    long start = System.currentTimeMillis();

    // 1. 載入地圖 (從原本 WorldManager 的 @PostConstruct 移過來)
    worldManager.loadWorld();

    // 2. (未來) 啟動全域計時器 (Tick Loop)
    // gameLoop.start();

    // 3. (未來) 載入 NPC 或 排行榜快取

    long duration = System.currentTimeMillis() - start;
    log.info("=== MUD World Ready in {} ms ===", duration);
  }
}


--- File: AnsiColor.java ---

package com.example.htmlmud.infra.util;

/**
 * ANSI 顏色碼列舉 包含標準色、高亮色、背景色以及 MUD 常用的 256 色擴展
 */
public enum AnsiColor {

  // --- 控制碼 ---
  RESET("\u001B[0m"), BOLD("\u001B[1m"), // 粗體
  DIM("\u001B[2m"), // 弱體
  ITALIC("\u001B[3m"), // 斜體
  UNDERLINE("\u001B[4m"), // 下劃線
  BLINK("\u001B[5m"), // 閃爍
  INVERSE("\u001B[7m"), // 反白
  HIDDEN("\u001B[8m"), // 隱藏
  STRIKETHROUGH("\u001B[9m"), // 刪除線

  // --- 標準前景色 (Standard Foreground) ---
  BLACK("\u001B[30m"), // 常用於深灰
  RED("\u001B[31m"), // 常用於紅色
  GREEN("\u001B[32m"), // 常用於綠色
  YELLOW("\u001B[33m"), // 常用於黃色
  BLUE("\u001B[34m"), // 常用於藍色
  MAGENTA("\u001B[35m"), // 常用於紫紅色
  CYAN("\u001B[36m"), // 常用於青色
  WHITE("\u001B[37m"), // 常用於白色

  // --- 高亮前景色 (Bright Foreground) ---
  BRIGHT_BLACK("\u001B[90m"), // 常用於高亮深灰
  BRIGHT_RED("\u001B[91m"), // 常用於高亮紅色
  BRIGHT_GREEN("\u001B[92m"), // 常用於高亮綠色
  BRIGHT_YELLOW("\u001B[93m"), // 常用於高亮黃色
  BRIGHT_BLUE("\u001B[94m"), // 常用於高亮藍色
  BRIGHT_MAGENTA("\u001B[95m"), // 常用於高亮紫紅色
  BRIGHT_CYAN("\u001B[96m"), // 常用於高亮青色
  BRIGHT_WHITE("\u001B[97m"), // 常用於高亮白色

  // --- MUD 特選 256 色 (Extended Colors) ---
  // 裝備與物品常用色
  ORANGE("\u001B[38;5;208m"), // 傳說物品
  GOLD("\u001B[38;5;220m"), // 金幣、神器
  SILVER("\u001B[38;5;250m"), // 銀幣、金屬
  BRONZE("\u001B[38;5;136m"), // 銅幣
  PINK("\u001B[38;5;205m"), // 特殊/女性角色
  PURPLE("\u001B[38;5;129m"), // 史詩物品

  // 元素與環境常用色
  LAVA_RED("\u001B[38;5;196m"), // 熔岩、致命傷害
  ICE_BLUE("\u001B[38;5;51m"), // 冰凍、魔法
  NATURE_GREEN("\u001B[38;5;46m"), // 劇毒、治療
  DARK_GREY("\u001B[38;5;236m"), // 陰影、潛形
  LIGHT_GREY("\u001B[38;5;244m"), // 石頭、牆壁
  BROWN("\u001B[38;5;94m"), // 木頭、泥土

  // --- 背景色 (Background) ---
  BG_BLACK("\u001B[40m"), // 常用於背景色深灰
  BG_RED("\u001B[41m"), // 常用於背景色紅色
  BG_GREEN("\u001B[42m"), // 常用於背景色綠色
  BG_YELLOW("\u001B[43m"), // 常用於背景色黃色
  BG_BLUE("\u001B[44m"), // 常用於背景色藍色
  BG_MAGENTA("\u001B[45m"), // 常用於背景色紫紅色
  BG_CYAN("\u001B[46m"), // 常用於背景色青色
  BG_WHITE("\u001B[47m"); // 常用於背景色白色

  private final String code;

  AnsiColor(String code) {
    this.code = code;
  }

  @Override
  public String toString() {
    return code;
  }

  public String getCode() {
    return code;
  }
}


--- File: ColorText.java ---

package com.example.htmlmud.infra.util;

public class ColorText {

  // 1. 基礎包裝方法
  public static String wrap(AnsiColor color, String text) {
    return color + text + AnsiColor.RESET;
  }

  // 2. 複合樣式 (例如：粗體紅色)
  public static String wrap(AnsiColor color, AnsiColor style, String text) {
    return style + "" + color + text + AnsiColor.RESET;
  }

  // --- 語義化 Helper Methods (MUD 專用) ---

  // 系統訊息 (青色)
  public static String system(String text) {
    return wrap(AnsiColor.CYAN, text);
  }

  // 錯誤訊息 (紅色)
  public static String error(String text) {
    return wrap(AnsiColor.RED, text);
  }

  // 警告訊息 (黃色)
  public static String warn(String text) {
    return wrap(AnsiColor.YELLOW, text);
  }

  // NPC 名稱 (綠色)
  public static String npc(String name) {
    return wrap(AnsiColor.GREEN, name);
  }

  // 怪物名稱 (紅色粗體)
  public static String mob(String name) {
    return wrap(AnsiColor.RED, AnsiColor.BOLD, name);
  }

  // 玩家名稱 (亮藍色)
  public static String player(String name) {
    return wrap(AnsiColor.BRIGHT_BLUE, name);
  }

  // 物品 (金色)
  public static String item(String name) {
    return wrap(AnsiColor.GOLD, name);
  }

  // 傷害數值 (熔岩紅)
  public static String damage(int dmg) {
    return wrap(AnsiColor.LAVA_RED, String.valueOf(dmg));
  }

  // 治療數值 (自然綠)
  public static String heal(int amount) {
    return wrap(AnsiColor.NATURE_GREEN, String.valueOf(amount));
  }

  // 房間名稱 (亮白色)
  public static String room(String name) {
    return wrap(AnsiColor.BRIGHT_WHITE, name);
  }

  // 房間描述 (預設色/灰色)
  public static String roomDesc(String desc) {
    return wrap(AnsiColor.LIGHT_GREY, desc);
  }

  // 出口名稱 (黃色)
  public static String exit(String name) {
    return wrap(AnsiColor.YELLOW, name);
  }

  // 物品描述 (白色)
  public static String itemDesc(String desc) {
    return wrap(AnsiColor.WHITE, desc);
  }

  // 物品稀有度 (紫色)
  public static String rarity(String rarity) {
    return wrap(AnsiColor.PURPLE, rarity);
  }
}


--- File: IdUtils.java ---

package com.example.htmlmud.infra.util;

public class IdUtils {

  /**
   * 解析 ID：將相對 ID 轉為絕對 ID * @param currentZoneId 當前所在的區域 ID (e.g., "newbie_village")
   * 
   * @param rawId 原始 ID (可能是 "square" 或 "dark_forest:clearing")
   * @return 完整的絕對 ID
   */
  public static String resolveId(String currentZoneId, String rawId) {
    if (rawId == null || rawId.isBlank()) {
      return null;
    }
    // 如果已經有冒號，就回傳原始值；否則加上前綴
    if (rawId.contains(":")) {
      return rawId;
    }
    return currentZoneId + ":" + rawId;
  }
}


--- File: ActorMessage.java ---

package com.example.htmlmud.protocol;

public record ActorMessage(String traceId, GameCommand command) {

}


--- File: ConnectionState.java ---

package com.example.htmlmud.protocol;

public enum ConnectionState {
  CONNECTED, // 剛連線：等待輸入帳號 或 'new'
  ENTERING_PASSWORD, // 已輸入帳號，等待密碼
  CREATING_USERNAME, // 正在輸入新帳號名稱
  CREATING_PASSWORD, // 正在設定新密碼
  ENTERING_CHAR_NAME, // 正在輸入新角色名稱
  ENTERING_CHAR_GENDER, // 正在選擇性別
  ENTERING_CHAR_RACE, // 正在選擇種族
  ENTERING_CHAR_CLASS, // 正在選擇職業
  ENTERING_CHAR_ATTRIBUTES, // 正在選擇等級
  IN_GAME // 遊戲中：正常遊玩
}


--- File: GameCommand.java ---

package com.example.htmlmud.protocol;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

// 定義外部傳來的 JSON 指令
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
@JsonSubTypes({
    // @JsonSubTypes.Type(value = GameCommand.Login.class, name = "LOGIN"),
    // @JsonSubTypes.Type(value = GameCommand.Move.class, name = "MOVE"),
    // @JsonSubTypes.Type(value = GameCommand.Chat.class, name = "CHAT"),
    @JsonSubTypes.Type(value = GameCommand.Input.class, name = "INPUT") // <--- 您的核心需求
})
public sealed interface GameCommand {
  // 1. 登入指令 (維持結構化，因為安全性)
  // record Login(String username, String password) implements GameCommand {
  // }
  // 2. 通用字串指令 (您的 MVP 核心)
  // 玩家輸入 "kill goblin", "look", "north" 全部都包在這裡面
  record Input(String text) implements GameCommand {
  }
  // record Move(String direction) implements GameCommand {}
  // record Chat(String content) implements GameCommand {}
}


--- File: RoomMessage.java ---

package com.example.htmlmud.protocol;

import java.util.concurrent.CompletableFuture;
import com.example.htmlmud.domain.actor.impl.PlayerActor;

/**
 * 定義所有發送給 RoomActor 的內部訊息協定 使用 Sealed Interface 限制訊息類型，配合 switch pattern matching
 */
public sealed interface RoomMessage permits RoomMessage.PlayerEnter, RoomMessage.PlayerLeave,
    RoomMessage.TryPickItem, RoomMessage.Look, RoomMessage.Say {

  /**
   * 玩家進入房間
   *
   * @param player 玩家 Actor 實例
   * @param future 用於通知移動完成 (可選)
   */
  record PlayerEnter(PlayerActor player, CompletableFuture<Void> future) implements RoomMessage {
  }

  /**
   * 玩家離開房間
   *
   * @param playerId 離開的玩家 ID
   */
  record PlayerLeave(String playerId) implements RoomMessage {
  }

  /**
   * 查看房間 (Look 指令)
   *
   * @param playerId 發出指令的玩家 ID (用於過濾"自己看到自己")
   * @param result 用於回傳房間描述字串
   */
  record Look(String playerId, CompletableFuture<String> result) implements RoomMessage {
  }

  /**
   * 說話/廣播
   *
   * @param sourcePlayerId 說話者 ID
   * @param content 內容
   */
  record Say(String sourcePlayerId, String content) implements RoomMessage {
  }

  record TryPickItem(String itemId, PlayerActor picker) implements RoomMessage {
  }

}


--- File: HtmlmudApplicationTests.java ---

package com.example.htmlmud;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HtmlmudApplicationTests {

	@Test
	void contextLoads() {
	}

}
